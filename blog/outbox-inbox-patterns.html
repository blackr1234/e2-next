<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="preload" as="image" href="/e2-next/nextjs.svg"/><link rel="stylesheet" href="/e2-next/_next/static/css/8b3b49f5a80261a3.css" data-precedence="next"/><link rel="stylesheet" href="/e2-next/_next/static/css/d3df112486f97f47.css" data-precedence="next"/><link rel="stylesheet" href="/e2-next/_next/static/css/47422044c9b2dd2c.css" data-precedence="next"/><link rel="stylesheet" href="/e2-next/_next/static/css/7bfe9ed714480baa.css" data-precedence="next"/><link rel="stylesheet" href="/e2-next/_next/static/css/c50e9134a56688df.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/e2-next/_next/static/chunks/webpack-a1c00121deb96d97.js"/><script src="/e2-next/_next/static/chunks/4bd1b696-0937feffdffed3be.js" async=""></script><script src="/e2-next/_next/static/chunks/1517-4a3809d10f30a6f7.js" async=""></script><script src="/e2-next/_next/static/chunks/main-app-05c45cc8f30d6cea.js" async=""></script><script src="/e2-next/_next/static/chunks/7833-c0135c68ec6a11ed.js" async=""></script><script src="/e2-next/_next/static/chunks/app/layout-3655101740c91656.js" async=""></script><script src="/e2-next/_next/static/chunks/app/page-63c121085425a904.js" async=""></script><script src="/e2-next/_next/static/chunks/13b76428-e7d338032a603c0d.js" async=""></script><script src="/e2-next/_next/static/chunks/5496-2276c5d321184651.js" async=""></script><script src="/e2-next/_next/static/chunks/app/blog/(blogPosts)/layout-b960ed9b018b1aae.js" async=""></script><title>Blog posts</title><meta name="description" content="Powered by Next.js and React"/><link rel="icon" href="/e2-next/favicon.ico" type="image/x-icon" sizes="48x48"/><link href="https://fonts.googleapis.com/css2?family=Roboto:ital,wght@0,100;0,300;0,400;0,500;0,700;0,900;1,100;1,300;1,400;1,500;1,700;1,900&amp;display=swap" rel="stylesheet"/><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css"/><script src="/e2-next/_next/static/chunks/polyfills-42372ed130431b0a.js" noModule=""></script></head><body><div class="vstack gap-5"><div class="text-center vstack gap-5"><div class="Ribbon_ribbon-left__fObbI"><img class="Ribbon_image__2_FYh" src="/e2-next/nextjs.svg"/></div><a role="button" tabindex="0" href="https://blackr1234.github.io/e2/" class="ButtonToOtherSites_button__K4zwN btn btn-secondary btn-sm">➜ Old React website</a><div><code class="SiteHeader_name__pxX08">Chung Cheuk Hang Michael</code><code class="SiteHeader_title__MUwhy">Java Web Developer</code></div><nav style="margin-top:-1.5rem;margin-bottom:-1rem" class="justify-content-center navbar navbar-expand-md navbar-dark"><button type="button" aria-label="Toggle navigation" class="navbar-toggler collapsed"><span class="navbar-toggler-icon"></span></button><div class="justify-content-center navbar-collapse collapse"><div class="justify-content-center navbar-nav nav-underline"><div class="nav-item"><a href="/e2-next/" draggable="false" data-rr-ui-event-key="/" class="nav-link">Home</a></div><div class="nav-item"><a href="/e2-next/work" draggable="false" data-rr-ui-event-key="/work" class="nav-link">Work</a></div><div class="nav-item"><a href="/e2-next/hobbyProjects" draggable="false" data-rr-ui-event-key="/hobbyProjects" class="nav-link">Hobby projects</a></div><div class="nav-item"><a href="/e2-next/personality" draggable="false" data-rr-ui-event-key="/personality" class="nav-link">Personality</a></div><div class="nav-item"><a href="/e2-next/blog" draggable="false" data-rr-ui-event-key="/blog" class="nav-link">Blog</a></div></div></div></nav></div><div class="vstack gap-5"><div style="display:flex;justify-content:space-between"><a role="button" tabindex="0" href="/e2-next/blog/bruno-http-api-test" class="layout_next-button__HNNsZ btn btn-primary btn-sm"><i class="fa-solid fa-arrow-left"></i><span class="layout_responsive-button-text__Z1usr" style="margin-left:0.75rem"><strong>Bruno HTTP API 測試工具</strong></span></a><a role="button" tabindex="0" href="/e2-next/blog/spring-boot-micrometer-tracing" class="layout_prev-button__uHSER btn btn-primary btn-sm"><span class="layout_responsive-button-text__Z1usr" style="margin-right:0.75rem"><strong>Spring Boot 3 micrometer tracing</strong></span><i class="fa-solid fa-arrow-right"></i></a></div><div class="justify-content-center row"><h1 class="text-center" style="margin-bottom:1rem"><strong>可靠訊息傳遞：Outbox &amp; inbox patterns</strong></h1></div><div class="justify-content-center row"><img loading="lazy" src="/e2-next/blog/2024-03/outbox-inbox-patterns/thumbnail.svg?v=202503" class="object-fit-contain layout_image__iOEk8"/></div><div class="row"><div style="word-wrap:break-word"><a href="#table-of-contents" style="text-decoration:none"><h1 id="table-of-contents" class="mdx-components_heading__HrNl3 mdx-components_heading-new-section__YU39B" style="z-index:1"><i class="fa-solid fa-link mdx-components_heading-link__r6M6c"></i>Table of contents</h1></a>
<ul>
<li class="mdx-components_list-item__fJ1NL"><span><a href="#1-%E5%8F%AF%E9%9D%A0%E8%A8%8A%E6%81%AF%E5%82%B3%E9%81%9E%E5%95%8F%E9%A1%8C" class="common_anchor__kGNsN">1 可靠訊息傳遞問題</a></span></li>
<li class="mdx-components_list-item__fJ1NL"><span><a href="#2-%E8%A8%8A%E6%81%AF%E5%82%B3%E9%81%9E%E6%97%A2%E5%94%94%E5%90%8C%E6%83%85%E6%B3%81" class="common_anchor__kGNsN">2 訊息傳遞既唔同情況</a></span></li>
<li class="mdx-components_list-item__fJ1NL"><span><a href="#3-%E8%A8%8A%E6%81%AF%E5%82%B3%E9%81%9E%E4%BF%9D%E8%AD%89" class="common_anchor__kGNsN">3 訊息傳遞保證</a></span></li>
<li class="mdx-components_list-item__fJ1NL"><span><a href="#4-outbox-pattern" class="common_anchor__kGNsN">4 Outbox pattern</a></span>
<ul>
<li class="mdx-components_list-item__fJ1NL"><span><a href="#41-%E5%AF%A6%E7%8F%BE%E6%96%B9%E5%BC%8F" class="common_anchor__kGNsN">4.1 實現方式</a></span></li>
<li class="mdx-components_list-item__fJ1NL"><span><a href="#42-%E6%89%80%E6%9C%89%E6%9C%89%E5%8F%AF%E8%83%BD%E5%87%BA%E9%8C%AF%E6%97%A2%E6%83%85%E6%B3%81" class="common_anchor__kGNsN">4.2 所有有可能出錯既情況</a></span></li>
</ul>
</li>
<li class="mdx-components_list-item__fJ1NL"><span><a href="#5-inbox-pattern" class="common_anchor__kGNsN">5 Inbox pattern</a></span>
<ul>
<li class="mdx-components_list-item__fJ1NL"><span><a href="#51-%E5%AF%A6%E7%8F%BE%E6%96%B9%E5%BC%8F" class="common_anchor__kGNsN">5.1 實現方式</a></span></li>
<li class="mdx-components_list-item__fJ1NL"><span><a href="#52-%E6%89%80%E6%9C%89%E6%9C%89%E5%8F%AF%E8%83%BD%E5%87%BA%E9%8C%AF%E6%97%A2%E6%83%85%E6%B3%81" class="common_anchor__kGNsN">5.2 所有有可能出錯既情況</a></span></li>
</ul>
</li>
<li class="mdx-components_list-item__fJ1NL"><span><a href="#6-%E8%80%83%E6%85%AE%E4%BA%8B%E9%A0%85" class="common_anchor__kGNsN">6 考慮事項</a></span></li>
<li class="mdx-components_list-item__fJ1NL"><span><a href="#7-%E5%8F%83%E8%80%83%E8%B3%87%E6%96%99" class="common_anchor__kGNsN">7 參考資料</a></span></li>
</ul>
<a href="#1-可靠訊息傳遞問題" style="text-decoration:none"><h1 id="1-可靠訊息傳遞問題" class="mdx-components_heading__HrNl3 mdx-components_heading-new-section__YU39B" style="z-index:1000000"><i class="fa-solid fa-link mdx-components_heading-link__r6M6c"></i>1 可靠訊息傳遞問題</h1></a>
<div class="mdx-components_paragraph__AUxxF">喺 distributed systems 既世界裡面，好多時候都會用到 messaging services（message brokers）黎達到 asynchronous 既 microservice communication。</div>
<div class="mdx-components_paragraph__AUxxF">不過，只要有任何 architecture 上既改變，都會衍生一啲新既困難，就好似每加多一樣 infrastructure 或者 middleware 入我地既 architecture，我地既 architecture 裡面就會有多一樣野可以出錯或者需要我地持續 maintain。而當我地用左 messaging services（brokers），就會出現一啲難題，例如如果 producer microservice 喺 update 完佢既 database 之後因為某啲原因而唔能夠成功發送訊息（或者話係個 broker 接收失敗），又或者 consumer microservice 收到訊息之後既處理過程出錯，咁點算呢？我地既 data 會唔會爛左呢？我地希望透過 messaging design patterns 去解決傳遞訊息既時候可能會遇到既突發情況，從而達至可靠既訊息傳遞。</div>
<!-- -->
<a href="#2-訊息傳遞既唔同情況" style="text-decoration:none"><h1 id="2-訊息傳遞既唔同情況" class="mdx-components_heading__HrNl3 mdx-components_heading-new-section__YU39B" style="z-index:2000000"><i class="fa-solid fa-link mdx-components_heading-link__r6M6c"></i>2 訊息傳遞既唔同情況</h1></a>
<div class="mdx-components_paragraph__AUxxF">訊息傳遞可以有幾多種唔同既結果：</div>
<ul>
<li class="mdx-components_list-item__fJ1NL">成功——訊息完全正常，帶有正常既格式、正確既數據，而且 producer、messaging broker、consumer 全部都運作正常。</li>
<li class="mdx-components_list-item__fJ1NL">失敗——訊息完全正常，帶有正常既格式、正確既數據，但係 producer、messaging broker、consumer 全部或者部分出錯。</li>
<li class="mdx-components_list-item__fJ1NL">失敗——因為訊息本身有問題（稱之為 poison message），例如係帶有 consumer microservice 冇辦法理解既格式或者錯誤既數據。</li>
</ul>
<!-- -->
<a href="#3-訊息傳遞保證" style="text-decoration:none"><h1 id="3-訊息傳遞保證" class="mdx-components_heading__HrNl3 mdx-components_heading-new-section__YU39B" style="z-index:3000000"><i class="fa-solid fa-link mdx-components_heading-link__r6M6c"></i>3 訊息傳遞保證</h1></a>
<div class="mdx-components_paragraph__AUxxF">喺講 design patterns 之前，我地要先思考下訊息傳遞可以有幾多種保證（message delivery guarantees）。</div>
<div class="mdx-components_table-outer-wrapper__npuxp"><div class="mdx-components_table-wrapper__0GcvD"><table class="mdx-components_table__bAy19"><thead><tr><th>訊息傳遞保證</th><th>描述</th><th>解釋</th></tr></thead><tbody><tr><td>Exactly once</td><td>每個訊息一定會被傳遞一次。</td><td>最理想當然係咁，但當我地考慮到任何野喺任何時候都有低機率會出錯，咁就知道其實實際上係好難（甚至冇可能）實現到呢個保證。</td></tr><tr><td>At least once</td><td>每個訊息至少會被傳遞一次，亦有可能會被傳遞多過一次。</td><td>呢個保證係可以接受既次選，但係接收左訊息之後，我地既處理過程一定要係 idempotent，即係同一段 code 執行多過一次既結果都係一樣（主要係 database 裡面既 data）。當遇到有問題既訊息，呢個保證會令到個 MQ 長期塞住。</td></tr><tr><td>At most once</td><td>每個訊息最多會被傳遞一次，亦有可能冇被傳遞。</td><td>呢個純粹係 best effort 盡做，所以係一個唔可靠既保證。</td></tr></tbody></table></div></div>
<!-- -->
<a href="#4-outbox-pattern" style="text-decoration:none"><h1 id="4-outbox-pattern" class="mdx-components_heading__HrNl3 mdx-components_heading-new-section__YU39B" style="z-index:4000000"><i class="fa-solid fa-link mdx-components_heading-link__r6M6c"></i>4 Outbox pattern</h1></a>
<div class="mdx-components_paragraph__AUxxF">Outbox pattern 可以做到 at least once 既訊息傳遞保證，確保最終一定可以發送到訊息。</div>
<div class="mdx-components_paragraph__AUxxF">通常 producer microservices 都唔會只係發送訊息，佢地通常都會先做一輪 database 讀寫，最後先會發送訊息去通知 downstream microservices。因為呢兩個步驟唔係 atomic，如果 database 讀寫成功，但係發送訊息失敗，咁就好可能會令業務出現問題。</div>
<div class="mdx-components_paragraph__AUxxF">其中一個可能性係 messaging service 出現問題（但 network 冇問題），令到呢一刻唔能夠發送訊息，就算有 retry 都未必可以喺短期內成功發送到訊息去 messaging service 度。</div>
<div class="mdx-components_paragraph__AUxxF">因為係 at least once 既訊息傳遞，我地唔可以因為重複處理相同既訊息而令到數據出錯，例如業務上重複扣除客戶戶口既錢。咁所以：</div>
<ul>
<li class="mdx-components_list-item__fJ1NL">Consumer microservices 要識得 deduplicate 訊息；</li>
<li class="mdx-components_list-item__fJ1NL">或者 consumer microservices 喺接收到訊息之後既處理過程一定要係 idempotent。</li>
</ul>
<div class="mdx-components_paragraph__AUxxF">註：</div>
<ul>
<li class="mdx-components_list-item__fJ1NL">就算 messaging service 識得 deduplicate 都冇用，因為 consumer microservices 可能會喺向 messaging service 發送確認既時候出錯，咁就會令到 consumer microservices 接收多過一次相同既訊息。</li>
</ul>
<a href="#41-實現方式" style="text-decoration:none"><h2 id="41-實現方式" class="mdx-components_heading__HrNl3 mdx-components_heading-sub-section__AJ2JK" style="z-index:4010000"><i class="fa-solid fa-link mdx-components_heading-link__r6M6c"></i>4.1 實現方式</h2></a>
<div class="mdx-components_paragraph__AUxxF">我地需要用到一個 RDBMS database table 去保存需要發送既訊息，並且利用 RDBMS databases 既 ACID 特性，令到 database 讀寫、發送訊息呢兩個步驟變到 atomic。</div>
<div class="mdx-components_paragraph__AUxxF">以下係具體既流程：</div>
<ol>
<li class="mdx-components_list-item__fJ1NL">Producer microservice 收到 request。</li>
<li class="mdx-components_list-item__fJ1NL">Producer microservice 開始一個 database transaction。</li>
<li class="mdx-components_list-item__fJ1NL">Producer microservice 讀寫 database 去更新一啲業務數據。</li>
<li class="mdx-components_list-item__fJ1NL">Producer microservice 將需要發送既訊息保存喺 outbox table。</li>
<li class="mdx-components_list-item__fJ1NL">Producer microservice 完成個 database transaction。</li>
</ol>
<div class="mdx-components_paragraph__AUxxF">另外亦都需要有一個定期重複執行既 schedule，producer microservice 要定期發送所有未發送既訊息：</div>
<ol>
<li class="mdx-components_list-item__fJ1NL">Producer microservice 查詢 outbox table 裡面未發送既 records。</li>
<li class="mdx-components_list-item__fJ1NL">Producer microservice 發送一個或多個訊息到 messaging service。</li>
<li class="mdx-components_list-item__fJ1NL">Producer microservice 等 messaging service 確認所有訊息成功發送（publisher acknowledgements／confirms）。</li>
<li class="mdx-components_list-item__fJ1NL">Producer microservice 開始一個 database transaction。</li>
<li class="mdx-components_list-item__fJ1NL">Producer microservice soft delete 或者 hard delete outbox table record(s)。</li>
<li class="mdx-components_list-item__fJ1NL">Producer microservice 完成個 database transaction。</li>
</ol>
<div class="mdx-components_paragraph__AUxxF">註：</div>
<ul>
<li class="mdx-components_list-item__fJ1NL">視乎情況，發送訊息既時候有可能需要注意 message ordering。</li>
<li class="mdx-components_list-item__fJ1NL">如果有任何出錯，一定要 throw exception。<!-- -->
<ul>
<li class="mdx-components_list-item__fJ1NL">如果發送訊息既時候出現 exception，都唔一定需要影響到處理其他 surrogate keys 既 records。</li>
</ul>
</li>
<li class="mdx-components_list-item__fJ1NL">如果利用 batch publishing 既方式發送訊息，而唔係逐個訊息咁發送，咁個 messaging service 一係要保證到 atomicity（全部成功或者全部失敗）。<!-- -->
<ul>
<li class="mdx-components_list-item__fJ1NL">如果我地對 message ordering 有要求，而個 messaging service 唔保證 atomicity，咁 consumer microservice 處理既訊息次序就有可能會亂曬。</li>
</ul>
</li>
</ul>
<!-- -->
<a href="#42-所有有可能出錯既情況" style="text-decoration:none"><h2 id="42-所有有可能出錯既情況" class="mdx-components_heading__HrNl3 mdx-components_heading-sub-section__AJ2JK" style="z-index:4020000"><i class="fa-solid fa-link mdx-components_heading-link__r6M6c"></i>4.2 所有有可能出錯既情況</h2></a>
<div class="mdx-components_paragraph__AUxxF">我地需要考慮到任何步驟都有出錯既機會，我地注重既係對數據一致性既影響。</div>
<div class="mdx-components_paragraph__AUxxF">註：</div>
<ul>
<li class="mdx-components_list-item__fJ1NL">「出錯」可以係 runtime exception，亦可以係成個 microservice instance 或者 messaging service 重新啟動或者死機。</li>
<li class="mdx-components_list-item__fJ1NL">一旦出錯，就會跳過所有後續既步驟。</li>
</ul>
<div class="mdx-components_table-outer-wrapper__npuxp"><div class="mdx-components_table-wrapper__0GcvD"><table class="mdx-components_table__bAy19"><thead><tr><th>出錯情況</th><th>對數據一致性既影響</th></tr></thead><tbody><tr><td>Producer microservice 收到 request 之前出錯。</td><td>✅ 如果只有一個 instance，咁好可能會影響業務運作，但就對數據一致性冇任何影響。</td></tr><tr><td>Producer microservice 收到 request 之後出錯。</td><td>✅ 個 request 固然會失敗，但係因為未寫入過任何數據，所以對數據一致性冇任何影響。</td></tr><tr><td>Producer microservice 開始一個 database transaction 之後出錯。</td><td>✅ 個 request 固然會失敗，而 database 會自動 rollback transaction，最終係冇任何數據上既改動，亦對數據一致性冇影響。</td></tr><tr><td>Producer microservice 讀寫 database 去更新一啲業務數據之後出錯。</td><td>✅ 個 request 固然會失敗，但係 database 會自動 rollback transaction，最終係冇任何數據上既改動，亦對數據一致性冇影響。</td></tr><tr><td>Producer microservice 將需要發送既訊息保存喺 outbox table 之後出錯。</td><td>✅ 個 request 固然會失敗，但係 database 會自動 rollback transaction，最終係冇任何數據上既改動，亦對數據一致性冇影響。</td></tr><tr><td>Producer microservice 完成個 database transaction 之後出錯。</td><td>✅ 因為已經完成 database transaction，所有數據已經保存妥當，所以對數據一致性冇影響。但因為個 request 失敗左，upstream microservice 可能會 retry 個 request，只要呢個 producer microservice 既處理過程係 idempotent，咁就唔成問題。</td></tr></tbody></table></div></div>
<div class="mdx-components_paragraph__AUxxF">至於定期發送訊息既 schedule：</div>
<div class="mdx-components_table-outer-wrapper__npuxp"><div class="mdx-components_table-wrapper__0GcvD"><table class="mdx-components_table__bAy19"><thead><tr><th>出錯情況</th><th>對數據一致性既影響</th></tr></thead><tbody><tr><td>Producer microservice 查詢 outbox table 裡面未發送既 records 之前出錯。</td><td>✅ 因為乜都未做過，所以對數據一致性冇影響。</td></tr><tr><td>Producer microservice 查詢 outbox table 裡面未發送既 records 之後出錯。</td><td>✅ 因為乜都未做過，所以對數據一致性冇影響。</td></tr><tr><td>Producer microservice 發送單一訊息既時候出錯，導致訊息發送唔到。</td><td>✅ 因為冇發送到訊息，所以對數據一致性冇影響。</td></tr><tr><td>Producer microservice 發送單一訊息到 messaging service 既時候出錯，導致訊息發送左，但係收唔到 messaging service 既確認。</td><td>✅ 因為有可能已經成功發送左訊息，但係冇更新到 outbox table，咁之後一定會再次發送相同既訊息，如果個 messaging service 支援 deduplication 又或者個 consumer microservice 識得 deduplicate 或者係 idempotent 既處理過程就冇問題，所以對數據一致性冇影響。</td></tr><tr><td>Producer microservice 發送單一訊息到 messaging service 之後出錯，導致訊息發送左，而又收到 messaging service 既確認，但係之後出錯。</td><td>✅ 因為已經發送左訊息，但係冇更新到 outbox table，咁之後一定會再次發送相同既訊息，如果個 messaging service 支援 deduplication 又或者個 consumer microservice 識得 deduplicate 或者係 idempotent 既處理過程就冇問題，所以對數據一致性冇影響。</td></tr><tr><td>Producer microservice batch 發送多個訊息到 messaging service 之間出錯。</td><td>✅ 用得 batch publishing，我地就期望個 messaging service 有 atomicity guarantee，如果失敗既話就會係個 batch 裡面全部訊息發送失敗，個 messaging service 唔會保存呢個 batch 裡面既任何一個訊息。因為等同於冇發送到訊息，所以對數據一致性冇影響。</td></tr><tr><td>Producer microservice batch 發送多個訊息到 messaging service 既時候出錯，導致訊息發送左，但係收唔到 messaging service 既確認。</td><td>✅ 因為有可能已經成功發送左訊息，但係冇更新到 outbox table，咁之後一定會再次發送相同既訊息，如果個 messaging service 支援 deduplication 又或者個 consumer microservice 識得 deduplicate 或者係 idempotent 既處理過程就冇問題，所以對數據一致性冇影響。</td></tr><tr><td>Producer microservice batch 發送多個訊息到 messaging service 之後出錯，導致訊息發送左，而又收到 messaging service 既確認，但係之後出錯。</td><td>✅ 因為已經發送左訊息，但係冇更新到 outbox table，咁之後一定會再次發送相同既訊息，如果個 messaging service 支援 deduplication 又或者個 consumer microservice 識得 deduplicate 或者係 idempotent 既處理過程就冇問題，所以對數據一致性冇影響。</td></tr><tr><td>Producer microservice 開始一個 database transaction 之後出錯。</td><td>✅ 因為已經發送左訊息，但係冇更新到 outbox table，咁之後一定會再次發送相同既訊息，如果個 messaging service 支援 deduplication 又或者個 consumer microservice 識得 deduplicate 或者係 idempotent 既處理過程就冇問題，所以對數據一致性冇影響。</td></tr><tr><td>Producer microservice soft delete 或者 hard delete outbox table record(s) 之後出錯。</td><td>✅ 因為已經發送左訊息，但係冇更新到 outbox table，咁之後一定會再次發送相同既訊息，如果個 messaging service 支援 deduplication 又或者個 consumer microservice 識得 deduplicate 或者係 idempotent 既處理過程就冇問題，所以對數據一致性冇影響。</td></tr><tr><td>Producer microservice 完成個 database transaction 之後出錯。</td><td>✅ 因為所有訊息已經成功發送，而且已經完成 database transaction，所有數據已經保存妥當，所以對數據一致性冇影響。</td></tr></tbody></table></div></div>
<!-- -->
<a href="#5-inbox-pattern" style="text-decoration:none"><h1 id="5-inbox-pattern" class="mdx-components_heading__HrNl3 mdx-components_heading-new-section__YU39B" style="z-index:5000000"><i class="fa-solid fa-link mdx-components_heading-link__r6M6c"></i>5 Inbox pattern</h1></a>
<div class="mdx-components_paragraph__AUxxF">Inbox pattern 雖然有啲似 outbox pattern，但佢就冇 outbox pattern 既必要性。</div>
<div class="mdx-components_paragraph__AUxxF">Outbox pattern 之所以重要，係因為：</div>
<ul>
<li class="mdx-components_list-item__fJ1NL">唔用 outbox pattern 而發送訊息失敗既話，咁可能就咩都冇，需要發送既訊息從此就會漏左；</li>
<li class="mdx-components_list-item__fJ1NL">用左 outbox pattern 就可以保證我地想發送既訊息最終都一定會發送到。</li>
</ul>
<div class="mdx-components_paragraph__AUxxF">如果冇 inbox pattern，都唔係唔得既，只係 consumer microservices 就要喺成功完成所有業務邏輯之後先至可以向 messaging service 確認訊息接收成功（acknowledgement），而確認既過程都有可能會出錯，咁即係無論 producer microservices 發送訊息係 at least once，或者 consumer microservices 接收訊息係 at least once，我地既 consumer microservices 都一定要有 idempotent 既處理過程。</div>
<a href="#51-實現方式" style="text-decoration:none"><h2 id="51-實現方式" class="mdx-components_heading__HrNl3 mdx-components_heading-sub-section__AJ2JK" style="z-index:5010000"><i class="fa-solid fa-link mdx-components_heading-link__r6M6c"></i>5.1 實現方式</h2></a>
<div class="mdx-components_paragraph__AUxxF">我地需要用到一個 RDBMS database table 去 mark 低未完成以及已經完成處理既訊息，並且利用 RDBMS databases 既 ACID 特性，令到完成處理訊息、database 讀寫呢兩個步驟變到 atomic。</div>
<div class="mdx-components_paragraph__AUxxF">以下係具體既流程：</div>
<ol>
<li class="mdx-components_list-item__fJ1NL">Consumer microservice 訂閱 messaging service。</li>
<li class="mdx-components_list-item__fJ1NL">Consumer microservice 接收到新訊息。</li>
<li class="mdx-components_list-item__fJ1NL">Consumer microservice 開始一個 database transaction。</li>
<li class="mdx-components_list-item__fJ1NL">Consumer microservice 將需要處理既訊息保存喺 inbox table。</li>
<li class="mdx-components_list-item__fJ1NL">Consumer microservice 完成個 database transaction。</li>
<li class="mdx-components_list-item__fJ1NL">Consumer microservice 向 messaging service 確認訊息接收（consumer acknowledgements）。</li>
</ol>
<div class="mdx-components_paragraph__AUxxF">另外亦都需要有一個定期重複執行既 schedule，consumer microservice 要定期處理所有接收左既訊息：</div>
<ol>
<li class="mdx-components_list-item__fJ1NL">Consumer microservice 查詢 inbox table 未處理既 records。</li>
<li class="mdx-components_list-item__fJ1NL">Consumer microservice 開始一個 database transaction。</li>
<li class="mdx-components_list-item__fJ1NL">Consumer microservice soft delete 或者 hard delete inbox table record(s)。</li>
<li class="mdx-components_list-item__fJ1NL">Consumer microservice 讀寫 database 去更新一啲業務數據。</li>
<li class="mdx-components_list-item__fJ1NL">Consumer microservice 完成個 database transaction。</li>
</ol>
<div class="mdx-components_paragraph__AUxxF">註：</div>
<ul>
<li class="mdx-components_list-item__fJ1NL">如果想利用個 inbox table 幫我地 deduplicate 重複接收既相同訊息，咁我地處理既時候就唔可以 hard delete inbox table records，因為成個 record 刪左就會冇辦法知道邊啲係已經接收過。</li>
</ul>
<!-- -->
<a href="#52-所有有可能出錯既情況" style="text-decoration:none"><h2 id="52-所有有可能出錯既情況" class="mdx-components_heading__HrNl3 mdx-components_heading-sub-section__AJ2JK" style="z-index:5020000"><i class="fa-solid fa-link mdx-components_heading-link__r6M6c"></i>5.2 所有有可能出錯既情況</h2></a>
<div class="mdx-components_paragraph__AUxxF">我地需要考慮到任何步驟都有出錯既機會，我地注重既係對數據一致性既影響。</div>
<div class="mdx-components_paragraph__AUxxF">註：</div>
<ul>
<li class="mdx-components_list-item__fJ1NL">「出錯」可以係 runtime exception，亦可以係成個 microservice instance 或者 messaging service 重新啟動或者死機。</li>
<li class="mdx-components_list-item__fJ1NL">一旦出錯，就會跳過所有後續既步驟。</li>
</ul>
<div class="mdx-components_table-outer-wrapper__npuxp"><div class="mdx-components_table-wrapper__0GcvD"><table class="mdx-components_table__bAy19"><thead><tr><th>出錯情況</th><th>對數據一致性既影響</th></tr></thead><tbody><tr><td>Consumer microservice 訂閱 messaging service 之前出錯。</td><td>✅ 如果只有一個 instance，咁好可能會影響業務運作，但就對數據一致性冇任何影響。</td></tr><tr><td>Consumer microservice 訂閱 messaging service 之後出錯。</td><td>✅ 如果只有一個 instance，咁好可能會影響業務運作，但就對數據一致性冇任何影響。</td></tr><tr><td>Consumer microservice 接收到新訊息之後出錯。</td><td>✅ 因為已經接收左訊息，但係冇更新到 inbox table，咁之後一定會再次接收相同既訊息，如果個 consumer microservice 係 idempotent 既處理過程就冇問題，所以對數據一致性冇影響。</td></tr><tr><td>Consumer microservice 開始一個 database transaction 之後出錯。</td><td>✅ 因為 database 會自動 rollback transaction，咁之後一定會再次接收相同既訊息，如果個 consumer microservice 係 idempotent 既處理過程就冇問題，所以對數據一致性冇影響。</td></tr><tr><td>Consumer microservice 將需要處理既訊息保存喺 inbox table 之後出錯。</td><td>✅ 因為已經接收左訊息，而 database 會自動 rollback transaction，咁之後一定會再次接收相同既訊息，如果個 consumer microservice 係 idempotent 既處理過程就冇問題，所以對數據一致性冇影響。</td></tr><tr><td>Consumer microservice 完成個 database transaction 之後出錯，冇向 messaging service 確認訊息接收。</td><td>✅ 因為已經完成 database transaction，但係冇向 messaging service 確認到訊息接收，咁之後一定會再次接收相同既訊息，如果個 consumer microservice 係 idempotent 既處理過程就冇問題，所以對數據一致性冇影響。</td></tr><tr><td>Consumer microservice 向 messaging service 確認訊息接收既時候出錯。</td><td>✅ 因為已經完成 database transaction，但係有可能冇確認到訊息接收，咁之後可能會再次接收相同既訊息，如果個 inbox table 識得 deduplicate 或者 consumer microservice 係 idempotent 既處理過程就冇問題，所以對數據一致性冇影響。</td></tr><tr><td>Consumer microservice 向 messaging service 確認訊息接收之後出錯。</td><td>✅ 因為已經完成 database transaction，所有數據已經保存妥當，而且已經確認接收，所以之後唔會接收重複既訊息，亦對數據一致性冇影響。</td></tr></tbody></table></div></div>
<div class="mdx-components_paragraph__AUxxF">至於定期處理訊息既 schedule：</div>
<div class="mdx-components_table-outer-wrapper__npuxp"><div class="mdx-components_table-wrapper__0GcvD"><table class="mdx-components_table__bAy19"><thead><tr><th>出錯情況</th><th>對數據一致性既影響</th></tr></thead><tbody><tr><td>Consumer microservice 查詢 inbox table 未處理既 records 之前出錯。</td><td>✅ 因為乜都未做過，所以對數據一致性冇影響。</td></tr><tr><td>Consumer microservice 查詢 inbox table 未處理既 records 之後出錯。</td><td>✅ 因為乜都未做過，所以對數據一致性冇影響。</td></tr><tr><td>Consumer microservice 開始一個 database transaction 之後出錯。</td><td>✅ Database 會自動 rollback transaction，最終係冇任何數據上既改動，亦對數據一致性冇影響。</td></tr><tr><td>Consumer microservice soft delete 或者 hard delete inbox table record(s) 之後出錯。</td><td>✅ Database 會自動 rollback transaction，最終係冇任何數據上既改動，亦對數據一致性冇影響。</td></tr><tr><td>Consumer microservice 讀寫 database 去更新一啲業務數據之後出錯。</td><td>✅ Database 會自動 rollback transaction，最終係冇任何數據上既改動，亦對數據一致性冇影響。</td></tr><tr><td>Consumer microservice 完成個 database transaction 之後出錯。</td><td>✅ 因為已經完成 database transaction，所有數據已經保存妥當，所以對數據一致性冇影響。</td></tr></tbody></table></div></div>
<!-- -->
<a href="#6-考慮事項" style="text-decoration:none"><h1 id="6-考慮事項" class="mdx-components_heading__HrNl3 mdx-components_heading-new-section__YU39B" style="z-index:6000000"><i class="fa-solid fa-link mdx-components_heading-link__r6M6c"></i>6 考慮事項</h1></a>
<ul>
<li class="mdx-components_list-item__fJ1NL">我地既 microservices 既處理過程需要做到 idempotent。如果做唔到，數據就有機會因為各種 retry 機制而終有一日出錯。</li>
<li class="mdx-components_list-item__fJ1NL">考慮到 consumer microservice 可能會重複收到相同既訊息，如果佢既處理過程冇辦法做到 idempotent，咁就要考慮從個 inbox table 入手。<!-- -->
<ul>
<li class="mdx-components_list-item__fJ1NL">Upstream microservice 發送畀 producer microservice 既 HTTP request 既 header 可以加入一個隨機既 UUID。而次選既方法係 producer microservice 根據 HTTP request body 某啲數據去計算一個 hash，但係會有機會誤判。</li>
<li class="mdx-components_list-item__fJ1NL">Producer microservice 可以用呢個 value 作為訊息既 ID。</li>
<li class="mdx-components_list-item__fJ1NL">Consumer microservice 既 inbox table 要有一個 <code class="undefined mdx-components_inline-code__y_QeQ">message_id</code> 既 column，然後整一個 unique index 落呢個 column 度。</li>
<li class="mdx-components_list-item__fJ1NL">Consumer microservice 收到訊息之後，會將佢放落 inbox table，如果已經存在相同訊息 ID 既 record，就會出現 unique index violation 既 exception，但係 consumer microservice 需要 ignore 呢個 exception，照樣向 messaging service 確認已經成功接收訊息，否則下次又會重新收到相同既訊息。</li>
<li class="mdx-components_list-item__fJ1NL">Consumer microservice 成功處理完訊息之後，只可以 soft delete inbox table 既 records，因為 hard delete 既話就會失去 unique index 幫我地 deduplicate 訊息既作用。</li>
</ul>
</li>
<li class="mdx-components_list-item__fJ1NL">如果用左 outbox pattern 以及 inbox pattern，仲有冇需要用 messaging service 收發訊息黎取代 HTTP requests？<!-- -->
<ul>
<li class="mdx-components_list-item__fJ1NL">我地的確可以用返 HTTP requests，因為有 database 既 inbox table 裝住未處理既數據，咁就一樣可以做到 asynchronous processing。</li>
<li class="mdx-components_list-item__fJ1NL">不過，HTTP requests 只能做到單一 consumer instance；相反，messaging service 可以畀我地做到 consumer groups，同一個 message 被多個 consumers 處理。</li>
<li class="mdx-components_list-item__fJ1NL">另外，如果我地想用 horizontal autoscaling 去維持多個 consumer microservice instances 去達到 high availability，而如果我地一定要維持返 message ordering，咁用 HTTP requests 既話就冇辦法指定邊一個 consumer microservice instance，咁就冇辦法確保到 requests 一定係順序完成處理；相反，如果我地用 RabbitMQ 既話可以用 single active consumer，或者 Kafka 既話用 partition，確保只會有一個 consumer microservice instance 接收到訊息，咁訊息接收次序就會同訊息發送次序一樣。</li>
</ul>
</li>
</ul>
<!-- -->
<a href="#7-參考資料" style="text-decoration:none"><h1 id="7-參考資料" class="mdx-components_heading__HrNl3 mdx-components_heading-new-section__YU39B" style="z-index:7000000"><i class="fa-solid fa-link mdx-components_heading-link__r6M6c"></i>7 參考資料</h1></a>
<ul>
<li class="mdx-components_list-item__fJ1NL"><span><a href="https://softwaremill.com/microservices-101/" target="_blank" rel="external nofollow noopener noreferrer" class="common_anchor__kGNsN">Microservices 101: Transactional Outbox and Inbox</a></span>
<ul>
<li class="mdx-components_list-item__fJ1NL">
<blockquote class="mdx-components_blockquote__CXIKy">
<div class="mdx-components_paragraph__AUxxF">Very often, the recipient service can cope without the inbox. If the task doesn’t take long to finish or completes a predictable amount of time, it can just ack the message after processing. Otherwise, it might be worthwhile to spend some effort to implement the pattern.</div>
</blockquote>
</li>
</ul>
</li>
<li class="mdx-components_list-item__fJ1NL"><span><a href="https://event-driven.io/en/outbox_inbox_patterns_and_delivery_guarantees_explained/" target="_blank" rel="external nofollow noopener noreferrer" class="common_anchor__kGNsN">Outbox, Inbox patterns and delivery guarantees explained</a></span></li>
<li class="mdx-components_list-item__fJ1NL"><span><a href="https://docs.aws.amazon.com/prescriptive-guidance/latest/cloud-design-patterns/transactional-outbox.html" target="_blank" rel="external nofollow noopener noreferrer" class="common_anchor__kGNsN">AWS Prescriptive Guidance - Transactional outbox pattern</a></span></li>
<li class="mdx-components_list-item__fJ1NL"><span><a href="https://medium.com/codait/handling-failure-successfully-in-rabbitmq-22ffa982b60f" target="_blank" rel="external nofollow noopener noreferrer" class="common_anchor__kGNsN">Handling Failure Successfully in RabbitMQ</a></span></li>
<li class="mdx-components_list-item__fJ1NL"><span><a href="https://www.linkedin.com/pulse/microservice-architecture-outbox-pattern-hugo-tota/" target="_blank" rel="external nofollow noopener noreferrer" class="common_anchor__kGNsN">Microservice architecture [Outbox pattern]</a></span></li>
<li class="mdx-components_list-item__fJ1NL"><span><a href="https://www.berkansasmaz.com/every-programmer-should-know-idempotency/" target="_blank" rel="external nofollow noopener noreferrer" class="common_anchor__kGNsN">Every Programmer Should Know #1: Idempotency</a></span>
<blockquote class="mdx-components_blockquote__CXIKy">
<div class="mdx-components_paragraph__AUxxF">Simply, it is possible to make a POST request idempotent by including a unique identifier in the request body or header, which can be used to identify and prevent duplicate requests.</div>
<div class="mdx-components_paragraph__AUxxF">Many approaches can be used to determine whether a request is a copy of an earlier request. For example, it may be possible to derive a synthetic token based on the parameters in the request. You can derive a hash of existing parameters and assume that any request with the same parameters from the same caller is a duplicate. On the surface, this seems to simplify both the customer experience and service implementation. Any request that looks exactly like a previous request is considered a duplicate request. However, this approach is unlikely to work in all situations. For example, let&#x27;s say you order a meal, and when your next-door neighbor orders the same meal, are these requests repeated or are they two different requests? Or after you place an order, your friend calls and says he&#x27;s hungry, and when you re-create the same order a short time later, will we treat them as renewed requests? Is this scenario very similar to the client retrying the service because of the network latency we just mentioned? It’s possible that the caller actually wants two identical meals.</div>
<div class="mdx-components_paragraph__AUxxF">The generally preferred approach is to include a unique caller-supplied client request identifier in the API contract. Requests from the same caller with the same customer request identifier can be considered duplicate requests and handled accordingly. A unique caller-supplied client request identifier for idempotent operations satisfies this need.</div>
</blockquote>
</li>
</ul></div></div></div><hr/><div class="vstack gap-3"><div class="text-center container"><div class="justify-content-center g-3 row row-cols-md-3 row-cols-sm-2 row-cols-1"><div class="col"><a href="tel:+85263301333" target="_blank" rel="external nofollow noopener noreferrer" class="SiteFooter_contact-item__H5kf5 card"><div class="card-body"><div class="card-title h5"><i class="fa-solid fa-phone" style="color:#009688"></i></div><p class="text-muted card-text">6330 1333</p></div></a></div><div class="col"><a href="mailto:michaelboyboy@gmail.com" target="_blank" rel="external nofollow noopener noreferrer" class="SiteFooter_contact-item__H5kf5 card"><div class="card-body"><div class="card-title h5"><i class="fa-solid fa-envelope" style="color:#f44336"></i></div><p class="text-muted card-text">michaelboyboy@gmail.com</p></div></a></div><div class="col"><a href="https://www.linkedin.com/in/mickchung" target="_blank" rel="external nofollow noopener noreferrer" class="SiteFooter_contact-item__H5kf5 card"><div class="card-body"><div class="card-title h5"><i class="fa-brands fa-linkedin" style="color:#2196f3"></i></div><p class="text-muted card-text">www.linkedin.com/in/mickchung</p></div></a></div></div></div><div class="SiteFooter_misc__7DgAh"><div>Copyright © <!-- -->2025<!-- --> Chung Cheuk Hang Michael. All rights reserved.</div><div>Developed with <strong>React</strong>, <strong>Bootstrap</strong> and <strong>Next.js</strong>.</div></div></div></div><script src="/e2-next/_next/static/chunks/webpack-a1c00121deb96d97.js" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0])</script><script>self.__next_f.push([1,"1:\"$Sreact.fragment\"\n2:I[8287,[\"7833\",\"static/chunks/7833-c0135c68ec6a11ed.js\",\"7177\",\"static/chunks/app/layout-3655101740c91656.js\"],\"default\"]\n3:I[3339,[\"8974\",\"static/chunks/app/page-63c121085425a904.js\"],\"default\"]\n4:I[2963,[\"7833\",\"static/chunks/7833-c0135c68ec6a11ed.js\",\"7177\",\"static/chunks/app/layout-3655101740c91656.js\"],\"default\"]\n5:I[7680,[\"7833\",\"static/chunks/7833-c0135c68ec6a11ed.js\",\"7177\",\"static/chunks/app/layout-3655101740c91656.js\"],\"default\"]\n6:I[5244,[],\"\"]\n7:I[3866,[],\"\"]\n8:I[6486,[\"7833\",\"static/chunks/7833-c0135c68ec6a11ed.js\",\"7177\",\"static/chunks/app/layout-3655101740c91656.js\"],\"default\"]\n9:I[4547,[],\"ClientSegmentRoot\"]\na:I[5211,[\"586\",\"static/chunks/13b76428-e7d338032a603c0d.js\",\"5496\",\"static/chunks/5496-2276c5d321184651.js\",\"8329\",\"static/chunks/app/blog/(blogPosts)/layout-b960ed9b018b1aae.js\"],\"default\"]\nd:I[6213,[],\"OutletBoundary\"]\nf:I[6213,[],\"MetadataBoundary\"]\n11:I[6213,[],\"ViewportBoundary\"]\n13:I[4835,[],\"\"]\n:HL[\"/e2-next/_next/static/css/8b3b49f5a80261a3.css\",\"style\"]\n:HL[\"/e2-next/_next/static/css/d3df112486f97f47.css\",\"style\"]\n:HL[\"/e2-next/_next/static/css/47422044c9b2dd2c.css\",\"style\"]\n:HL[\"/e2-next/_next/static/css/7bfe9ed714480baa.css\",\"style\"]\n:HL[\"/e2-next/_next/static/css/c50e9134a56688df.css\",\"style\"]\nc:T43c,Many approaches can be used to determine whether a request is a copy of an earlier request. For example, it may be possible to derive a synthetic token based on the parameters in the request. You can derive a hash of existing parameters and assume that any request with the same parameters from the same caller is a duplicate. On the surface, this seems to simplify both the customer experience and service implementation. Any request that looks exactly like a previous request is considered a duplicate request. However, this approach is unlikely to work in all situations. For example, let's say you order a meal, and when your next-door neighbor orders the same meal, are these requests repeated or are they two different requests? Or after you place an order, your fr"])</script><script>self.__next_f.push([1,"iend calls and says he's hungry, and when you re-create the same order a short time later, will we treat them as renewed requests? Is this scenario very similar to the client retrying the service because of the network latency we just mentioned? It’s possible that the caller actually wants two identical meals."])</script><script>self.__next_f.push([1,"0:{\"P\":null,\"b\":\"-hFQ78fpvTVfkaYLnDHqy\",\"p\":\"/e2-next\",\"c\":[\"\",\"blog\",\"outbox-inbox-patterns\"],\"i\":false,\"f\":[[[\"\",{\"children\":[\"blog\",{\"children\":[\"(blogPosts)\",{\"children\":[\"(2024-03)\",{\"children\":[\"outbox-inbox-patterns\",{\"children\":[\"__PAGE__\",{}]}]}]}]}]},\"$undefined\",\"$undefined\",true],[\"\",[\"$\",\"$1\",\"c\",{\"children\":[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/e2-next/_next/static/css/8b3b49f5a80261a3.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\",\"nonce\":\"$undefined\"}],[\"$\",\"link\",\"1\",{\"rel\":\"stylesheet\",\"href\":\"/e2-next/_next/static/css/d3df112486f97f47.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\",\"nonce\":\"$undefined\"}],[\"$\",\"link\",\"2\",{\"rel\":\"stylesheet\",\"href\":\"/e2-next/_next/static/css/47422044c9b2dd2c.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\",\"nonce\":\"$undefined\"}]],[\"$\",\"html\",null,{\"lang\":\"en\",\"children\":[[\"$\",\"head\",null,{\"children\":[[\"$\",\"link\",null,{\"href\":\"https://fonts.googleapis.com/css2?family=Roboto:ital,wght@0,100;0,300;0,400;0,500;0,700;0,900;1,100;1,300;1,400;1,500;1,700;1,900\u0026display=swap\",\"rel\":\"stylesheet\"}],[\"$\",\"link\",null,{\"rel\":\"stylesheet\",\"href\":\"https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css\"}]]}],[\"$\",\"body\",null,{\"children\":[\"$\",\"$L2\",null,{\"children\":[\"$\",\"$L3\",null,{\"gap\":5,\"children\":[[\"$\",\"$L3\",null,{\"gap\":5,\"className\":\"text-center\",\"children\":[[\"$\",\"div\",null,{\"className\":\"Ribbon_ribbon-left__fObbI\",\"children\":[\"$\",\"img\",null,{\"className\":\"Ribbon_image__2_FYh\",\"src\":\"/e2-next/nextjs.svg\"}]}],[\"$\",\"$L4\",null,{\"href\":\"https://blackr1234.github.io/e2/\",\"variant\":\"secondary\",\"size\":\"sm\",\"className\":\"ButtonToOtherSites_button__K4zwN\",\"children\":\"➜ Old React website\"}],[\"$\",\"div\",null,{\"children\":[[\"$\",\"code\",null,{\"className\":\"SiteHeader_name__pxX08\",\"children\":\"Chung Cheuk Hang Michael\"}],[\"$\",\"code\",null,{\"className\":\"SiteHeader_title__MUwhy\",\"children\":\"Java Web Developer\"}]]}],[\"$\",\"$L5\",null,{}]]}],[\"$\",\"$L6\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L7\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[[],[[\"$\",\"title\",null,{\"children\":\"404: This page could not be found.\"}],[\"$\",\"div\",null,{\"style\":{\"fontFamily\":\"system-ui,\\\"Segoe UI\\\",Roboto,Helvetica,Arial,sans-serif,\\\"Apple Color Emoji\\\",\\\"Segoe UI Emoji\\\"\",\"height\":\"100vh\",\"textAlign\":\"center\",\"display\":\"flex\",\"flexDirection\":\"column\",\"alignItems\":\"center\",\"justifyContent\":\"center\"},\"children\":[\"$\",\"div\",null,{\"children\":[[\"$\",\"style\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}\"}}],[\"$\",\"h1\",null,{\"className\":\"next-error-h1\",\"style\":{\"display\":\"inline-block\",\"margin\":\"0 20px 0 0\",\"padding\":\"0 23px 0 0\",\"fontSize\":24,\"fontWeight\":500,\"verticalAlign\":\"top\",\"lineHeight\":\"49px\"},\"children\":404}],[\"$\",\"div\",null,{\"style\":{\"display\":\"inline-block\"},\"children\":[\"$\",\"h2\",null,{\"style\":{\"fontSize\":14,\"fontWeight\":400,\"lineHeight\":\"49px\",\"margin\":0},\"children\":\"This page could not be found.\"}]}]]}]}]]],\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}],[\"$\",\"hr\",null,{}],[\"$\",\"$L8\",null,{}]]}]}]}]]}]]}],{\"children\":[\"blog\",[\"$\",\"$1\",\"c\",{\"children\":[null,[\"$\",\"$L6\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"blog\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L7\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]]}],{\"children\":[\"(blogPosts)\",[\"$\",\"$1\",\"c\",{\"children\":[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/e2-next/_next/static/css/7bfe9ed714480baa.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\",\"nonce\":\"$undefined\"}]],[\"$\",\"$L9\",null,{\"Component\":\"$a\",\"slots\":{\"children\":[\"$\",\"$L6\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"blog\",\"children\",\"(blogPosts)\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L7\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]},\"params\":{},\"promise\":\"$@b\"}]]}],{\"children\":[\"(2024-03)\",[\"$\",\"$1\",\"c\",{\"children\":[null,[\"$\",\"$L6\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"blog\",\"children\",\"(blogPosts)\",\"children\",\"(2024-03)\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L7\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]]}],{\"children\":[\"outbox-inbox-patterns\",[\"$\",\"$1\",\"c\",{\"children\":[null,[\"$\",\"$L6\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"blog\",\"children\",\"(blogPosts)\",\"children\",\"(2024-03)\",\"children\",\"outbox-inbox-patterns\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L7\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]]}],{\"children\":[\"__PAGE__\",[\"$\",\"$1\",\"c\",{\"children\":[[[\"$\",\"a\",null,{\"href\":\"#table-of-contents\",\"style\":{\"textDecoration\":\"none\"},\"children\":[\"$\",\"h1\",null,{\"id\":\"table-of-contents\",\"className\":\"mdx-components_heading__HrNl3 mdx-components_heading-new-section__YU39B\",\"style\":{\"zIndex\":1},\"children\":[[\"$\",\"i\",null,{\"className\":\"fa-solid fa-link mdx-components_heading-link__r6M6c\"}],\"Table of contents\"]}]}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"className\":\"mdx-components_list-item__fJ1NL\",\"children\":[\"$\",\"span\",null,{\"children\":[\"$\",\"a\",null,{\"href\":\"#1-%E5%8F%AF%E9%9D%A0%E8%A8%8A%E6%81%AF%E5%82%B3%E9%81%9E%E5%95%8F%E9%A1%8C\",\"className\":\"common_anchor__kGNsN\",\"children\":\"1 可靠訊息傳遞問題\"}]}]}],\"\\n\",[\"$\",\"li\",null,{\"className\":\"mdx-components_list-item__fJ1NL\",\"children\":[\"$\",\"span\",null,{\"children\":[\"$\",\"a\",null,{\"href\":\"#2-%E8%A8%8A%E6%81%AF%E5%82%B3%E9%81%9E%E6%97%A2%E5%94%94%E5%90%8C%E6%83%85%E6%B3%81\",\"className\":\"common_anchor__kGNsN\",\"children\":\"2 訊息傳遞既唔同情況\"}]}]}],\"\\n\",[\"$\",\"li\",null,{\"className\":\"mdx-components_list-item__fJ1NL\",\"children\":[\"$\",\"span\",null,{\"children\":[\"$\",\"a\",null,{\"href\":\"#3-%E8%A8%8A%E6%81%AF%E5%82%B3%E9%81%9E%E4%BF%9D%E8%AD%89\",\"className\":\"common_anchor__kGNsN\",\"children\":\"3 訊息傳遞保證\"}]}]}],\"\\n\",[\"$\",\"li\",null,{\"className\":\"mdx-components_list-item__fJ1NL\",\"children\":[[\"$\",\"span\",null,{\"children\":[\"$\",\"a\",null,{\"href\":\"#4-outbox-pattern\",\"className\":\"common_anchor__kGNsN\",\"children\":\"4 Outbox pattern\"}]}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"className\":\"mdx-components_list-item__fJ1NL\",\"children\":[\"$\",\"span\",null,{\"children\":[\"$\",\"a\",null,{\"href\":\"#41-%E5%AF%A6%E7%8F%BE%E6%96%B9%E5%BC%8F\",\"className\":\"common_anchor__kGNsN\",\"children\":\"4.1 實現方式\"}]}]}],\"\\n\",[\"$\",\"li\",null,{\"className\":\"mdx-components_list-item__fJ1NL\",\"children\":[\"$\",\"span\",null,{\"children\":[\"$\",\"a\",null,{\"href\":\"#42-%E6%89%80%E6%9C%89%E6%9C%89%E5%8F%AF%E8%83%BD%E5%87%BA%E9%8C%AF%E6%97%A2%E6%83%85%E6%B3%81\",\"className\":\"common_anchor__kGNsN\",\"children\":\"4.2 所有有可能出錯既情況\"}]}]}],\"\\n\"]}],\"\\n\"]}],\"\\n\",[\"$\",\"li\",null,{\"className\":\"mdx-components_list-item__fJ1NL\",\"children\":[[\"$\",\"span\",null,{\"children\":[\"$\",\"a\",null,{\"href\":\"#5-inbox-pattern\",\"className\":\"common_anchor__kGNsN\",\"children\":\"5 Inbox pattern\"}]}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"className\":\"mdx-components_list-item__fJ1NL\",\"children\":[\"$\",\"span\",null,{\"children\":[\"$\",\"a\",null,{\"href\":\"#51-%E5%AF%A6%E7%8F%BE%E6%96%B9%E5%BC%8F\",\"className\":\"common_anchor__kGNsN\",\"children\":\"5.1 實現方式\"}]}]}],\"\\n\",[\"$\",\"li\",null,{\"className\":\"mdx-components_list-item__fJ1NL\",\"children\":[\"$\",\"span\",null,{\"children\":[\"$\",\"a\",null,{\"href\":\"#52-%E6%89%80%E6%9C%89%E6%9C%89%E5%8F%AF%E8%83%BD%E5%87%BA%E9%8C%AF%E6%97%A2%E6%83%85%E6%B3%81\",\"className\":\"common_anchor__kGNsN\",\"children\":\"5.2 所有有可能出錯既情況\"}]}]}],\"\\n\"]}],\"\\n\"]}],\"\\n\",[\"$\",\"li\",null,{\"className\":\"mdx-components_list-item__fJ1NL\",\"children\":[\"$\",\"span\",null,{\"children\":[\"$\",\"a\",null,{\"href\":\"#6-%E8%80%83%E6%85%AE%E4%BA%8B%E9%A0%85\",\"className\":\"common_anchor__kGNsN\",\"children\":\"6 考慮事項\"}]}]}],\"\\n\",[\"$\",\"li\",null,{\"className\":\"mdx-components_list-item__fJ1NL\",\"children\":[\"$\",\"span\",null,{\"children\":[\"$\",\"a\",null,{\"href\":\"#7-%E5%8F%83%E8%80%83%E8%B3%87%E6%96%99\",\"className\":\"common_anchor__kGNsN\",\"children\":\"7 參考資料\"}]}]}],\"\\n\"]}],\"\\n\",[\"$\",\"a\",null,{\"href\":\"#1-可靠訊息傳遞問題\",\"style\":{\"textDecoration\":\"none\"},\"children\":[\"$\",\"h1\",null,{\"id\":\"1-可靠訊息傳遞問題\",\"className\":\"mdx-components_heading__HrNl3 mdx-components_heading-new-section__YU39B\",\"style\":{\"zIndex\":1000000},\"children\":[[\"$\",\"i\",null,{\"className\":\"fa-solid fa-link mdx-components_heading-link__r6M6c\"}],\"1 可靠訊息傳遞問題\"]}]}],\"\\n\",[\"$\",\"div\",null,{\"className\":\"mdx-components_paragraph__AUxxF\",\"children\":\"喺 distributed systems 既世界裡面，好多時候都會用到 messaging services（message brokers）黎達到 asynchronous 既 microservice communication。\"}],\"\\n\",[\"$\",\"div\",null,{\"className\":\"mdx-components_paragraph__AUxxF\",\"children\":\"不過，只要有任何 architecture 上既改變，都會衍生一啲新既困難，就好似每加多一樣 infrastructure 或者 middleware 入我地既 architecture，我地既 architecture 裡面就會有多一樣野可以出錯或者需要我地持續 maintain。而當我地用左 messaging services（brokers），就會出現一啲難題，例如如果 producer microservice 喺 update 完佢既 database 之後因為某啲原因而唔能夠成功發送訊息（或者話係個 broker 接收失敗），又或者 consumer microservice 收到訊息之後既處理過程出錯，咁點算呢？我地既 data 會唔會爛左呢？我地希望透過 messaging design patterns 去解決傳遞訊息既時候可能會遇到既突發情況，從而達至可靠既訊息傳遞。\"}],\"\\n\",\"$undefined\",\"\\n\",[\"$\",\"a\",null,{\"href\":\"#2-訊息傳遞既唔同情況\",\"style\":{\"textDecoration\":\"none\"},\"children\":[\"$\",\"h1\",null,{\"id\":\"2-訊息傳遞既唔同情況\",\"className\":\"mdx-components_heading__HrNl3 mdx-components_heading-new-section__YU39B\",\"style\":{\"zIndex\":2000000},\"children\":[[\"$\",\"i\",null,{\"className\":\"fa-solid fa-link mdx-components_heading-link__r6M6c\"}],\"2 訊息傳遞既唔同情況\"]}]}],\"\\n\",[\"$\",\"div\",null,{\"className\":\"mdx-components_paragraph__AUxxF\",\"children\":\"訊息傳遞可以有幾多種唔同既結果：\"}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"className\":\"mdx-components_list-item__fJ1NL\",\"children\":\"成功——訊息完全正常，帶有正常既格式、正確既數據，而且 producer、messaging broker、consumer 全部都運作正常。\"}],\"\\n\",[\"$\",\"li\",null,{\"className\":\"mdx-components_list-item__fJ1NL\",\"children\":\"失敗——訊息完全正常，帶有正常既格式、正確既數據，但係 producer、messaging broker、consumer 全部或者部分出錯。\"}],\"\\n\",[\"$\",\"li\",null,{\"className\":\"mdx-components_list-item__fJ1NL\",\"children\":\"失敗——因為訊息本身有問題（稱之為 poison message），例如係帶有 consumer microservice 冇辦法理解既格式或者錯誤既數據。\"}],\"\\n\"]}],\"\\n\",\"$undefined\",\"\\n\",[\"$\",\"a\",null,{\"href\":\"#3-訊息傳遞保證\",\"style\":{\"textDecoration\":\"none\"},\"children\":[\"$\",\"h1\",null,{\"id\":\"3-訊息傳遞保證\",\"className\":\"mdx-components_heading__HrNl3 mdx-components_heading-new-section__YU39B\",\"style\":{\"zIndex\":3000000},\"children\":[[\"$\",\"i\",null,{\"className\":\"fa-solid fa-link mdx-components_heading-link__r6M6c\"}],\"3 訊息傳遞保證\"]}]}],\"\\n\",[\"$\",\"div\",null,{\"className\":\"mdx-components_paragraph__AUxxF\",\"children\":\"喺講 design patterns 之前，我地要先思考下訊息傳遞可以有幾多種保證（message delivery guarantees）。\"}],\"\\n\",[\"$\",\"div\",null,{\"className\":\"mdx-components_table-outer-wrapper__npuxp\",\"children\":[\"$\",\"div\",null,{\"className\":\"mdx-components_table-wrapper__0GcvD\",\"children\":[\"$\",\"table\",null,{\"className\":\"mdx-components_table__bAy19\",\"children\":[[\"$\",\"thead\",null,{\"children\":[\"$\",\"tr\",null,{\"children\":[[\"$\",\"th\",null,{\"children\":\"訊息傳遞保證\"}],[\"$\",\"th\",null,{\"children\":\"描述\"}],[\"$\",\"th\",null,{\"children\":\"解釋\"}]]}]}],[\"$\",\"tbody\",null,{\"children\":[[\"$\",\"tr\",null,{\"children\":[[\"$\",\"td\",null,{\"children\":\"Exactly once\"}],[\"$\",\"td\",null,{\"children\":\"每個訊息一定會被傳遞一次。\"}],[\"$\",\"td\",null,{\"children\":\"最理想當然係咁，但當我地考慮到任何野喺任何時候都有低機率會出錯，咁就知道其實實際上係好難（甚至冇可能）實現到呢個保證。\"}]]}],[\"$\",\"tr\",null,{\"children\":[[\"$\",\"td\",null,{\"children\":\"At least once\"}],[\"$\",\"td\",null,{\"children\":\"每個訊息至少會被傳遞一次，亦有可能會被傳遞多過一次。\"}],[\"$\",\"td\",null,{\"children\":\"呢個保證係可以接受既次選，但係接收左訊息之後，我地既處理過程一定要係 idempotent，即係同一段 code 執行多過一次既結果都係一樣（主要係 database 裡面既 data）。當遇到有問題既訊息，呢個保證會令到個 MQ 長期塞住。\"}]]}],[\"$\",\"tr\",null,{\"children\":[[\"$\",\"td\",null,{\"children\":\"At most once\"}],[\"$\",\"td\",null,{\"children\":\"每個訊息最多會被傳遞一次，亦有可能冇被傳遞。\"}],[\"$\",\"td\",null,{\"children\":\"呢個純粹係 best effort 盡做，所以係一個唔可靠既保證。\"}]]}]]}]]}]}]}],\"\\n\",\"$undefined\",\"\\n\",[\"$\",\"a\",null,{\"href\":\"#4-outbox-pattern\",\"style\":{\"textDecoration\":\"none\"},\"children\":[\"$\",\"h1\",null,{\"id\":\"4-outbox-pattern\",\"className\":\"mdx-components_heading__HrNl3 mdx-components_heading-new-section__YU39B\",\"style\":{\"zIndex\":4000000},\"children\":[[\"$\",\"i\",null,{\"className\":\"fa-solid fa-link mdx-components_heading-link__r6M6c\"}],\"4 Outbox pattern\"]}]}],\"\\n\",[\"$\",\"div\",null,{\"className\":\"mdx-components_paragraph__AUxxF\",\"children\":\"Outbox pattern 可以做到 at least once 既訊息傳遞保證，確保最終一定可以發送到訊息。\"}],\"\\n\",[\"$\",\"div\",null,{\"className\":\"mdx-components_paragraph__AUxxF\",\"children\":\"通常 producer microservices 都唔會只係發送訊息，佢地通常都會先做一輪 database 讀寫，最後先會發送訊息去通知 downstream microservices。因為呢兩個步驟唔係 atomic，如果 database 讀寫成功，但係發送訊息失敗，咁就好可能會令業務出現問題。\"}],\"\\n\",[\"$\",\"div\",null,{\"className\":\"mdx-components_paragraph__AUxxF\",\"children\":\"其中一個可能性係 messaging service 出現問題（但 network 冇問題），令到呢一刻唔能夠發送訊息，就算有 retry 都未必可以喺短期內成功發送到訊息去 messaging service 度。\"}],\"\\n\",[\"$\",\"div\",null,{\"className\":\"mdx-components_paragraph__AUxxF\",\"children\":\"因為係 at least once 既訊息傳遞，我地唔可以因為重複處理相同既訊息而令到數據出錯，例如業務上重複扣除客戶戶口既錢。咁所以：\"}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"className\":\"mdx-components_list-item__fJ1NL\",\"children\":\"Consumer microservices 要識得 deduplicate 訊息；\"}],\"\\n\",[\"$\",\"li\",null,{\"className\":\"mdx-components_list-item__fJ1NL\",\"children\":\"或者 consumer microservices 喺接收到訊息之後既處理過程一定要係 idempotent。\"}],\"\\n\"]}],\"\\n\",[\"$\",\"div\",null,{\"className\":\"mdx-components_paragraph__AUxxF\",\"children\":\"註：\"}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"className\":\"mdx-components_list-item__fJ1NL\",\"children\":\"就算 messaging service 識得 deduplicate 都冇用，因為 consumer microservices 可能會喺向 messaging service 發送確認既時候出錯，咁就會令到 consumer microservices 接收多過一次相同既訊息。\"}],\"\\n\"]}],\"\\n\",[\"$\",\"a\",null,{\"href\":\"#41-實現方式\",\"style\":{\"textDecoration\":\"none\"},\"children\":[\"$\",\"h2\",null,{\"id\":\"41-實現方式\",\"className\":\"mdx-components_heading__HrNl3 mdx-components_heading-sub-section__AJ2JK\",\"style\":{\"zIndex\":4010000},\"children\":[[\"$\",\"i\",null,{\"className\":\"fa-solid fa-link mdx-components_heading-link__r6M6c\"}],\"4.1 實現方式\"]}]}],\"\\n\",[\"$\",\"div\",null,{\"className\":\"mdx-components_paragraph__AUxxF\",\"children\":\"我地需要用到一個 RDBMS database table 去保存需要發送既訊息，並且利用 RDBMS databases 既 ACID 特性，令到 database 讀寫、發送訊息呢兩個步驟變到 atomic。\"}],\"\\n\",[\"$\",\"div\",null,{\"className\":\"mdx-components_paragraph__AUxxF\",\"children\":\"以下係具體既流程：\"}],\"\\n\",[\"$\",\"ol\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"className\":\"mdx-components_list-item__fJ1NL\",\"children\":\"Producer microservice 收到 request。\"}],\"\\n\",[\"$\",\"li\",null,{\"className\":\"mdx-components_list-item__fJ1NL\",\"children\":\"Producer microservice 開始一個 database transaction。\"}],\"\\n\",[\"$\",\"li\",null,{\"className\":\"mdx-components_list-item__fJ1NL\",\"children\":\"Producer microservice 讀寫 database 去更新一啲業務數據。\"}],\"\\n\",[\"$\",\"li\",null,{\"className\":\"mdx-components_list-item__fJ1NL\",\"children\":\"Producer microservice 將需要發送既訊息保存喺 outbox table。\"}],\"\\n\",[\"$\",\"li\",null,{\"className\":\"mdx-components_list-item__fJ1NL\",\"children\":\"Producer microservice 完成個 database transaction。\"}],\"\\n\"]}],\"\\n\",[\"$\",\"div\",null,{\"className\":\"mdx-components_paragraph__AUxxF\",\"children\":\"另外亦都需要有一個定期重複執行既 schedule，producer microservice 要定期發送所有未發送既訊息：\"}],\"\\n\",[\"$\",\"ol\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"className\":\"mdx-components_list-item__fJ1NL\",\"children\":\"Producer microservice 查詢 outbox table 裡面未發送既 records。\"}],\"\\n\",[\"$\",\"li\",null,{\"className\":\"mdx-components_list-item__fJ1NL\",\"children\":\"Producer microservice 發送一個或多個訊息到 messaging service。\"}],\"\\n\",[\"$\",\"li\",null,{\"className\":\"mdx-components_list-item__fJ1NL\",\"children\":\"Producer microservice 等 messaging service 確認所有訊息成功發送（publisher acknowledgements／confirms）。\"}],\"\\n\",[\"$\",\"li\",null,{\"className\":\"mdx-components_list-item__fJ1NL\",\"children\":\"Producer microservice 開始一個 database transaction。\"}],\"\\n\",[\"$\",\"li\",null,{\"className\":\"mdx-components_list-item__fJ1NL\",\"children\":\"Producer microservice soft delete 或者 hard delete outbox table record(s)。\"}],\"\\n\",[\"$\",\"li\",null,{\"className\":\"mdx-components_list-item__fJ1NL\",\"children\":\"Producer microservice 完成個 database transaction。\"}],\"\\n\"]}],\"\\n\",[\"$\",\"div\",null,{\"className\":\"mdx-components_paragraph__AUxxF\",\"children\":\"註：\"}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"className\":\"mdx-components_list-item__fJ1NL\",\"children\":\"視乎情況，發送訊息既時候有可能需要注意 message ordering。\"}],\"\\n\",[\"$\",\"li\",null,{\"className\":\"mdx-components_list-item__fJ1NL\",\"children\":[\"如果有任何出錯，一定要 throw exception。\",\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"className\":\"mdx-components_list-item__fJ1NL\",\"children\":\"如果發送訊息既時候出現 exception，都唔一定需要影響到處理其他 surrogate keys 既 records。\"}],\"\\n\"]}],\"\\n\"]}],\"\\n\",[\"$\",\"li\",null,{\"className\":\"mdx-components_list-item__fJ1NL\",\"children\":[\"如果利用 batch publishing 既方式發送訊息，而唔係逐個訊息咁發送，咁個 messaging service 一係要保證到 atomicity（全部成功或者全部失敗）。\",\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"className\":\"mdx-components_list-item__fJ1NL\",\"children\":\"如果我地對 message ordering 有要求，而個 messaging service 唔保證 atomicity，咁 consumer microservice 處理既訊息次序就有可能會亂曬。\"}],\"\\n\"]}],\"\\n\"]}],\"\\n\"]}],\"\\n\",\"$undefined\",\"\\n\",[\"$\",\"a\",null,{\"href\":\"#42-所有有可能出錯既情況\",\"style\":{\"textDecoration\":\"none\"},\"children\":[\"$\",\"h2\",null,{\"id\":\"42-所有有可能出錯既情況\",\"className\":\"mdx-components_heading__HrNl3 mdx-components_heading-sub-section__AJ2JK\",\"style\":{\"zIndex\":4020000},\"children\":[[\"$\",\"i\",null,{\"className\":\"fa-solid fa-link mdx-components_heading-link__r6M6c\"}],\"4.2 所有有可能出錯既情況\"]}]}],\"\\n\",[\"$\",\"div\",null,{\"className\":\"mdx-components_paragraph__AUxxF\",\"children\":\"我地需要考慮到任何步驟都有出錯既機會，我地注重既係對數據一致性既影響。\"}],\"\\n\",[\"$\",\"div\",null,{\"className\":\"mdx-components_paragraph__AUxxF\",\"children\":\"註：\"}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"className\":\"mdx-components_list-item__fJ1NL\",\"children\":\"「出錯」可以係 runtime exception，亦可以係成個 microservice instance 或者 messaging service 重新啟動或者死機。\"}],\"\\n\",[\"$\",\"li\",null,{\"className\":\"mdx-components_list-item__fJ1NL\",\"children\":\"一旦出錯，就會跳過所有後續既步驟。\"}],\"\\n\"]}],\"\\n\",[\"$\",\"div\",null,{\"className\":\"mdx-components_table-outer-wrapper__npuxp\",\"children\":[\"$\",\"div\",null,{\"className\":\"mdx-components_table-wrapper__0GcvD\",\"children\":[\"$\",\"table\",null,{\"className\":\"mdx-components_table__bAy19\",\"children\":[[\"$\",\"thead\",null,{\"children\":[\"$\",\"tr\",null,{\"children\":[[\"$\",\"th\",null,{\"children\":\"出錯情況\"}],[\"$\",\"th\",null,{\"children\":\"對數據一致性既影響\"}]]}]}],[\"$\",\"tbody\",null,{\"children\":[[\"$\",\"tr\",null,{\"children\":[[\"$\",\"td\",null,{\"children\":\"Producer microservice 收到 request 之前出錯。\"}],[\"$\",\"td\",null,{\"children\":\"✅ 如果只有一個 instance，咁好可能會影響業務運作，但就對數據一致性冇任何影響。\"}]]}],[\"$\",\"tr\",null,{\"children\":[[\"$\",\"td\",null,{\"children\":\"Producer microservice 收到 request 之後出錯。\"}],[\"$\",\"td\",null,{\"children\":\"✅ 個 request 固然會失敗，但係因為未寫入過任何數據，所以對數據一致性冇任何影響。\"}]]}],[\"$\",\"tr\",null,{\"children\":[[\"$\",\"td\",null,{\"children\":\"Producer microservice 開始一個 database transaction 之後出錯。\"}],[\"$\",\"td\",null,{\"children\":\"✅ 個 request 固然會失敗，而 database 會自動 rollback transaction，最終係冇任何數據上既改動，亦對數據一致性冇影響。\"}]]}],[\"$\",\"tr\",null,{\"children\":[[\"$\",\"td\",null,{\"children\":\"Producer microservice 讀寫 database 去更新一啲業務數據之後出錯。\"}],[\"$\",\"td\",null,{\"children\":\"✅ 個 request 固然會失敗，但係 database 會自動 rollback transaction，最終係冇任何數據上既改動，亦對數據一致性冇影響。\"}]]}],[\"$\",\"tr\",null,{\"children\":[[\"$\",\"td\",null,{\"children\":\"Producer microservice 將需要發送既訊息保存喺 outbox table 之後出錯。\"}],[\"$\",\"td\",null,{\"children\":\"✅ 個 request 固然會失敗，但係 database 會自動 rollback transaction，最終係冇任何數據上既改動，亦對數據一致性冇影響。\"}]]}],[\"$\",\"tr\",null,{\"children\":[[\"$\",\"td\",null,{\"children\":\"Producer microservice 完成個 database transaction 之後出錯。\"}],[\"$\",\"td\",null,{\"children\":\"✅ 因為已經完成 database transaction，所有數據已經保存妥當，所以對數據一致性冇影響。但因為個 request 失敗左，upstream microservice 可能會 retry 個 request，只要呢個 producer microservice 既處理過程係 idempotent，咁就唔成問題。\"}]]}]]}]]}]}]}],\"\\n\",[\"$\",\"div\",null,{\"className\":\"mdx-components_paragraph__AUxxF\",\"children\":\"至於定期發送訊息既 schedule：\"}],\"\\n\",[\"$\",\"div\",null,{\"className\":\"mdx-components_table-outer-wrapper__npuxp\",\"children\":[\"$\",\"div\",null,{\"className\":\"mdx-components_table-wrapper__0GcvD\",\"children\":[\"$\",\"table\",null,{\"className\":\"mdx-components_table__bAy19\",\"children\":[[\"$\",\"thead\",null,{\"children\":[\"$\",\"tr\",null,{\"children\":[[\"$\",\"th\",null,{\"children\":\"出錯情況\"}],[\"$\",\"th\",null,{\"children\":\"對數據一致性既影響\"}]]}]}],[\"$\",\"tbody\",null,{\"children\":[[\"$\",\"tr\",null,{\"children\":[[\"$\",\"td\",null,{\"children\":\"Producer microservice 查詢 outbox table 裡面未發送既 records 之前出錯。\"}],[\"$\",\"td\",null,{\"children\":\"✅ 因為乜都未做過，所以對數據一致性冇影響。\"}]]}],[\"$\",\"tr\",null,{\"children\":[[\"$\",\"td\",null,{\"children\":\"Producer microservice 查詢 outbox table 裡面未發送既 records 之後出錯。\"}],[\"$\",\"td\",null,{\"children\":\"✅ 因為乜都未做過，所以對數據一致性冇影響。\"}]]}],[\"$\",\"tr\",null,{\"children\":[[\"$\",\"td\",null,{\"children\":\"Producer microservice 發送單一訊息既時候出錯，導致訊息發送唔到。\"}],[\"$\",\"td\",null,{\"children\":\"✅ 因為冇發送到訊息，所以對數據一致性冇影響。\"}]]}],[\"$\",\"tr\",null,{\"children\":[[\"$\",\"td\",null,{\"children\":\"Producer microservice 發送單一訊息到 messaging service 既時候出錯，導致訊息發送左，但係收唔到 messaging service 既確認。\"}],[\"$\",\"td\",null,{\"children\":\"✅ 因為有可能已經成功發送左訊息，但係冇更新到 outbox table，咁之後一定會再次發送相同既訊息，如果個 messaging service 支援 deduplication 又或者個 consumer microservice 識得 deduplicate 或者係 idempotent 既處理過程就冇問題，所以對數據一致性冇影響。\"}]]}],[\"$\",\"tr\",null,{\"children\":[[\"$\",\"td\",null,{\"children\":\"Producer microservice 發送單一訊息到 messaging service 之後出錯，導致訊息發送左，而又收到 messaging service 既確認，但係之後出錯。\"}],[\"$\",\"td\",null,{\"children\":\"✅ 因為已經發送左訊息，但係冇更新到 outbox table，咁之後一定會再次發送相同既訊息，如果個 messaging service 支援 deduplication 又或者個 consumer microservice 識得 deduplicate 或者係 idempotent 既處理過程就冇問題，所以對數據一致性冇影響。\"}]]}],[\"$\",\"tr\",null,{\"children\":[[\"$\",\"td\",null,{\"children\":\"Producer microservice batch 發送多個訊息到 messaging service 之間出錯。\"}],[\"$\",\"td\",null,{\"children\":\"✅ 用得 batch publishing，我地就期望個 messaging service 有 atomicity guarantee，如果失敗既話就會係個 batch 裡面全部訊息發送失敗，個 messaging service 唔會保存呢個 batch 裡面既任何一個訊息。因為等同於冇發送到訊息，所以對數據一致性冇影響。\"}]]}],[\"$\",\"tr\",null,{\"children\":[[\"$\",\"td\",null,{\"children\":\"Producer microservice batch 發送多個訊息到 messaging service 既時候出錯，導致訊息發送左，但係收唔到 messaging service 既確認。\"}],[\"$\",\"td\",null,{\"children\":\"✅ 因為有可能已經成功發送左訊息，但係冇更新到 outbox table，咁之後一定會再次發送相同既訊息，如果個 messaging service 支援 deduplication 又或者個 consumer microservice 識得 deduplicate 或者係 idempotent 既處理過程就冇問題，所以對數據一致性冇影響。\"}]]}],[\"$\",\"tr\",null,{\"children\":[[\"$\",\"td\",null,{\"children\":\"Producer microservice batch 發送多個訊息到 messaging service 之後出錯，導致訊息發送左，而又收到 messaging service 既確認，但係之後出錯。\"}],[\"$\",\"td\",null,{\"children\":\"✅ 因為已經發送左訊息，但係冇更新到 outbox table，咁之後一定會再次發送相同既訊息，如果個 messaging service 支援 deduplication 又或者個 consumer microservice 識得 deduplicate 或者係 idempotent 既處理過程就冇問題，所以對數據一致性冇影響。\"}]]}],[\"$\",\"tr\",null,{\"children\":[[\"$\",\"td\",null,{\"children\":\"Producer microservice 開始一個 database transaction 之後出錯。\"}],[\"$\",\"td\",null,{\"children\":\"✅ 因為已經發送左訊息，但係冇更新到 outbox table，咁之後一定會再次發送相同既訊息，如果個 messaging service 支援 deduplication 又或者個 consumer microservice 識得 deduplicate 或者係 idempotent 既處理過程就冇問題，所以對數據一致性冇影響。\"}]]}],[\"$\",\"tr\",null,{\"children\":[[\"$\",\"td\",null,{\"children\":\"Producer microservice soft delete 或者 hard delete outbox table record(s) 之後出錯。\"}],[\"$\",\"td\",null,{\"children\":\"✅ 因為已經發送左訊息，但係冇更新到 outbox table，咁之後一定會再次發送相同既訊息，如果個 messaging service 支援 deduplication 又或者個 consumer microservice 識得 deduplicate 或者係 idempotent 既處理過程就冇問題，所以對數據一致性冇影響。\"}]]}],[\"$\",\"tr\",null,{\"children\":[[\"$\",\"td\",null,{\"children\":\"Producer microservice 完成個 database transaction 之後出錯。\"}],[\"$\",\"td\",null,{\"children\":\"✅ 因為所有訊息已經成功發送，而且已經完成 database transaction，所有數據已經保存妥當，所以對數據一致性冇影響。\"}]]}]]}]]}]}]}],\"\\n\",\"$undefined\",\"\\n\",[\"$\",\"a\",null,{\"href\":\"#5-inbox-pattern\",\"style\":{\"textDecoration\":\"none\"},\"children\":[\"$\",\"h1\",null,{\"id\":\"5-inbox-pattern\",\"className\":\"mdx-components_heading__HrNl3 mdx-components_heading-new-section__YU39B\",\"style\":{\"zIndex\":5000000},\"children\":[[\"$\",\"i\",null,{\"className\":\"fa-solid fa-link mdx-components_heading-link__r6M6c\"}],\"5 Inbox pattern\"]}]}],\"\\n\",[\"$\",\"div\",null,{\"className\":\"mdx-components_paragraph__AUxxF\",\"children\":\"Inbox pattern 雖然有啲似 outbox pattern，但佢就冇 outbox pattern 既必要性。\"}],\"\\n\",[\"$\",\"div\",null,{\"className\":\"mdx-components_paragraph__AUxxF\",\"children\":\"Outbox pattern 之所以重要，係因為：\"}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"className\":\"mdx-components_list-item__fJ1NL\",\"children\":\"唔用 outbox pattern 而發送訊息失敗既話，咁可能就咩都冇，需要發送既訊息從此就會漏左；\"}],\"\\n\",[\"$\",\"li\",null,{\"className\":\"mdx-components_list-item__fJ1NL\",\"children\":\"用左 outbox pattern 就可以保證我地想發送既訊息最終都一定會發送到。\"}],\"\\n\"]}],\"\\n\",[\"$\",\"div\",null,{\"className\":\"mdx-components_paragraph__AUxxF\",\"children\":\"如果冇 inbox pattern，都唔係唔得既，只係 consumer microservices 就要喺成功完成所有業務邏輯之後先至可以向 messaging service 確認訊息接收成功（acknowledgement），而確認既過程都有可能會出錯，咁即係無論 producer microservices 發送訊息係 at least once，或者 consumer microservices 接收訊息係 at least once，我地既 consumer microservices 都一定要有 idempotent 既處理過程。\"}],\"\\n\",[\"$\",\"a\",null,{\"href\":\"#51-實現方式\",\"style\":{\"textDecoration\":\"none\"},\"children\":[\"$\",\"h2\",null,{\"id\":\"51-實現方式\",\"className\":\"mdx-components_heading__HrNl3 mdx-components_heading-sub-section__AJ2JK\",\"style\":{\"zIndex\":5010000},\"children\":[[\"$\",\"i\",null,{\"className\":\"fa-solid fa-link mdx-components_heading-link__r6M6c\"}],\"5.1 實現方式\"]}]}],\"\\n\",[\"$\",\"div\",null,{\"className\":\"mdx-components_paragraph__AUxxF\",\"children\":\"我地需要用到一個 RDBMS database table 去 mark 低未完成以及已經完成處理既訊息，並且利用 RDBMS databases 既 ACID 特性，令到完成處理訊息、database 讀寫呢兩個步驟變到 atomic。\"}],\"\\n\",[\"$\",\"div\",null,{\"className\":\"mdx-components_paragraph__AUxxF\",\"children\":\"以下係具體既流程：\"}],\"\\n\",[\"$\",\"ol\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"className\":\"mdx-components_list-item__fJ1NL\",\"children\":\"Consumer microservice 訂閱 messaging service。\"}],\"\\n\",[\"$\",\"li\",null,{\"className\":\"mdx-components_list-item__fJ1NL\",\"children\":\"Consumer microservice 接收到新訊息。\"}],\"\\n\",[\"$\",\"li\",null,{\"className\":\"mdx-components_list-item__fJ1NL\",\"children\":\"Consumer microservice 開始一個 database transaction。\"}],\"\\n\",[\"$\",\"li\",null,{\"className\":\"mdx-components_list-item__fJ1NL\",\"children\":\"Consumer microservice 將需要處理既訊息保存喺 inbox table。\"}],\"\\n\",[\"$\",\"li\",null,{\"className\":\"mdx-components_list-item__fJ1NL\",\"children\":\"Consumer microservice 完成個 database transaction。\"}],\"\\n\",[\"$\",\"li\",null,{\"className\":\"mdx-components_list-item__fJ1NL\",\"children\":\"Consumer microservice 向 messaging service 確認訊息接收（consumer acknowledgements）。\"}],\"\\n\"]}],\"\\n\",[\"$\",\"div\",null,{\"className\":\"mdx-components_paragraph__AUxxF\",\"children\":\"另外亦都需要有一個定期重複執行既 schedule，consumer microservice 要定期處理所有接收左既訊息：\"}],\"\\n\",[\"$\",\"ol\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"className\":\"mdx-components_list-item__fJ1NL\",\"children\":\"Consumer microservice 查詢 inbox table 未處理既 records。\"}],\"\\n\",[\"$\",\"li\",null,{\"className\":\"mdx-components_list-item__fJ1NL\",\"children\":\"Consumer microservice 開始一個 database transaction。\"}],\"\\n\",[\"$\",\"li\",null,{\"className\":\"mdx-components_list-item__fJ1NL\",\"children\":\"Consumer microservice soft delete 或者 hard delete inbox table record(s)。\"}],\"\\n\",[\"$\",\"li\",null,{\"className\":\"mdx-components_list-item__fJ1NL\",\"children\":\"Consumer microservice 讀寫 database 去更新一啲業務數據。\"}],\"\\n\",[\"$\",\"li\",null,{\"className\":\"mdx-components_list-item__fJ1NL\",\"children\":\"Consumer microservice 完成個 database transaction。\"}],\"\\n\"]}],\"\\n\",[\"$\",\"div\",null,{\"className\":\"mdx-components_paragraph__AUxxF\",\"children\":\"註：\"}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"className\":\"mdx-components_list-item__fJ1NL\",\"children\":\"如果想利用個 inbox table 幫我地 deduplicate 重複接收既相同訊息，咁我地處理既時候就唔可以 hard delete inbox table records，因為成個 record 刪左就會冇辦法知道邊啲係已經接收過。\"}],\"\\n\"]}],\"\\n\",\"$undefined\",\"\\n\",[\"$\",\"a\",null,{\"href\":\"#52-所有有可能出錯既情況\",\"style\":{\"textDecoration\":\"none\"},\"children\":[\"$\",\"h2\",null,{\"id\":\"52-所有有可能出錯既情況\",\"className\":\"mdx-components_heading__HrNl3 mdx-components_heading-sub-section__AJ2JK\",\"style\":{\"zIndex\":5020000},\"children\":[[\"$\",\"i\",null,{\"className\":\"fa-solid fa-link mdx-components_heading-link__r6M6c\"}],\"5.2 所有有可能出錯既情況\"]}]}],\"\\n\",[\"$\",\"div\",null,{\"className\":\"mdx-components_paragraph__AUxxF\",\"children\":\"我地需要考慮到任何步驟都有出錯既機會，我地注重既係對數據一致性既影響。\"}],\"\\n\",[\"$\",\"div\",null,{\"className\":\"mdx-components_paragraph__AUxxF\",\"children\":\"註：\"}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"className\":\"mdx-components_list-item__fJ1NL\",\"children\":\"「出錯」可以係 runtime exception，亦可以係成個 microservice instance 或者 messaging service 重新啟動或者死機。\"}],\"\\n\",[\"$\",\"li\",null,{\"className\":\"mdx-components_list-item__fJ1NL\",\"children\":\"一旦出錯，就會跳過所有後續既步驟。\"}],\"\\n\"]}],\"\\n\",[\"$\",\"div\",null,{\"className\":\"mdx-components_table-outer-wrapper__npuxp\",\"children\":[\"$\",\"div\",null,{\"className\":\"mdx-components_table-wrapper__0GcvD\",\"children\":[\"$\",\"table\",null,{\"className\":\"mdx-components_table__bAy19\",\"children\":[[\"$\",\"thead\",null,{\"children\":[\"$\",\"tr\",null,{\"children\":[[\"$\",\"th\",null,{\"children\":\"出錯情況\"}],[\"$\",\"th\",null,{\"children\":\"對數據一致性既影響\"}]]}]}],[\"$\",\"tbody\",null,{\"children\":[[\"$\",\"tr\",null,{\"children\":[[\"$\",\"td\",null,{\"children\":\"Consumer microservice 訂閱 messaging service 之前出錯。\"}],[\"$\",\"td\",null,{\"children\":\"✅ 如果只有一個 instance，咁好可能會影響業務運作，但就對數據一致性冇任何影響。\"}]]}],[\"$\",\"tr\",null,{\"children\":[[\"$\",\"td\",null,{\"children\":\"Consumer microservice 訂閱 messaging service 之後出錯。\"}],[\"$\",\"td\",null,{\"children\":\"✅ 如果只有一個 instance，咁好可能會影響業務運作，但就對數據一致性冇任何影響。\"}]]}],[\"$\",\"tr\",null,{\"children\":[[\"$\",\"td\",null,{\"children\":\"Consumer microservice 接收到新訊息之後出錯。\"}],[\"$\",\"td\",null,{\"children\":\"✅ 因為已經接收左訊息，但係冇更新到 inbox table，咁之後一定會再次接收相同既訊息，如果個 consumer microservice 係 idempotent 既處理過程就冇問題，所以對數據一致性冇影響。\"}]]}],[\"$\",\"tr\",null,{\"children\":[[\"$\",\"td\",null,{\"children\":\"Consumer microservice 開始一個 database transaction 之後出錯。\"}],[\"$\",\"td\",null,{\"children\":\"✅ 因為 database 會自動 rollback transaction，咁之後一定會再次接收相同既訊息，如果個 consumer microservice 係 idempotent 既處理過程就冇問題，所以對數據一致性冇影響。\"}]]}],[\"$\",\"tr\",null,{\"children\":[[\"$\",\"td\",null,{\"children\":\"Consumer microservice 將需要處理既訊息保存喺 inbox table 之後出錯。\"}],[\"$\",\"td\",null,{\"children\":\"✅ 因為已經接收左訊息，而 database 會自動 rollback transaction，咁之後一定會再次接收相同既訊息，如果個 consumer microservice 係 idempotent 既處理過程就冇問題，所以對數據一致性冇影響。\"}]]}],[\"$\",\"tr\",null,{\"children\":[[\"$\",\"td\",null,{\"children\":\"Consumer microservice 完成個 database transaction 之後出錯，冇向 messaging service 確認訊息接收。\"}],[\"$\",\"td\",null,{\"children\":\"✅ 因為已經完成 database transaction，但係冇向 messaging service 確認到訊息接收，咁之後一定會再次接收相同既訊息，如果個 consumer microservice 係 idempotent 既處理過程就冇問題，所以對數據一致性冇影響。\"}]]}],[\"$\",\"tr\",null,{\"children\":[[\"$\",\"td\",null,{\"children\":\"Consumer microservice 向 messaging service 確認訊息接收既時候出錯。\"}],[\"$\",\"td\",null,{\"children\":\"✅ 因為已經完成 database transaction，但係有可能冇確認到訊息接收，咁之後可能會再次接收相同既訊息，如果個 inbox table 識得 deduplicate 或者 consumer microservice 係 idempotent 既處理過程就冇問題，所以對數據一致性冇影響。\"}]]}],[\"$\",\"tr\",null,{\"children\":[[\"$\",\"td\",null,{\"children\":\"Consumer microservice 向 messaging service 確認訊息接收之後出錯。\"}],[\"$\",\"td\",null,{\"children\":\"✅ 因為已經完成 database transaction，所有數據已經保存妥當，而且已經確認接收，所以之後唔會接收重複既訊息，亦對數據一致性冇影響。\"}]]}]]}]]}]}]}],\"\\n\",[\"$\",\"div\",null,{\"className\":\"mdx-components_paragraph__AUxxF\",\"children\":\"至於定期處理訊息既 schedule：\"}],\"\\n\",[\"$\",\"div\",null,{\"className\":\"mdx-components_table-outer-wrapper__npuxp\",\"children\":[\"$\",\"div\",null,{\"className\":\"mdx-components_table-wrapper__0GcvD\",\"children\":[\"$\",\"table\",null,{\"className\":\"mdx-components_table__bAy19\",\"children\":[[\"$\",\"thead\",null,{\"children\":[\"$\",\"tr\",null,{\"children\":[[\"$\",\"th\",null,{\"children\":\"出錯情況\"}],[\"$\",\"th\",null,{\"children\":\"對數據一致性既影響\"}]]}]}],[\"$\",\"tbody\",null,{\"children\":[[\"$\",\"tr\",null,{\"children\":[[\"$\",\"td\",null,{\"children\":\"Consumer microservice 查詢 inbox table 未處理既 records 之前出錯。\"}],[\"$\",\"td\",null,{\"children\":\"✅ 因為乜都未做過，所以對數據一致性冇影響。\"}]]}],[\"$\",\"tr\",null,{\"children\":[[\"$\",\"td\",null,{\"children\":\"Consumer microservice 查詢 inbox table 未處理既 records 之後出錯。\"}],[\"$\",\"td\",null,{\"children\":\"✅ 因為乜都未做過，所以對數據一致性冇影響。\"}]]}],[\"$\",\"tr\",null,{\"children\":[[\"$\",\"td\",null,{\"children\":\"Consumer microservice 開始一個 database transaction 之後出錯。\"}],[\"$\",\"td\",null,{\"children\":\"✅ Database 會自動 rollback transaction，最終係冇任何數據上既改動，亦對數據一致性冇影響。\"}]]}],[\"$\",\"tr\",null,{\"children\":[[\"$\",\"td\",null,{\"children\":\"Consumer microservice soft delete 或者 hard delete inbox table record(s) 之後出錯。\"}],[\"$\",\"td\",null,{\"children\":\"✅ Database 會自動 rollback transaction，最終係冇任何數據上既改動，亦對數據一致性冇影響。\"}]]}],[\"$\",\"tr\",null,{\"children\":[[\"$\",\"td\",null,{\"children\":\"Consumer microservice 讀寫 database 去更新一啲業務數據之後出錯。\"}],[\"$\",\"td\",null,{\"children\":\"✅ Database 會自動 rollback transaction，最終係冇任何數據上既改動，亦對數據一致性冇影響。\"}]]}],[\"$\",\"tr\",null,{\"children\":[[\"$\",\"td\",null,{\"children\":\"Consumer microservice 完成個 database transaction 之後出錯。\"}],[\"$\",\"td\",null,{\"children\":\"✅ 因為已經完成 database transaction，所有數據已經保存妥當，所以對數據一致性冇影響。\"}]]}]]}]]}]}]}],\"\\n\",\"$undefined\",\"\\n\",[\"$\",\"a\",null,{\"href\":\"#6-考慮事項\",\"style\":{\"textDecoration\":\"none\"},\"children\":[\"$\",\"h1\",null,{\"id\":\"6-考慮事項\",\"className\":\"mdx-components_heading__HrNl3 mdx-components_heading-new-section__YU39B\",\"style\":{\"zIndex\":6000000},\"children\":[[\"$\",\"i\",null,{\"className\":\"fa-solid fa-link mdx-components_heading-link__r6M6c\"}],\"6 考慮事項\"]}]}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"className\":\"mdx-components_list-item__fJ1NL\",\"children\":\"我地既 microservices 既處理過程需要做到 idempotent。如果做唔到，數據就有機會因為各種 retry 機制而終有一日出錯。\"}],\"\\n\",[\"$\",\"li\",null,{\"className\":\"mdx-components_list-item__fJ1NL\",\"children\":[\"考慮到 consumer microservice 可能會重複收到相同既訊息，如果佢既處理過程冇辦法做到 idempotent，咁就要考慮從個 inbox table 入手。\",\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"className\":\"mdx-components_list-item__fJ1NL\",\"children\":\"Upstream microservice 發送畀 producer microservice 既 HTTP request 既 header 可以加入一個隨機既 UUID。而次選既方法係 producer microservice 根據 HTTP request body 某啲數據去計算一個 hash，但係會有機會誤判。\"}],\"\\n\",[\"$\",\"li\",null,{\"className\":\"mdx-components_list-item__fJ1NL\",\"children\":\"Producer microservice 可以用呢個 value 作為訊息既 ID。\"}],\"\\n\",[\"$\",\"li\",null,{\"className\":\"mdx-components_list-item__fJ1NL\",\"children\":[\"Consumer microservice 既 inbox table 要有一個 \",[\"$\",\"code\",null,{\"className\":\"undefined mdx-components_inline-code__y_QeQ\",\"children\":\"message_id\"}],\" 既 column，然後整一個 unique index 落呢個 column 度。\"]}],\"\\n\",[\"$\",\"li\",null,{\"className\":\"mdx-components_list-item__fJ1NL\",\"children\":\"Consumer microservice 收到訊息之後，會將佢放落 inbox table，如果已經存在相同訊息 ID 既 record，就會出現 unique index violation 既 exception，但係 consumer microservice 需要 ignore 呢個 exception，照樣向 messaging service 確認已經成功接收訊息，否則下次又會重新收到相同既訊息。\"}],\"\\n\",[\"$\",\"li\",null,{\"className\":\"mdx-components_list-item__fJ1NL\",\"children\":\"Consumer microservice 成功處理完訊息之後，只可以 soft delete inbox table 既 records，因為 hard delete 既話就會失去 unique index 幫我地 deduplicate 訊息既作用。\"}],\"\\n\"]}],\"\\n\"]}],\"\\n\",[\"$\",\"li\",null,{\"className\":\"mdx-components_list-item__fJ1NL\",\"children\":[\"如果用左 outbox pattern 以及 inbox pattern，仲有冇需要用 messaging service 收發訊息黎取代 HTTP requests？\",\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"className\":\"mdx-components_list-item__fJ1NL\",\"children\":\"我地的確可以用返 HTTP requests，因為有 database 既 inbox table 裝住未處理既數據，咁就一樣可以做到 asynchronous processing。\"}],\"\\n\",[\"$\",\"li\",null,{\"className\":\"mdx-components_list-item__fJ1NL\",\"children\":\"不過，HTTP requests 只能做到單一 consumer instance；相反，messaging service 可以畀我地做到 consumer groups，同一個 message 被多個 consumers 處理。\"}],\"\\n\",[\"$\",\"li\",null,{\"className\":\"mdx-components_list-item__fJ1NL\",\"children\":\"另外，如果我地想用 horizontal autoscaling 去維持多個 consumer microservice instances 去達到 high availability，而如果我地一定要維持返 message ordering，咁用 HTTP requests 既話就冇辦法指定邊一個 consumer microservice instance，咁就冇辦法確保到 requests 一定係順序完成處理；相反，如果我地用 RabbitMQ 既話可以用 single active consumer，或者 Kafka 既話用 partition，確保只會有一個 consumer microservice instance 接收到訊息，咁訊息接收次序就會同訊息發送次序一樣。\"}],\"\\n\"]}],\"\\n\"]}],\"\\n\"]}],\"\\n\",\"$undefined\",\"\\n\",[\"$\",\"a\",null,{\"href\":\"#7-參考資料\",\"style\":{\"textDecoration\":\"none\"},\"children\":[\"$\",\"h1\",null,{\"id\":\"7-參考資料\",\"className\":\"mdx-components_heading__HrNl3 mdx-components_heading-new-section__YU39B\",\"style\":{\"zIndex\":7000000},\"children\":[[\"$\",\"i\",null,{\"className\":\"fa-solid fa-link mdx-components_heading-link__r6M6c\"}],\"7 參考資料\"]}]}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"className\":\"mdx-components_list-item__fJ1NL\",\"children\":[[\"$\",\"span\",null,{\"children\":[\"$\",\"a\",null,{\"href\":\"https://softwaremill.com/microservices-101/\",\"target\":\"_blank\",\"rel\":\"external nofollow noopener noreferrer\",\"className\":\"common_anchor__kGNsN\",\"children\":\"Microservices 101: Transactional Outbox and Inbox\"}]}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"className\":\"mdx-components_list-item__fJ1NL\",\"children\":[\"\\n\",[\"$\",\"blockquote\",null,{\"className\":\"mdx-components_blockquote__CXIKy\",\"children\":[\"\\n\",[\"$\",\"div\",null,{\"className\":\"mdx-components_paragraph__AUxxF\",\"children\":\"Very often, the recipient service can cope without the inbox. If the task doesn’t take long to finish or completes a predictable amount of time, it can just ack the message after processing. Otherwise, it might be worthwhile to spend some effort to implement the pattern.\"}],\"\\n\"]}],\"\\n\"]}],\"\\n\"]}],\"\\n\"]}],\"\\n\",[\"$\",\"li\",null,{\"className\":\"mdx-components_list-item__fJ1NL\",\"children\":[\"$\",\"span\",null,{\"children\":[\"$\",\"a\",null,{\"href\":\"https://event-driven.io/en/outbox_inbox_patterns_and_delivery_guarantees_explained/\",\"target\":\"_blank\",\"rel\":\"external nofollow noopener noreferrer\",\"className\":\"common_anchor__kGNsN\",\"children\":\"Outbox, Inbox patterns and delivery guarantees explained\"}]}]}],\"\\n\",[\"$\",\"li\",null,{\"className\":\"mdx-components_list-item__fJ1NL\",\"children\":[\"$\",\"span\",null,{\"children\":[\"$\",\"a\",null,{\"href\":\"https://docs.aws.amazon.com/prescriptive-guidance/latest/cloud-design-patterns/transactional-outbox.html\",\"target\":\"_blank\",\"rel\":\"external nofollow noopener noreferrer\",\"className\":\"common_anchor__kGNsN\",\"children\":\"AWS Prescriptive Guidance - Transactional outbox pattern\"}]}]}],\"\\n\",[\"$\",\"li\",null,{\"className\":\"mdx-components_list-item__fJ1NL\",\"children\":[\"$\",\"span\",null,{\"children\":[\"$\",\"a\",null,{\"href\":\"https://medium.com/codait/handling-failure-successfully-in-rabbitmq-22ffa982b60f\",\"target\":\"_blank\",\"rel\":\"external nofollow noopener noreferrer\",\"className\":\"common_anchor__kGNsN\",\"children\":\"Handling Failure Successfully in RabbitMQ\"}]}]}],\"\\n\",[\"$\",\"li\",null,{\"className\":\"mdx-components_list-item__fJ1NL\",\"children\":[\"$\",\"span\",null,{\"children\":[\"$\",\"a\",null,{\"href\":\"https://www.linkedin.com/pulse/microservice-architecture-outbox-pattern-hugo-tota/\",\"target\":\"_blank\",\"rel\":\"external nofollow noopener noreferrer\",\"className\":\"common_anchor__kGNsN\",\"children\":\"Microservice architecture [Outbox pattern]\"}]}]}],\"\\n\",[\"$\",\"li\",null,{\"className\":\"mdx-components_list-item__fJ1NL\",\"children\":[[\"$\",\"span\",null,{\"children\":[\"$\",\"a\",null,{\"href\":\"https://www.berkansasmaz.com/every-programmer-should-know-idempotency/\",\"target\":\"_blank\",\"rel\":\"external nofollow noopener noreferrer\",\"className\":\"common_anchor__kGNsN\",\"children\":\"Every Programmer Should Know #1: Idempotency\"}]}],\"\\n\",[\"$\",\"blockquote\",null,{\"className\":\"mdx-components_blockquote__CXIKy\",\"children\":[\"\\n\",[\"$\",\"div\",null,{\"className\":\"mdx-components_paragraph__AUxxF\",\"children\":\"Simply, it is possible to make a POST request idempotent by including a unique identifier in the request body or header, which can be used to identify and prevent duplicate requests.\"}],\"\\n\",[\"$\",\"div\",null,{\"className\":\"mdx-components_paragraph__AUxxF\",\"children\":\"$c\"}],\"\\n\",[\"$\",\"div\",null,{\"className\":\"mdx-components_paragraph__AUxxF\",\"children\":\"The generally preferred approach is to include a unique caller-supplied client request identifier in the API contract. Requests from the same caller with the same customer request identifier can be considered duplicate requests and handled accordingly. A unique caller-supplied client request identifier for idempotent operations satisfies this need.\"}],\"\\n\"]}],\"\\n\"]}],\"\\n\"]}]],[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/e2-next/_next/static/css/c50e9134a56688df.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\",\"nonce\":\"$undefined\"}]],[\"$\",\"$Ld\",null,{\"children\":\"$Le\"}]]}],{},null,false]},null,false]},null,false]},null,false]},null,false]},null,false],[\"$\",\"$1\",\"h\",{\"children\":[null,[\"$\",\"$1\",\"re91-Tw6zLEwaZAGJCK9M\",{\"children\":[[\"$\",\"$Lf\",null,{\"children\":\"$L10\"}],[\"$\",\"$L11\",null,{\"children\":\"$L12\"}],null]}]]}],false]],\"m\":\"$undefined\",\"G\":[\"$13\",\"$undefined\"],\"s\":false,\"S\":true}\n"])</script><script>self.__next_f.push([1,"b:{}\n"])</script><script>self.__next_f.push([1,"12:[[\"$\",\"meta\",\"0\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}]]\n10:[[\"$\",\"meta\",\"0\",{\"charSet\":\"utf-8\"}],[\"$\",\"title\",\"1\",{\"children\":\"Blog posts\"}],[\"$\",\"meta\",\"2\",{\"name\":\"description\",\"content\":\"Powered by Next.js and React\"}],[\"$\",\"link\",\"3\",{\"rel\":\"icon\",\"href\":\"/e2-next/favicon.ico\",\"type\":\"image/x-icon\",\"sizes\":\"48x48\"}]]\n"])</script><script>self.__next_f.push([1,"e:null\n"])</script></body></html>