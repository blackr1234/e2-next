1:"$Sreact.fragment"
2:I[8287,["7829","static/chunks/7829-b7b9eb1dbe0d40e4.js","2153","static/chunks/2153-45fd9844831c6348.js","7177","static/chunks/app/layout-ea91c2d128ec48c2.js"],"default"]
3:I[3339,["7829","static/chunks/7829-b7b9eb1dbe0d40e4.js","8974","static/chunks/app/page-c8b940db14fac9a0.js"],"default"]
4:I[1367,["7829","static/chunks/7829-b7b9eb1dbe0d40e4.js","2153","static/chunks/2153-45fd9844831c6348.js","7177","static/chunks/app/layout-ea91c2d128ec48c2.js"],"default"]
5:I[5244,[],""]
6:I[3866,[],""]
7:I[4798,["7829","static/chunks/7829-b7b9eb1dbe0d40e4.js","8974","static/chunks/app/page-c8b940db14fac9a0.js"],"default"]
8:I[6121,["7829","static/chunks/7829-b7b9eb1dbe0d40e4.js","8974","static/chunks/app/page-c8b940db14fac9a0.js"],"default"]
9:I[3667,["7829","static/chunks/7829-b7b9eb1dbe0d40e4.js","8974","static/chunks/app/page-c8b940db14fac9a0.js"],"default"]
a:I[8407,["7829","static/chunks/7829-b7b9eb1dbe0d40e4.js","2153","static/chunks/2153-45fd9844831c6348.js","7177","static/chunks/app/layout-ea91c2d128ec48c2.js"],"default"]
b:I[8173,["7829","static/chunks/7829-b7b9eb1dbe0d40e4.js","8974","static/chunks/app/page-c8b940db14fac9a0.js"],""]
c:I[3197,["7829","static/chunks/7829-b7b9eb1dbe0d40e4.js","2153","static/chunks/2153-45fd9844831c6348.js","7177","static/chunks/app/layout-ea91c2d128ec48c2.js"],"default"]
d:I[7933,["7829","static/chunks/7829-b7b9eb1dbe0d40e4.js","2153","static/chunks/2153-45fd9844831c6348.js","7177","static/chunks/app/layout-ea91c2d128ec48c2.js"],"default"]
e:I[3800,["7829","static/chunks/7829-b7b9eb1dbe0d40e4.js","2153","static/chunks/2153-45fd9844831c6348.js","7177","static/chunks/app/layout-ea91c2d128ec48c2.js"],"default"]
10:I[6213,[],"OutletBoundary"]
12:I[6213,[],"MetadataBoundary"]
14:I[6213,[],"ViewportBoundary"]
16:I[4835,[],""]
:HL["/e2-next/_next/static/css/d3df112486f97f47.css","style"]
:HL["/e2-next/_next/static/css/c3624a693ae5a0c4.css","style"]
f:T42c,public final class TypeUtils {

    private TypeUtils() {}

    public static List<String> getGenericTypeNames(Class<?> clazz) {

        if (!(clazz.getGenericSuperclass() instanceof ParameterizedType)) {
            return Collections.emptyList();
        }

        return Arrays
                .stream(((ParameterizedType) clazz.getGenericSuperclass()).getActualTypeArguments())
                .map(Type::getTypeName)
                .collect(Collectors.toList());
    }

    public static List<Class<?>> getGenericTypes(Class<?> clazz) {
        return getGenericTypeNames(clazz).stream()
                .map(e -> e.replaceAll("<.*?>", ""))
                .map(e -> {
                    try {
                        return Class.forName(e);
                    } catch (Exception ex) {
                        ex.printStackTrace(); // handle exception
                        return null;
                    }
                })
                .filter(Objects::nonNull)
                .collect(Collectors.toList());
    }
}
0:{"P":null,"b":"wfZ4FdS4ntgGvzjeKJhfw","p":"/e2-next","c":["","blog","java-collections-generic-type-covariance"],"i":false,"f":[[["",{"children":["blog",{"children":["(2021-06)",{"children":["java-collections-generic-type-covariance",{"children":["__PAGE__",{}]}]}]}]},"$undefined","$undefined",true],["",["$","$1","c",{"children":[[["$","link","0",{"rel":"stylesheet","href":"/e2-next/_next/static/css/d3df112486f97f47.css","precedence":"next","crossOrigin":"$undefined","nonce":"$undefined"}],["$","link","1",{"rel":"stylesheet","href":"/e2-next/_next/static/css/c3624a693ae5a0c4.css","precedence":"next","crossOrigin":"$undefined","nonce":"$undefined"}]],["$","html",null,{"lang":"en","children":[["$","head",null,{"children":[["$","link",null,{"href":"https://fonts.googleapis.com/css2?family=Roboto:ital,wght@0,100;0,300;0,400;0,500;0,700;0,900;1,100;1,300;1,400;1,500;1,700;1,900&display=swap","rel":"stylesheet"}],["$","link",null,{"rel":"stylesheet","href":"https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.6.0/css/all.min.css"}]]}],["$","body",null,{"children":["$","$L2",null,{"children":["$","$L3",null,{"gap":5,"children":[["$","$L3",null,{"gap":5,"className":"text-center","children":[["$","div",null,{"children":[["$","code",null,{"className":"SiteHeader_name__cwQmL","children":"Chung Cheuk Hang Michael"}],["$","code",null,{"className":"SiteHeader_title__CCfvI","children":"Java Web Developer"}]]}],["$","$L4",null,{}]]}],["$","$L5",null,{"parallelRouterKey":"children","segmentPath":["children"],"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L6",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":[[],[["$","title",null,{"children":"404: This page could not be found."}],["$","div",null,{"style":{"fontFamily":"system-ui,\"Segoe UI\",Roboto,Helvetica,Arial,sans-serif,\"Apple Color Emoji\",\"Segoe UI Emoji\"","height":"100vh","textAlign":"center","display":"flex","flexDirection":"column","alignItems":"center","justifyContent":"center"},"children":["$","div",null,{"children":[["$","style",null,{"dangerouslySetInnerHTML":{"__html":"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}"}}],["$","h1",null,{"className":"next-error-h1","style":{"display":"inline-block","margin":"0 20px 0 0","padding":"0 23px 0 0","fontSize":24,"fontWeight":500,"verticalAlign":"top","lineHeight":"49px"},"children":404}],["$","div",null,{"style":{"display":"inline-block"},"children":["$","h2",null,{"style":{"fontSize":14,"fontWeight":400,"lineHeight":"49px","margin":0},"children":"This page could not be found."}]}]]}]}]]],"forbidden":"$undefined","unauthorized":"$undefined"}],["$","hr",null,{}],["$","$L3",null,{"gap":3,"children":["$","$L7",null,{"className":"text-center","children":["$","$L8",null,{"xs":1,"sm":2,"md":3,"className":"justify-content-center g-3","children":[["$","$L9","0",{"children":["$","$La",null,{"as":"$b","href":"tel:+85263301333","target":"_blank","rel":"external nofollow noopener noreferrer","className":"SiteFooter_contact-item__2JRRr","children":["$","$Lc",null,{"children":[["$","$Ld",null,{"children":["$","i",null,{"className":"fa-solid fa-phone","style":{"color":"#009688"}}]}],["$","$Le",null,{"className":"text-muted","children":["6330 1333"," "]}]]}]}]}],["$","$L9","1",{"children":["$","$La",null,{"as":"$b","href":"mailto:michaelboyboy@gmail.com","target":"_blank","rel":"external nofollow noopener noreferrer","className":"SiteFooter_contact-item__2JRRr","children":["$","$Lc",null,{"children":[["$","$Ld",null,{"children":["$","i",null,{"className":"fa-solid fa-envelope","style":{"color":"#f44336"}}]}],["$","$Le",null,{"className":"text-muted","children":["michaelboyboy@gmail.com"," "]}]]}]}]}],["$","$L9","2",{"children":["$","$La",null,{"as":"$b","href":"https://www.linkedin.com/in/mickchung","target":"_blank","rel":"external nofollow noopener noreferrer","className":"SiteFooter_contact-item__2JRRr","children":["$","$Lc",null,{"children":[["$","$Ld",null,{"children":["$","i",null,{"className":"fa-brands fa-linkedin","style":{"color":"#2196f3"}}]}],["$","$Le",null,{"className":"text-muted","children":["www.linkedin.com/in/mickchung"," "]}]]}]}]}]]}]}]}]]}]}]}]]}]]}],{"children":["blog",["$","$1","c",{"children":[null,["$","$L5",null,{"parallelRouterKey":"children","segmentPath":["children","blog","children"],"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L6",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","forbidden":"$undefined","unauthorized":"$undefined"}]]}],{"children":["(2021-06)",["$","$1","c",{"children":[null,["$","$L5",null,{"parallelRouterKey":"children","segmentPath":["children","blog","children","(2021-06)","children"],"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L6",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","forbidden":"$undefined","unauthorized":"$undefined"}]]}],{"children":["java-collections-generic-type-covariance",["$","$1","c",{"children":[null,["$","$L5",null,{"parallelRouterKey":"children","segmentPath":["children","blog","children","(2021-06)","children","java-collections-generic-type-covariance","children"],"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L6",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","forbidden":"$undefined","unauthorized":"$undefined"}]]}],{"children":["__PAGE__",["$","$1","c",{"children":[[["$","h1",null,{"children":"1 重溫 Java collections"}],"\n",["$","p",null,{"children":["如果想重溫返關於 Java ",["$","code",null,{"children":"Collection"}]," 既 ",["$","code",null,{"children":"List"}],"、",["$","code",null,{"children":"Set"}]," subinterfaces 以及 ",["$","code",null,{"children":"Map"}],"，可以睇返呢篇：",["$","a",null,{"href":"/blog/coding-java-3#335-array--collection--map","children":"Java 開發筆記（三） - Array / Collection / Map"}],"。"]}],"\n",["$","p",null,{"children":[["$","code",null,{"children":"List"}],"："]}],"\n",["$","pre",null,{"children":["$","code",null,{"className":"language-java","children":"List<String> names = new ArrayList<>();\r\nnames.add(\"Michael\");\r\nnames.add(\"Peter\");\r\nnames.add(\"Peter\");\r\nSystem.out.println(names); // [Michael, Peter, Peter]\n"}]}],"\n",["$","p",null,{"children":["解釋：",["$","code",null,{"children":"List"}]," 支持重複既 elements。"]}],"\n",["$","p",null,{"children":[["$","code",null,{"children":"Set"}],"："]}],"\n",["$","pre",null,{"children":["$","code",null,{"className":"language-java","children":"Set<String> names = new HashSet<>();\r\nnames.add(\"Michael\");\r\nnames.add(\"Peter\");\r\nnames.add(\"Peter\");\r\nSystem.out.println(names); // [Michael, Peter]\n"}]}],"\n",["$","p",null,{"children":["解釋：",["$","code",null,{"children":"Set"}]," 裡面既 elements 都係獨一無二，唔會重複。如果 ",["$","code",null,{"children":"Set"}]," 既 generic type 係自定義既 class，咁建議喺自定義既 class 裡面再定義 ",["$","code",null,{"children":"equals(obj)"}]," 同 ",["$","code",null,{"children":"hashCode()"}]," 既邏輯，畀 ",["$","code",null,{"children":"Set"}]," 判決呢個自定義既 class 既唔同既 objects 係咪重複。"]}],"\n",["$","p",null,{"children":[["$","code",null,{"children":"Map"}],"："]}],"\n",["$","pre",null,{"children":["$","code",null,{"className":"language-java","children":"Map<String, Integer> nameAgeMap = new HashMap<>();\r\nnameAgeMap.put(\"Alice\", 15);\r\nnameAgeMap.put(\"Bob\", 24);\r\nnameAgeMap.put(\"Alice\", 22);\r\nSystem.out.println(nameAgeMap); // {Bob=24, Alice=22}\n"}]}],"\n",["$","p",null,{"children":["解釋：",["$","code",null,{"children":"Map"}]," 既 keys 都係獨一無二，唔會重複，一般情況都會用 Java 內建既 primitive wrapper classes 或者 ",["$","code",null,{"children":"String"}]," 作為 key 既 generic type，而 value 就更可以用自定義既 class 做 generic type。"]}],"\n",["$","hr",null,{}],"\n",["$","h1",null,{"children":"2 介紹 Java generic type"}],"\n",["$","p",null,{"children":["上面既 ",["$","code",null,{"children":"List"}],"、",["$","code",null,{"children":"Set"}],"、",["$","code",null,{"children":"Map"}]," 例子裡面，我地都見到佢地有個 diamond operator ",["$","code",null,{"children":"<>"}],"，而裡面有一個 type，我地會叫 ",["$","code",null,{"children":"<T>"}]," 裡面既 type 做 generic type，咁 ",["$","code",null,{"children":"Clazz<T>"}]," 成個夾埋係表達緊 class of type，例如 ",["$","code",null,{"children":"List<String>"}]," 解 ",["$","code",null,{"children":"List"}]," of ",["$","code",null,{"children":"String"}],"，因為已經 substitute 左 ",["$","code",null,{"children":"String"}]," 落 ",["$","code",null,{"children":"List<T>"}]," 既 ",["$","code",null,{"children":"T"}],"，所以 ",["$","code",null,{"children":"List<String>"}]," 喺呢個情況就係一個 parameterized type。"]}],"\n",["$","p",null,{"children":["Generic type 係 Java 5 加入既功能，compiler 會喺 compile time 既時候幫我 check 啲 code 寫得合唔合理，係 for type safety 既用途。例如，明明我地 declare 既係 ",["$","code",null,{"children":"List<String> list"}],"，但我地又 call ",["$","code",null,{"children":"list.add(1)"}],"，咁就好唔合理，而 compiler 就會喺 compile time 出 error，示意我地要睇下有冇寫錯 code。不過呢個功能只會應用喺 compile time，runtime 係發揮唔到任何作用，因為有 type erasure。"]}],"\n",["$","p",null,{"children":["因為 Java 既新版都會支持返舊式既 syntax，所以就算唔寫 ",["$","code",null,{"children":"<Type>"}]," 都唔會引致 compilation error。即係咁樣寫都冇問題："]}],"\n",["$","pre",null,{"children":["$","code",null,{"className":"language-java","children":"List rawList = new ArrayList();\r\nSet rawSet = new HashSet();\r\nMap rawMap = new HashMap();\n"}]}],"\n",["$","p",null,{"children":["呢啲冇畀 generic type 既 objects 既 class 我地會叫做 ",["$","a",null,{"href":"https://docs.oracle.com/javase/tutorial/java/generics/rawTypes.html","children":"raw type"}],"。"]}],"\n",["$","p",null,{"children":"有啲 IDE 例如 Eclipse 默認既設定下會顯示黃線 warning，提示 raw type 係舊式寫法，應該跟足新式寫法，令我地既 code 更 strongly typed。"}],"\n",["$","p",null,{"children":"以下係複雜少少，牽涉 subclass："}],"\n",["$","pre",null,{"children":["$","code",null,{"className":"language-java","children":"List<Number> nums = new ArrayList<>();\r\nnums.add(1); // 1 係 int，會被 autobox 成 Integer object\r\nnums.add(1L); // 1 係 long，會被 autobox 成 Long object\r\nnums.add(1.5F); // 1.5F 係 float，會被 autobox 成 Float object\r\nnums.add(1.5D); // 1.5D 係 double，會被 autobox 成 Double object\n"}]}],"\n",["$","p",null,{"children":["解釋：",["$","code",null,{"children":"List<Number>"}]," 可以 ",["$","code",null,{"children":"add()"}]," 既 argument 可以係任何 ",["$","code",null,{"children":"extends Number"}]," 既 object。"]}],"\n",["$","p",null,{"children":"但咁樣寫會有 compilation error："}],"\n",["$","pre",null,{"children":["$","code",null,{"className":"language-java","children":"List<Number> nums = new ArrayList<>();\r\nnums = new ArrayList<Integer>(); // compilation error\r\nnums = new ArrayList<Long>(); // compilation error\r\nnums = new ArrayList<Float>(); // compilation error\r\nnums = new ArrayList<Double>(); // compilation error\n"}]}],"\n",["$","p",null,{"children":["解釋：",["$","code",null,{"children":"List<Number>"}]," 既 variable 只限 assign 返 ",["$","code",null,{"children":"List<Number>"}]," 既 object。"]}],"\n",["$","p",null,{"children":"但如果換成咁樣寫，反而就冇 compilation error（Java 8+）："}],"\n",["$","pre",null,{"children":["$","code",null,{"className":"language-java","children":"public static void main(String[] args) throws Exception {\r\n\r\n    List<Number> nums = new ArrayList<>();\r\n\r\n    // 下面既 createList(T...) 同用 Arrays.asList(T...) 一樣\r\n    nums = createList(); // List<Number>\r\n    nums = createList(1, 2); // List<Integer>\r\n    nums = createList(1L, 2L); // List<Long>\r\n    nums = createList(1.5F, 2.5F); // List<Float>\r\n    nums = createList(1.5D, 2.5D); // List<Double>\r\n}\r\n\r\nprivate static <T> List<T> createList(T... nums) {\r\n    final List list = Arrays.asList(nums);\r\n    return list;\r\n}\n"}]}],"\n",["$","p",null,{"children":["解釋：",["$","code",null,{"children":"createList(T...)"}]," 或者 ",["$","code",null,{"children":"Arrays.asList(T...)"}]," 做緊既野一樣，都係根據傳入既 ",["$","code",null,{"children":"T..."}]," varargs 既 ",["$","code",null,{"children":"T"}]," 去 infer return type ",["$","code",null,{"children":"List<T>"}]," 裡面既 ",["$","code",null,{"children":"T"}],"。然後我地將 ",["$","code",null,{"children":"createList(T...)"}]," 既 result assign 落 ",["$","code",null,{"children":"List<Number>"}]," 度。就咁睇好似同上面出 error 既例子一樣，但其實情況有啲唔同，因為 Java 8+ 會睇埋 assignment 既被 assign 果邊（即係左手邊既 ",["$","code",null,{"children":"nums"}],"）既 type，再去決定右手邊既 type，而呢個情況下句 ",["$","code",null,{"children":"createList(T...)"}]," expression 就係 poly expression，出現左喺一個 poly context 裡面。類似既做法有 Java 7 既 type inference，例如 ",["$","code",null,{"children":"List<String> list = new ArrayList<>()"}]," 既 ",["$","code",null,{"children":"<>"}]," 唔洗寫 ",["$","code",null,{"children":"<String>"}]," 係因為 compiler 知道呢個係 poly expression，就會睇埋 assignment 既 context，會睇被 assign 果邊去決定 ",["$","code",null,{"children":"<>"}]," 裡面係咩 type。相反，standalone expression 就唔會理個 context。"]}],"\n",["$","h2",null,{"children":"2.1 Type erasure"}],"\n",["$","p",null,{"children":"其實 Java 既 generic type 只不過係 for compile time 既 type safety 用，而去到 runtime（個 JVM 幫你執行緊你啲 code）既時候，所有 type information 就會冇曬。"}],"\n",["$","p",null,{"children":["呢個亦係點解我地寫 utility methods 既時候，係冇得寫 ",["$","code",null,{"children":"T.class"}]," 或者用 reflection 既方法黎 reference 返一個 parameterized type 既 ",["$","code",null,{"children":"<T>"}]," 裡面既 ",["$","code",null,{"children":"T"}]," 喺 runtime 既 value，而一定要用一個 parameter ",["$","code",null,{"children":"Class<?> type"}]," 既 variable 先可以知道係咩 type。"]}],"\n",["$","pre",null,{"children":["$","code",null,{"className":"language-java","children":"public static <T> void foo(T obj) {\r\n    // 唔知 T 係咩黎，冇得用 T.class 或者 T.newInstance()\r\n}\n"}]}],"\n",["$","p",null,{"children":"要改成："}],"\n",["$","pre",null,{"children":["$","code",null,{"className":"language-java","children":"public static <T> void foo(T obj, Class<T> type) {\r\n    T newObj = type.newInstance();\r\n    System.out.println(type);\r\n}\n"}]}],"\n",["$","p",null,{"children":"只要唔係 unbounded wildcard 既 parameterized type，都係 non-reifiable type，type information 都會喺 runtime 度 lost 左。"}],"\n",["$","blockquote",null,{"children":["\n",["$","p",null,{"children":"A reifiable type is a type whose type information is fully available at runtime. This includes primitives, non-generic types, raw types, and invocations of unbound wildcards."}],"\n",["$","p",null,{"children":["Non-reifiable types are types where information has been removed at compile-time by type erasure — invocations of generic types that are not defined as unbounded wildcards. A non-reifiable type does not have all of its information available at runtime. Examples of non-reifiable types are ",["$","code",null,{"children":"List<String>"}]," and ",["$","code",null,{"children":"List<Number>"}],"; the JVM cannot tell the difference between these types at runtime. As shown in Restrictions on Generics, there are certain situations where non-reifiable types cannot be used: in an ",["$","code",null,{"children":"instanceof"}]," expression, for example, or as an element in an array."]}],"\n"]}],"\n",["$","p",null,{"children":"舉個例，即係就算我地咁樣寫，唔單止喺 compile time 冇 error，而到左 runtime 都唔會有任何 exception："}],"\n",["$","pre",null,{"children":["$","code",null,{"className":"language-java","children":"List nums = new ArrayList<Integer>();\r\nnums.add(1);\r\nnums.add(\"Hi\");\r\n\r\nSystem.out.println(nums.get(0)); // 1\r\nSystem.out.println(nums.get(1)); // Hi\n"}]}],"\n",["$","p",null,{"children":"解釋："}],"\n",["$","ul",null,{"children":["\n",["$","li",null,{"children":["上面段 code 冇 compile time exception 好正常，因為 ",["$","code",null,{"children":"List"}]," 係 raw type，而之前已經講過，想要 compiler 幫我地 check type，就要寫埋個 generic type，例如 ",["$","code",null,{"children":"List<String>"}],"；"]}],"\n",["$","li",null,{"children":["而點解上面段 code 喺 runtime 執行 ",["$","code",null,{"children":"add()"}]," 唔同 types 既 objects 都冇任何 exception？咁係因為 type erasure 既關係，就算我地 assign 既 object 係 ",["$","code",null,{"children":"ArrayList<Integer>"}],"，其實呢個 ",["$","code",null,{"children":"<Integer>"}]," 喺 compile 完出黎既 bytecode 裡面係會抹走左，咁 runtime 自然就冇 type information，即係 ",["$","code",null,{"children":"new ArrayList<Integer>()"}]," 到左 runtime 其實同一個冇 generic type 既 ",["$","code",null,{"children":"new ArrayList()"}]," 完全一樣，所以點解話 generics 只會喺 compile time 發揮作用，就係呢個原因。"]}],"\n"]}],"\n",["$","p",null,{"children":["但如果我地將 ",["$","code",null,{"children":"List nums"}]," 改成 ",["$","code",null,{"children":"List<Integer> nums"}],"，",["$","code",null,{"children":"nums.add(\"Hi\")"}]," 就會出 compile time error，咁係因為 compiler 幫我地喺 compile time check 左，",["$","code",null,{"children":"List<Integer>"}]," 係加唔到 ",["$","code",null,{"children":"String"}]," object。"]}],"\n",["$","h3",null,{"children":"2.1.1 Explicit type casting"}],"\n",["$","p",null,{"children":["因為 type erasure 既關係，喺 runtime 既時候如果要用 generic type ",["$","code",null,{"children":"<T>"}]," 黎做 explicit type casting，就唔可以用 ",["$","code",null,{"children":"(T) obj"}]," 既寫法："]}],"\n",["$","pre",null,{"children":["$","code",null,{"className":"language-java","children":"public class Main {\r\n\r\n    public static void main(String[] args) {\r\n        final GenericClass<Integer> list = castToGenericClass(\"123\");\r\n        System.out.println(list.getData() instanceof Integer); // false\r\n        System.out.println(list.getData().getClass()); // ClassCastException\r\n    }\r\n\r\n    private static <T> GenericClass<T> castToGenericClass(Object obj) {\r\n\r\n        final T cast = (T) obj;\r\n\r\n        final GenericClass<T> list = new GenericClass<>();\r\n        list.setData(cast);\r\n\r\n        return list;\r\n    }\r\n}\r\n\r\n@Data\r\nclass GenericClass<T> {\r\n    T data;\r\n}\n"}]}],"\n",["$","p",null,{"children":["應該改為傳入 ",["$","code",null,{"children":"Class<T> clazz"}],"，然後用 ",["$","code",null,{"children":"clazz.cast(obj)"}]," 既方式："]}],"\n",["$","pre",null,{"children":["$","code",null,{"className":"language-java","children":"public class Main {\r\n\r\n    public static void main(String[] args) {\r\n        final GenericClass<String> list = castToGenericClass(\"123\", String.class);\r\n        System.out.println(list.getData().getClass()); // class java.lang.String\r\n\r\n        final GenericClass<Integer> list2 = castToGenericClass(123, Integer.class);\r\n        System.out.println(list2.getData().getClass()); // class java.lang.Integer\r\n    }\r\n\r\n    private static <T> GenericClass<T> castToGenericClass(Object obj, Class<T> clazz) {\r\n\r\n        final T cast = clazz.cast(obj);\r\n\r\n        final GenericClass<T> list = new GenericClass<>();\r\n        list.setData(cast);\r\n\r\n        return list;\r\n    }\r\n}\r\n\r\n@Data\r\nclass GenericClass<T> {\r\n    T data;\r\n}\n"}]}],"\n",["$","p",null,{"children":"參考資料："}],"\n",["$","ul",null,{"children":["\n",["$","li",null,{"children":["$","a",null,{"href":"https://stackoverflow.com/questions/14524751/cast-object-to-generic-type-for-returning","children":"StackOverflow - Cast Object to Generic Type for returning"}]}],"\n"]}],"\n",["$","h3",null,{"children":"2.1.2 Declared type information"}],"\n",["$","p",null,{"children":"如果個 generic type 係喺 class definition 層面，例如以下既例子，咁係可以 reference 到個 type，但一定要係 type declaration 先可以，如果唔係 type declaration 既情況下 invoke generic type，最後都係會令 type information lost 左。"}],"\n",["$","p",null,{"children":"首先我地寫一個 utility class，喺下面既例子會用到："}],"\n",["$","pre",null,{"children":["$","code",null,{"className":"language-java","children":"$f"}]}],"\n",["$","h4",null,{"children":"2.1.2.1 Anonymous class"}],"\n",["$","p",null,{"children":"Anonymous class 係 type declaration，所以可以拎到 parameterized type 裡面既 generic type information 出黎。"}],"\n",["$","pre",null,{"children":["$","code",null,{"className":"language-java","children":"Map raw = new HashMap<Integer, String>() {}; // 注意後面既 {} 令佢成為 anonymous class\r\n\r\nList<String> typeNames = TypeUtils.getGenericTypeNames(raw.getClass());\r\nSystem.out.println(typeNames);\r\n// [java.lang.Integer, java.util.List<java.lang.String>]\r\n\r\nList<Class<?>> types = TypeUtils.getGenericTypes(raw.getClass());\r\nSystem.out.println(types);\r\n// [class java.lang.Integer, interface java.util.List]\n"}]}],"\n",["$","h4",null,{"children":"2.1.2.2 Subclass"}],"\n",["$","p",null,{"children":"Subclass 係 type declaration，所以可以拎到 parameterized type 裡面既 generic type information 出黎。但係如果直接用 superclass invoke generic type，咁就拎唔到 generic type information 出黎。"}],"\n",["$","pre",null,{"children":["$","code",null,{"className":"language-java","children":"public class Main {\r\n\r\n    public static void main(String[] args) {\r\n\r\n        new Sub();\r\n        // [java.lang.String, java.util.List<java.lang.Integer>]\r\n        // [class java.lang.String, interface java.util.List]\r\n\r\n        new Super<Integer, List<String>>();\r\n        // [] 拎唔到\r\n        // [] 拎唔到\r\n    }\r\n}\r\n\r\nclass Super<T1, T2> {\r\n    public Super() {\r\n        System.out.println(TypeUtils.getGenericTypeNames(getClass()));\r\n        System.out.println(TypeUtils.getGenericTypes(getClass()));\r\n    }\r\n}\r\n\r\nclass Sub extends Super<String, List<Integer>> {}\n"}]}],"\n",["$","hr",null,{}],"\n",["$","h2",null,{"children":"2.2 Unbounded wildcard generic type"}],"\n",["$","p",null,{"children":["我地可以用問號 ",["$","code",null,{"children":"?"}]," 黎代表 generic type 係 wildcard type："]}],"\n",["$","pre",null,{"children":["$","code",null,{"className":"language-java","children":"List<?> list = new ArrayList<>();\r\n\r\nlist = Arrays.asList(\"item\");\r\n// wildcard generic type 既 List variable 可以 assign 任何 generic type 既 List object\r\n\r\nlist.add(null);\r\nlist.add(new Object()); // compilation error\r\n// 因為 Java 唔知個 List 係咩 generic type，我地係 add 唔到 element（除左乜野 type 都唔係既 null）\n"}]}],"\n",["$","hr",null,{}],"\n",["$","h2",null,{"children":"2.3 Upper bounded wildcard generic type"}],"\n",["$","pre",null,{"children":["$","code",null,{"className":"language-java","children":"List<? extends Number> nums = new ArrayList<>();\n"}]}],"\n",["$","p",null,{"children":["解釋：呢一個 ",["$","code",null,{"children":"List"}]," 既 variable 只能夠接受 list of ",["$","code",null,{"children":"Number"}]," 或者 list of ",["$","code",null,{"children":"extends Number"}]," 既 class。下面既都可以："]}],"\n",["$","pre",null,{"children":["$","code",null,{"className":"language-java","children":"List<? extends Number> nums;\r\nnums = new ArrayList<Number>();\r\nnums = new ArrayList<Integer>();\r\nnums = new ArrayList<Double>();\n"}]}],"\n",["$","p",null,{"children":["需要注意既係，因為唔知個 ",["$","code",null,{"children":"List"}]," 係幾 specific 既 generic type，",["$","code",null,{"children":"List<? extends Number>"}]," 可以 assign ",["$","code",null,{"children":"List<Number>"}],"、",["$","code",null,{"children":"List<Integer>"}],"，甚至 list of ",["$","code",null,{"children":"Integer"}]," 既 subclass（自定義或者 3rd party library 裡面提供既）既 object，而如果 assign 既係 ",["$","code",null,{"children":"List<Integer>"}]," 既 object，理論上係唔應該畀 ",["$","code",null,{"children":"add()"}]," 一個 ",["$","code",null,{"children":"Integer"}]," 以外既 element，所以 compiler 穩陣起見，就喺 compile time 唔畀我地 ",["$","code",null,{"children":"add()"}]," 任何 element（除左乜野 type 都唔係既 ",["$","code",null,{"children":"null"}],"）："]}],"\n",["$","pre",null,{"children":["$","code",null,{"className":"language-java","children":"List<? extends Number> nums = new ArrayList<>();\r\nnums.add(null);\r\nnums.add(1); // compilation error\n"}]}],"\n",["$","hr",null,{}],"\n",["$","h2",null,{"children":"2.4 Lower bounded wildcard generic type"}],"\n",["$","pre",null,{"children":["$","code",null,{"className":"language-java","children":"List<? super Number> nums = new ArrayList<>();\n"}]}],"\n",["$","p",null,{"children":["解釋：呢一個 ",["$","code",null,{"children":"List"}]," 既 variable 只能夠接受 list of ",["$","code",null,{"children":"Number"}]," 或者 list of ",["$","code",null,{"children":"Number"}]," 既 superclass。下面既都可以："]}],"\n",["$","pre",null,{"children":["$","code",null,{"className":"language-java","children":"List<? super Number> nums;\r\nnums = new ArrayList<Number>();\r\nnums = new ArrayList<Object>();\n"}]}],"\n",["$","p",null,{"children":["需要注意既係，lower bounded wildcard 同 upper bounded wildcard 唔同，因為知道個 ",["$","code",null,{"children":"List"}]," 唔會比 ",["$","code",null,{"children":"List<Number>"}]," 更 specific，可以 assign ",["$","code",null,{"children":"List<Number>"}]," 或者 ",["$","code",null,{"children":"List<Object>"}]," 既 object 都得，如果 assign 既係 ",["$","code",null,{"children":"List<Number>"}]," 既 object，係可以 ",["$","code",null,{"children":"add()"}]," 任何 ",["$","code",null,{"children":"Number"}]," 或者 ",["$","code",null,{"children":"extends Number"}]," 既 object，而如果 assign 既係 ",["$","code",null,{"children":"List<Object>"}]," 既 object 既話更加係 ",["$","code",null,{"children":"add()"}]," 乜野 object 都可以，所以 lower bounded wildcard 係畀我地 ",["$","code",null,{"children":"add()"}]," element，但 ",["$","code",null,{"children":"List<? super Number>"}]," 只限 ",["$","code",null,{"children":"add()"}]," 到 ",["$","code",null,{"children":"Number"}]," 或者 ",["$","code",null,{"children":"extends Number"}]," 既 object，以及乜野 type 都唔係既 ",["$","code",null,{"children":"null"}],"。"]}],"\n",["$","p",null,{"children":"咁樣寫係冇問題："}],"\n",["$","pre",null,{"children":["$","code",null,{"className":"language-java","children":"List<? super Number> nums = new ArrayList<>();\r\nnums.add(null);\r\nnums.add(new Number() { /* add unimplemented methods */ }); // anonymous class\r\nnums.add(1);\r\nnums.add(1.5D);\n"}]}],"\n",["$","hr",null,{}],"\n",["$","h1",null,{"children":"3 Covariance 問題"}],"\n",["$","p",null,{"children":["因為 generic type 可以有繼承，即係我地可以寫 ",["$","code",null,{"children":"class Sub extends Super"}],"，咁即係話我地可以有 ",["$","code",null,{"children":"List<Super>"}]," 同 ",["$","code",null,{"children":"List<Sub>"}],"，咁到底兩者既 variables 同 objects 係咪互相相容（in terms of polymorphism）？呢個就係 covariance 問題。"]}],"\n",["$","p",null,{"children":["註：除左 ",["$","code",null,{"children":"extends"}],"，covariance 既規則對 ",["$","code",null,{"children":"implements"}],"（interface）都一樣適用。"]}],"\n",["$","hr",null,{}],"\n",["$","h1",null,{"children":"4 Covariance 規則"}],"\n",["$","p",null,{"children":["到底 ",["$","code",null,{"children":"Clazz<T>"}]," 可以 assign 返乜野 type 既 object？"]}],"\n",["$","p",null,{"children":"假設我地有以下既自定義 classes："}],"\n",["$","pre",null,{"children":["$","code",null,{"className":"language-java","children":"class Wrapper<T> {\r\n    public void foo(T obj) {}\r\n}\r\nclass SubWrapper<T> extends Wrapper<T> {}\r\n\r\nclass Super {}\r\nclass Sub extends Super {}\n"}]}],"\n",["$","p",null,{"children":["如果係特定 generic type，例如 ",["$","code",null,{"children":"Wrapper<Super>"}],"，特定左 generic type 係 ",["$","code",null,{"children":"Super"}],"，咁只能 assign 同樣特定 generic type 既 ",["$","code",null,{"children":"Wrapper"}]," 或者 ",["$","code",null,{"children":"Wrapper"}]," 既 subclass 既 object："]}],"\n",["$","pre",null,{"children":["$","code",null,{"className":"language-java","children":"Wrapper<Super> wrapper;\r\nwrapper = new Wrapper<Super>();\r\nwrapper = new SubWrapper<Super>();\r\n\r\nwrapper.foo(null);\r\nwrapper.foo(new Super());\r\nwrapper.foo(new Sub());\r\n\r\n// 唔可以用特定 generic type 既 subclass 做個 generic type\r\nwrapper = new Wrapper<Sub>(); // compilation error\r\nwrapper = new SubWrapper<Sub>(); // compilation error\n"}]}],"\n",["$","p",null,{"children":["如果係 upper bounded wildcard，例如 ",["$","code",null,{"children":"Wrapper<? extends Super>"}],"，咁可以 assign 相同既 generic type 或者佢既 subclass 既 ",["$","code",null,{"children":"Wrapper"}]," 或者 ",["$","code",null,{"children":"Wrapper"}]," 既 subclass 既 object："]}],"\n",["$","pre",null,{"children":["$","code",null,{"className":"language-java","children":"Wrapper<? extends Super> wrapper;\r\nwrapper = new Wrapper<Super>();\r\nwrapper = new SubWrapper<Super>();\r\nwrapper = new Wrapper<Sub>();\r\nwrapper = new SubWrapper<Sub>();\r\n\r\nwrapper.foo(null);\r\n\r\n// 唔可以 call 任何 parameter 有 T 既 method\r\nwrapper.foo(new Super()); // compilation error\r\nwrapper.foo(new Sub()); // compilation error\n"}]}],"\n",["$","p",null,{"children":["如果係 lower bounded wildcard，例如 ",["$","code",null,{"children":"Wrapper<? super Super>"}],"，咁可以 assign 相同既 generic type 或者佢既 superclass 既 ",["$","code",null,{"children":"Wrapper"}]," 或者 ",["$","code",null,{"children":"Wrapper"}]," 既 subclass 既 object："]}],"\n",["$","pre",null,{"children":["$","code",null,{"className":"language-java","children":"Wrapper<? super Super> wrapper;\r\nwrapper = new Wrapper<Super>();\r\nwrapper = new SubWrapper<Super>();\r\nwrapper = new Wrapper<Object>();\r\nwrapper = new SubWrapper<Object>();\r\n\r\nwrapper.foo(null);\r\nwrapper.foo(new Super());\r\nwrapper.foo(new Sub());\n"}]}],"\n",["$","p",null,{"children":["如果係 wildcard，例如 ",["$","code",null,{"children":"Wrapper<?>"}],"，咁可以 assign 任何 generic type 既 ",["$","code",null,{"children":"Wrapper"}]," 或者 ",["$","code",null,{"children":"Wrapper"}]," 既 subclass 既 object："]}],"\n",["$","pre",null,{"children":["$","code",null,{"className":"language-java","children":"Wrapper<?> wrapper;\r\nwrapper = new Wrapper<Super>();\r\nwrapper = new SubWrapper<Super>();\r\nwrapper = new Wrapper<Sub>();\r\nwrapper = new SubWrapper<Sub>();\r\nwrapper = new Wrapper<Object>();\r\nwrapper = new SubWrapper<Object>();\r\n\r\nwrapper.foo(null);\r\n\r\n// 唔可以 call 任何 parameter 有 T 既 method\r\nwrapper.foo(new Super()); // compilation error\r\nwrapper.foo(new Sub()); // compilation error\r\nwrapper.foo(new Object()); // compilation error\n"}]}]],null,["$","$L10",null,{"children":"$L11"}]]}],{},null,false]},null,false]},null,false]},null,false]},null,false],["$","$1","h",{"children":[null,["$","$1","6E8OPlldIxe6RDx6GaAi9",{"children":[["$","$L12",null,{"children":"$L13"}],["$","$L14",null,{"children":"$L15"}],null]}]]}],false]],"m":"$undefined","G":["$16","$undefined"],"s":false,"S":true}
15:[["$","meta","0",{"name":"viewport","content":"width=device-width, initial-scale=1"}]]
13:[["$","meta","0",{"charSet":"utf-8"}],["$","title","1",{"children":"Michael Chung's e-Portfolio"}],["$","meta","2",{"name":"description","content":"Powered by Next.js and React"}]]
11:null
