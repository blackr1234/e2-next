<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="stylesheet" href="/e2-next/_next/static/css/d3df112486f97f47.css" data-precedence="next"/><link rel="stylesheet" href="/e2-next/_next/static/css/c3624a693ae5a0c4.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/e2-next/_next/static/chunks/webpack-f088da4552bcc253.js"/><script src="/e2-next/_next/static/chunks/4bd1b696-120f4d9c40d223dd.js" async=""></script><script src="/e2-next/_next/static/chunks/1517-c8d232d43a11224c.js" async=""></script><script src="/e2-next/_next/static/chunks/main-app-05c45cc8f30d6cea.js" async=""></script><script src="/e2-next/_next/static/chunks/7829-b7b9eb1dbe0d40e4.js" async=""></script><script src="/e2-next/_next/static/chunks/2153-45fd9844831c6348.js" async=""></script><script src="/e2-next/_next/static/chunks/app/layout-ea91c2d128ec48c2.js" async=""></script><script src="/e2-next/_next/static/chunks/app/page-c8b940db14fac9a0.js" async=""></script><title>Michael Chung&#x27;s e-Portfolio</title><meta name="description" content="Powered by Next.js and React"/><link href="https://fonts.googleapis.com/css2?family=Roboto:ital,wght@0,100;0,300;0,400;0,500;0,700;0,900;1,100;1,300;1,400;1,500;1,700;1,900&amp;display=swap" rel="stylesheet"/><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.6.0/css/all.min.css"/><script src="/e2-next/_next/static/chunks/polyfills-42372ed130431b0a.js" noModule=""></script></head><body><div class="vstack gap-5"><div class="text-center vstack gap-5"><div><code class="SiteHeader_name__cwQmL">Chung Cheuk Hang Michael</code><code class="SiteHeader_title__CCfvI">Java Web Developer</code></div><nav class="justify-content-center navbar navbar-expand-md navbar-dark"><button type="button" aria-label="Toggle navigation" class="navbar-toggler collapsed"><span class="navbar-toggler-icon"></span></button><div class="justify-content-center navbar-collapse collapse"><div class="justify-content-center navbar-nav nav-underline"><div class="nav-item"><a draggable="false" data-rr-ui-event-key="/" class="nav-link" href="/e2-next">Home</a></div><div class="nav-item"><a draggable="false" data-rr-ui-event-key="/work" class="nav-link" href="/e2-next/work">Work</a></div><div class="nav-item"><a draggable="false" data-rr-ui-event-key="/hobbyProjects" class="nav-link" href="/e2-next/hobbyProjects">Hobby projects</a></div><div class="nav-item"><a draggable="false" data-rr-ui-event-key="/personality" class="nav-link" href="/e2-next/personality">Personality</a></div><div class="nav-item"><a draggable="false" data-rr-ui-event-key="/blog" class="nav-link" href="/e2-next/blog">Blog</a></div></div></div></nav></div><h1>1 重溫 Java collections</h1>
<p>如果想重溫返關於 Java <code>Collection</code> 既 <code>List</code>、<code>Set</code> subinterfaces 以及 <code>Map</code>，可以睇返呢篇：<a href="/blog/coding-java-3#335-array--collection--map">Java 開發筆記（三） - Array / Collection / Map</a>。</p>
<p><code>List</code>：</p>
<pre><code class="language-java">List&lt;String&gt; names = new ArrayList&lt;&gt;();
names.add(&quot;Michael&quot;);
names.add(&quot;Peter&quot;);
names.add(&quot;Peter&quot;);
System.out.println(names); // [Michael, Peter, Peter]
</code></pre>
<p>解釋：<code>List</code> 支持重複既 elements。</p>
<p><code>Set</code>：</p>
<pre><code class="language-java">Set&lt;String&gt; names = new HashSet&lt;&gt;();
names.add(&quot;Michael&quot;);
names.add(&quot;Peter&quot;);
names.add(&quot;Peter&quot;);
System.out.println(names); // [Michael, Peter]
</code></pre>
<p>解釋：<code>Set</code> 裡面既 elements 都係獨一無二，唔會重複。如果 <code>Set</code> 既 generic type 係自定義既 class，咁建議喺自定義既 class 裡面再定義 <code>equals(obj)</code> 同 <code>hashCode()</code> 既邏輯，畀 <code>Set</code> 判決呢個自定義既 class 既唔同既 objects 係咪重複。</p>
<p><code>Map</code>：</p>
<pre><code class="language-java">Map&lt;String, Integer&gt; nameAgeMap = new HashMap&lt;&gt;();
nameAgeMap.put(&quot;Alice&quot;, 15);
nameAgeMap.put(&quot;Bob&quot;, 24);
nameAgeMap.put(&quot;Alice&quot;, 22);
System.out.println(nameAgeMap); // {Bob=24, Alice=22}
</code></pre>
<p>解釋：<code>Map</code> 既 keys 都係獨一無二，唔會重複，一般情況都會用 Java 內建既 primitive wrapper classes 或者 <code>String</code> 作為 key 既 generic type，而 value 就更可以用自定義既 class 做 generic type。</p>
<hr/>
<h1>2 介紹 Java generic type</h1>
<p>上面既 <code>List</code>、<code>Set</code>、<code>Map</code> 例子裡面，我地都見到佢地有個 diamond operator <code>&lt;&gt;</code>，而裡面有一個 type，我地會叫 <code>&lt;T&gt;</code> 裡面既 type 做 generic type，咁 <code>Clazz&lt;T&gt;</code> 成個夾埋係表達緊 class of type，例如 <code>List&lt;String&gt;</code> 解 <code>List</code> of <code>String</code>，因為已經 substitute 左 <code>String</code> 落 <code>List&lt;T&gt;</code> 既 <code>T</code>，所以 <code>List&lt;String&gt;</code> 喺呢個情況就係一個 parameterized type。</p>
<p>Generic type 係 Java 5 加入既功能，compiler 會喺 compile time 既時候幫我 check 啲 code 寫得合唔合理，係 for type safety 既用途。例如，明明我地 declare 既係 <code>List&lt;String&gt; list</code>，但我地又 call <code>list.add(1)</code>，咁就好唔合理，而 compiler 就會喺 compile time 出 error，示意我地要睇下有冇寫錯 code。不過呢個功能只會應用喺 compile time，runtime 係發揮唔到任何作用，因為有 type erasure。</p>
<p>因為 Java 既新版都會支持返舊式既 syntax，所以就算唔寫 <code>&lt;Type&gt;</code> 都唔會引致 compilation error。即係咁樣寫都冇問題：</p>
<pre><code class="language-java">List rawList = new ArrayList();
Set rawSet = new HashSet();
Map rawMap = new HashMap();
</code></pre>
<p>呢啲冇畀 generic type 既 objects 既 class 我地會叫做 <a href="https://docs.oracle.com/javase/tutorial/java/generics/rawTypes.html">raw type</a>。</p>
<p>有啲 IDE 例如 Eclipse 默認既設定下會顯示黃線 warning，提示 raw type 係舊式寫法，應該跟足新式寫法，令我地既 code 更 strongly typed。</p>
<p>以下係複雜少少，牽涉 subclass：</p>
<pre><code class="language-java">List&lt;Number&gt; nums = new ArrayList&lt;&gt;();
nums.add(1); // 1 係 int，會被 autobox 成 Integer object
nums.add(1L); // 1 係 long，會被 autobox 成 Long object
nums.add(1.5F); // 1.5F 係 float，會被 autobox 成 Float object
nums.add(1.5D); // 1.5D 係 double，會被 autobox 成 Double object
</code></pre>
<p>解釋：<code>List&lt;Number&gt;</code> 可以 <code>add()</code> 既 argument 可以係任何 <code>extends Number</code> 既 object。</p>
<p>但咁樣寫會有 compilation error：</p>
<pre><code class="language-java">List&lt;Number&gt; nums = new ArrayList&lt;&gt;();
nums = new ArrayList&lt;Integer&gt;(); // compilation error
nums = new ArrayList&lt;Long&gt;(); // compilation error
nums = new ArrayList&lt;Float&gt;(); // compilation error
nums = new ArrayList&lt;Double&gt;(); // compilation error
</code></pre>
<p>解釋：<code>List&lt;Number&gt;</code> 既 variable 只限 assign 返 <code>List&lt;Number&gt;</code> 既 object。</p>
<p>但如果換成咁樣寫，反而就冇 compilation error（Java 8+）：</p>
<pre><code class="language-java">public static void main(String[] args) throws Exception {

    List&lt;Number&gt; nums = new ArrayList&lt;&gt;();

    // 下面既 createList(T...) 同用 Arrays.asList(T...) 一樣
    nums = createList(); // List&lt;Number&gt;
    nums = createList(1, 2); // List&lt;Integer&gt;
    nums = createList(1L, 2L); // List&lt;Long&gt;
    nums = createList(1.5F, 2.5F); // List&lt;Float&gt;
    nums = createList(1.5D, 2.5D); // List&lt;Double&gt;
}

private static &lt;T&gt; List&lt;T&gt; createList(T... nums) {
    final List list = Arrays.asList(nums);
    return list;
}
</code></pre>
<p>解釋：<code>createList(T...)</code> 或者 <code>Arrays.asList(T...)</code> 做緊既野一樣，都係根據傳入既 <code>T...</code> varargs 既 <code>T</code> 去 infer return type <code>List&lt;T&gt;</code> 裡面既 <code>T</code>。然後我地將 <code>createList(T...)</code> 既 result assign 落 <code>List&lt;Number&gt;</code> 度。就咁睇好似同上面出 error 既例子一樣，但其實情況有啲唔同，因為 Java 8+ 會睇埋 assignment 既被 assign 果邊（即係左手邊既 <code>nums</code>）既 type，再去決定右手邊既 type，而呢個情況下句 <code>createList(T...)</code> expression 就係 poly expression，出現左喺一個 poly context 裡面。類似既做法有 Java 7 既 type inference，例如 <code>List&lt;String&gt; list = new ArrayList&lt;&gt;()</code> 既 <code>&lt;&gt;</code> 唔洗寫 <code>&lt;String&gt;</code> 係因為 compiler 知道呢個係 poly expression，就會睇埋 assignment 既 context，會睇被 assign 果邊去決定 <code>&lt;&gt;</code> 裡面係咩 type。相反，standalone expression 就唔會理個 context。</p>
<h2>2.1 Type erasure</h2>
<p>其實 Java 既 generic type 只不過係 for compile time 既 type safety 用，而去到 runtime（個 JVM 幫你執行緊你啲 code）既時候，所有 type information 就會冇曬。</p>
<p>呢個亦係點解我地寫 utility methods 既時候，係冇得寫 <code>T.class</code> 或者用 reflection 既方法黎 reference 返一個 parameterized type 既 <code>&lt;T&gt;</code> 裡面既 <code>T</code> 喺 runtime 既 value，而一定要用一個 parameter <code>Class&lt;?&gt; type</code> 既 variable 先可以知道係咩 type。</p>
<pre><code class="language-java">public static &lt;T&gt; void foo(T obj) {
    // 唔知 T 係咩黎，冇得用 T.class 或者 T.newInstance()
}
</code></pre>
<p>要改成：</p>
<pre><code class="language-java">public static &lt;T&gt; void foo(T obj, Class&lt;T&gt; type) {
    T newObj = type.newInstance();
    System.out.println(type);
}
</code></pre>
<p>只要唔係 unbounded wildcard 既 parameterized type，都係 non-reifiable type，type information 都會喺 runtime 度 lost 左。</p>
<blockquote>
<p>A reifiable type is a type whose type information is fully available at runtime. This includes primitives, non-generic types, raw types, and invocations of unbound wildcards.</p>
<p>Non-reifiable types are types where information has been removed at compile-time by type erasure — invocations of generic types that are not defined as unbounded wildcards. A non-reifiable type does not have all of its information available at runtime. Examples of non-reifiable types are <code>List&lt;String&gt;</code> and <code>List&lt;Number&gt;</code>; the JVM cannot tell the difference between these types at runtime. As shown in Restrictions on Generics, there are certain situations where non-reifiable types cannot be used: in an <code>instanceof</code> expression, for example, or as an element in an array.</p>
</blockquote>
<p>舉個例，即係就算我地咁樣寫，唔單止喺 compile time 冇 error，而到左 runtime 都唔會有任何 exception：</p>
<pre><code class="language-java">List nums = new ArrayList&lt;Integer&gt;();
nums.add(1);
nums.add(&quot;Hi&quot;);

System.out.println(nums.get(0)); // 1
System.out.println(nums.get(1)); // Hi
</code></pre>
<p>解釋：</p>
<ul>
<li>上面段 code 冇 compile time exception 好正常，因為 <code>List</code> 係 raw type，而之前已經講過，想要 compiler 幫我地 check type，就要寫埋個 generic type，例如 <code>List&lt;String&gt;</code>；</li>
<li>而點解上面段 code 喺 runtime 執行 <code>add()</code> 唔同 types 既 objects 都冇任何 exception？咁係因為 type erasure 既關係，就算我地 assign 既 object 係 <code>ArrayList&lt;Integer&gt;</code>，其實呢個 <code>&lt;Integer&gt;</code> 喺 compile 完出黎既 bytecode 裡面係會抹走左，咁 runtime 自然就冇 type information，即係 <code>new ArrayList&lt;Integer&gt;()</code> 到左 runtime 其實同一個冇 generic type 既 <code>new ArrayList()</code> 完全一樣，所以點解話 generics 只會喺 compile time 發揮作用，就係呢個原因。</li>
</ul>
<p>但如果我地將 <code>List nums</code> 改成 <code>List&lt;Integer&gt; nums</code>，<code>nums.add(&quot;Hi&quot;)</code> 就會出 compile time error，咁係因為 compiler 幫我地喺 compile time check 左，<code>List&lt;Integer&gt;</code> 係加唔到 <code>String</code> object。</p>
<h3>2.1.1 Explicit type casting</h3>
<p>因為 type erasure 既關係，喺 runtime 既時候如果要用 generic type <code>&lt;T&gt;</code> 黎做 explicit type casting，就唔可以用 <code>(T) obj</code> 既寫法：</p>
<pre><code class="language-java">public class Main {

    public static void main(String[] args) {
        final GenericClass&lt;Integer&gt; list = castToGenericClass(&quot;123&quot;);
        System.out.println(list.getData() instanceof Integer); // false
        System.out.println(list.getData().getClass()); // ClassCastException
    }

    private static &lt;T&gt; GenericClass&lt;T&gt; castToGenericClass(Object obj) {

        final T cast = (T) obj;

        final GenericClass&lt;T&gt; list = new GenericClass&lt;&gt;();
        list.setData(cast);

        return list;
    }
}

@Data
class GenericClass&lt;T&gt; {
    T data;
}
</code></pre>
<p>應該改為傳入 <code>Class&lt;T&gt; clazz</code>，然後用 <code>clazz.cast(obj)</code> 既方式：</p>
<pre><code class="language-java">public class Main {

    public static void main(String[] args) {
        final GenericClass&lt;String&gt; list = castToGenericClass(&quot;123&quot;, String.class);
        System.out.println(list.getData().getClass()); // class java.lang.String

        final GenericClass&lt;Integer&gt; list2 = castToGenericClass(123, Integer.class);
        System.out.println(list2.getData().getClass()); // class java.lang.Integer
    }

    private static &lt;T&gt; GenericClass&lt;T&gt; castToGenericClass(Object obj, Class&lt;T&gt; clazz) {

        final T cast = clazz.cast(obj);

        final GenericClass&lt;T&gt; list = new GenericClass&lt;&gt;();
        list.setData(cast);

        return list;
    }
}

@Data
class GenericClass&lt;T&gt; {
    T data;
}
</code></pre>
<p>參考資料：</p>
<ul>
<li><a href="https://stackoverflow.com/questions/14524751/cast-object-to-generic-type-for-returning">StackOverflow - Cast Object to Generic Type for returning</a></li>
</ul>
<h3>2.1.2 Declared type information</h3>
<p>如果個 generic type 係喺 class definition 層面，例如以下既例子，咁係可以 reference 到個 type，但一定要係 type declaration 先可以，如果唔係 type declaration 既情況下 invoke generic type，最後都係會令 type information lost 左。</p>
<p>首先我地寫一個 utility class，喺下面既例子會用到：</p>
<pre><code class="language-java">public final class TypeUtils {

    private TypeUtils() {}

    public static List&lt;String&gt; getGenericTypeNames(Class&lt;?&gt; clazz) {

        if (!(clazz.getGenericSuperclass() instanceof ParameterizedType)) {
            return Collections.emptyList();
        }

        return Arrays
                .stream(((ParameterizedType) clazz.getGenericSuperclass()).getActualTypeArguments())
                .map(Type::getTypeName)
                .collect(Collectors.toList());
    }

    public static List&lt;Class&lt;?&gt;&gt; getGenericTypes(Class&lt;?&gt; clazz) {
        return getGenericTypeNames(clazz).stream()
                .map(e -&gt; e.replaceAll(&quot;&lt;.*?&gt;&quot;, &quot;&quot;))
                .map(e -&gt; {
                    try {
                        return Class.forName(e);
                    } catch (Exception ex) {
                        ex.printStackTrace(); // handle exception
                        return null;
                    }
                })
                .filter(Objects::nonNull)
                .collect(Collectors.toList());
    }
}
</code></pre>
<h4>2.1.2.1 Anonymous class</h4>
<p>Anonymous class 係 type declaration，所以可以拎到 parameterized type 裡面既 generic type information 出黎。</p>
<pre><code class="language-java">Map raw = new HashMap&lt;Integer, String&gt;() {}; // 注意後面既 {} 令佢成為 anonymous class

List&lt;String&gt; typeNames = TypeUtils.getGenericTypeNames(raw.getClass());
System.out.println(typeNames);
// [java.lang.Integer, java.util.List&lt;java.lang.String&gt;]

List&lt;Class&lt;?&gt;&gt; types = TypeUtils.getGenericTypes(raw.getClass());
System.out.println(types);
// [class java.lang.Integer, interface java.util.List]
</code></pre>
<h4>2.1.2.2 Subclass</h4>
<p>Subclass 係 type declaration，所以可以拎到 parameterized type 裡面既 generic type information 出黎。但係如果直接用 superclass invoke generic type，咁就拎唔到 generic type information 出黎。</p>
<pre><code class="language-java">public class Main {

    public static void main(String[] args) {

        new Sub();
        // [java.lang.String, java.util.List&lt;java.lang.Integer&gt;]
        // [class java.lang.String, interface java.util.List]

        new Super&lt;Integer, List&lt;String&gt;&gt;();
        // [] 拎唔到
        // [] 拎唔到
    }
}

class Super&lt;T1, T2&gt; {
    public Super() {
        System.out.println(TypeUtils.getGenericTypeNames(getClass()));
        System.out.println(TypeUtils.getGenericTypes(getClass()));
    }
}

class Sub extends Super&lt;String, List&lt;Integer&gt;&gt; {}
</code></pre>
<hr/>
<h2>2.2 Unbounded wildcard generic type</h2>
<p>我地可以用問號 <code>?</code> 黎代表 generic type 係 wildcard type：</p>
<pre><code class="language-java">List&lt;?&gt; list = new ArrayList&lt;&gt;();

list = Arrays.asList(&quot;item&quot;);
// wildcard generic type 既 List variable 可以 assign 任何 generic type 既 List object

list.add(null);
list.add(new Object()); // compilation error
// 因為 Java 唔知個 List 係咩 generic type，我地係 add 唔到 element（除左乜野 type 都唔係既 null）
</code></pre>
<hr/>
<h2>2.3 Upper bounded wildcard generic type</h2>
<pre><code class="language-java">List&lt;? extends Number&gt; nums = new ArrayList&lt;&gt;();
</code></pre>
<p>解釋：呢一個 <code>List</code> 既 variable 只能夠接受 list of <code>Number</code> 或者 list of <code>extends Number</code> 既 class。下面既都可以：</p>
<pre><code class="language-java">List&lt;? extends Number&gt; nums;
nums = new ArrayList&lt;Number&gt;();
nums = new ArrayList&lt;Integer&gt;();
nums = new ArrayList&lt;Double&gt;();
</code></pre>
<p>需要注意既係，因為唔知個 <code>List</code> 係幾 specific 既 generic type，<code>List&lt;? extends Number&gt;</code> 可以 assign <code>List&lt;Number&gt;</code>、<code>List&lt;Integer&gt;</code>，甚至 list of <code>Integer</code> 既 subclass（自定義或者 3rd party library 裡面提供既）既 object，而如果 assign 既係 <code>List&lt;Integer&gt;</code> 既 object，理論上係唔應該畀 <code>add()</code> 一個 <code>Integer</code> 以外既 element，所以 compiler 穩陣起見，就喺 compile time 唔畀我地 <code>add()</code> 任何 element（除左乜野 type 都唔係既 <code>null</code>）：</p>
<pre><code class="language-java">List&lt;? extends Number&gt; nums = new ArrayList&lt;&gt;();
nums.add(null);
nums.add(1); // compilation error
</code></pre>
<hr/>
<h2>2.4 Lower bounded wildcard generic type</h2>
<pre><code class="language-java">List&lt;? super Number&gt; nums = new ArrayList&lt;&gt;();
</code></pre>
<p>解釋：呢一個 <code>List</code> 既 variable 只能夠接受 list of <code>Number</code> 或者 list of <code>Number</code> 既 superclass。下面既都可以：</p>
<pre><code class="language-java">List&lt;? super Number&gt; nums;
nums = new ArrayList&lt;Number&gt;();
nums = new ArrayList&lt;Object&gt;();
</code></pre>
<p>需要注意既係，lower bounded wildcard 同 upper bounded wildcard 唔同，因為知道個 <code>List</code> 唔會比 <code>List&lt;Number&gt;</code> 更 specific，可以 assign <code>List&lt;Number&gt;</code> 或者 <code>List&lt;Object&gt;</code> 既 object 都得，如果 assign 既係 <code>List&lt;Number&gt;</code> 既 object，係可以 <code>add()</code> 任何 <code>Number</code> 或者 <code>extends Number</code> 既 object，而如果 assign 既係 <code>List&lt;Object&gt;</code> 既 object 既話更加係 <code>add()</code> 乜野 object 都可以，所以 lower bounded wildcard 係畀我地 <code>add()</code> element，但 <code>List&lt;? super Number&gt;</code> 只限 <code>add()</code> 到 <code>Number</code> 或者 <code>extends Number</code> 既 object，以及乜野 type 都唔係既 <code>null</code>。</p>
<p>咁樣寫係冇問題：</p>
<pre><code class="language-java">List&lt;? super Number&gt; nums = new ArrayList&lt;&gt;();
nums.add(null);
nums.add(new Number() { /* add unimplemented methods */ }); // anonymous class
nums.add(1);
nums.add(1.5D);
</code></pre>
<hr/>
<h1>3 Covariance 問題</h1>
<p>因為 generic type 可以有繼承，即係我地可以寫 <code>class Sub extends Super</code>，咁即係話我地可以有 <code>List&lt;Super&gt;</code> 同 <code>List&lt;Sub&gt;</code>，咁到底兩者既 variables 同 objects 係咪互相相容（in terms of polymorphism）？呢個就係 covariance 問題。</p>
<p>註：除左 <code>extends</code>，covariance 既規則對 <code>implements</code>（interface）都一樣適用。</p>
<hr/>
<h1>4 Covariance 規則</h1>
<p>到底 <code>Clazz&lt;T&gt;</code> 可以 assign 返乜野 type 既 object？</p>
<p>假設我地有以下既自定義 classes：</p>
<pre><code class="language-java">class Wrapper&lt;T&gt; {
    public void foo(T obj) {}
}
class SubWrapper&lt;T&gt; extends Wrapper&lt;T&gt; {}

class Super {}
class Sub extends Super {}
</code></pre>
<p>如果係特定 generic type，例如 <code>Wrapper&lt;Super&gt;</code>，特定左 generic type 係 <code>Super</code>，咁只能 assign 同樣特定 generic type 既 <code>Wrapper</code> 或者 <code>Wrapper</code> 既 subclass 既 object：</p>
<pre><code class="language-java">Wrapper&lt;Super&gt; wrapper;
wrapper = new Wrapper&lt;Super&gt;();
wrapper = new SubWrapper&lt;Super&gt;();

wrapper.foo(null);
wrapper.foo(new Super());
wrapper.foo(new Sub());

// 唔可以用特定 generic type 既 subclass 做個 generic type
wrapper = new Wrapper&lt;Sub&gt;(); // compilation error
wrapper = new SubWrapper&lt;Sub&gt;(); // compilation error
</code></pre>
<p>如果係 upper bounded wildcard，例如 <code>Wrapper&lt;? extends Super&gt;</code>，咁可以 assign 相同既 generic type 或者佢既 subclass 既 <code>Wrapper</code> 或者 <code>Wrapper</code> 既 subclass 既 object：</p>
<pre><code class="language-java">Wrapper&lt;? extends Super&gt; wrapper;
wrapper = new Wrapper&lt;Super&gt;();
wrapper = new SubWrapper&lt;Super&gt;();
wrapper = new Wrapper&lt;Sub&gt;();
wrapper = new SubWrapper&lt;Sub&gt;();

wrapper.foo(null);

// 唔可以 call 任何 parameter 有 T 既 method
wrapper.foo(new Super()); // compilation error
wrapper.foo(new Sub()); // compilation error
</code></pre>
<p>如果係 lower bounded wildcard，例如 <code>Wrapper&lt;? super Super&gt;</code>，咁可以 assign 相同既 generic type 或者佢既 superclass 既 <code>Wrapper</code> 或者 <code>Wrapper</code> 既 subclass 既 object：</p>
<pre><code class="language-java">Wrapper&lt;? super Super&gt; wrapper;
wrapper = new Wrapper&lt;Super&gt;();
wrapper = new SubWrapper&lt;Super&gt;();
wrapper = new Wrapper&lt;Object&gt;();
wrapper = new SubWrapper&lt;Object&gt;();

wrapper.foo(null);
wrapper.foo(new Super());
wrapper.foo(new Sub());
</code></pre>
<p>如果係 wildcard，例如 <code>Wrapper&lt;?&gt;</code>，咁可以 assign 任何 generic type 既 <code>Wrapper</code> 或者 <code>Wrapper</code> 既 subclass 既 object：</p>
<pre><code class="language-java">Wrapper&lt;?&gt; wrapper;
wrapper = new Wrapper&lt;Super&gt;();
wrapper = new SubWrapper&lt;Super&gt;();
wrapper = new Wrapper&lt;Sub&gt;();
wrapper = new SubWrapper&lt;Sub&gt;();
wrapper = new Wrapper&lt;Object&gt;();
wrapper = new SubWrapper&lt;Object&gt;();

wrapper.foo(null);

// 唔可以 call 任何 parameter 有 T 既 method
wrapper.foo(new Super()); // compilation error
wrapper.foo(new Sub()); // compilation error
wrapper.foo(new Object()); // compilation error
</code></pre><hr/><div class="vstack gap-3"><div class="text-center container"><div class="justify-content-center g-3 row row-cols-md-3 row-cols-sm-2 row-cols-1"><div class="col"><a target="_blank" rel="external nofollow noopener noreferrer" class="SiteFooter_contact-item__2JRRr card" href="tel:+85263301333"><div class="card-body"><div class="card-title h5"><i class="fa-solid fa-phone" style="color:#009688"></i></div><p class="text-muted card-text">6330 1333<!-- --> </p></div></a></div><div class="col"><a target="_blank" rel="external nofollow noopener noreferrer" class="SiteFooter_contact-item__2JRRr card" href="mailto:michaelboyboy@gmail.com"><div class="card-body"><div class="card-title h5"><i class="fa-solid fa-envelope" style="color:#f44336"></i></div><p class="text-muted card-text">michaelboyboy@gmail.com<!-- --> </p></div></a></div><div class="col"><a target="_blank" rel="external nofollow noopener noreferrer" class="SiteFooter_contact-item__2JRRr card" href="https://www.linkedin.com/in/mickchung"><div class="card-body"><div class="card-title h5"><i class="fa-brands fa-linkedin" style="color:#2196f3"></i></div><p class="text-muted card-text">www.linkedin.com/in/mickchung<!-- --> </p></div></a></div></div></div></div></div><script src="/e2-next/_next/static/chunks/webpack-f088da4552bcc253.js" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0])</script><script>self.__next_f.push([1,"1:\"$Sreact.fragment\"\n2:I[8287,[\"7829\",\"static/chunks/7829-b7b9eb1dbe0d40e4.js\",\"2153\",\"static/chunks/2153-45fd9844831c6348.js\",\"7177\",\"static/chunks/app/layout-ea91c2d128ec48c2.js\"],\"default\"]\n3:I[3339,[\"7829\",\"static/chunks/7829-b7b9eb1dbe0d40e4.js\",\"8974\",\"static/chunks/app/page-c8b940db14fac9a0.js\"],\"default\"]\n4:I[1367,[\"7829\",\"static/chunks/7829-b7b9eb1dbe0d40e4.js\",\"2153\",\"static/chunks/2153-45fd9844831c6348.js\",\"7177\",\"static/chunks/app/layout-ea91c2d128ec48c2.js\"],\"default\"]\n5:I[5244,[],\"\"]\n6:I[3866,[],\"\"]\n7:I[4798,[\"7829\",\"static/chunks/7829-b7b9eb1dbe0d40e4.js\",\"8974\",\"static/chunks/app/page-c8b940db14fac9a0.js\"],\"default\"]\n8:I[6121,[\"7829\",\"static/chunks/7829-b7b9eb1dbe0d40e4.js\",\"8974\",\"static/chunks/app/page-c8b940db14fac9a0.js\"],\"default\"]\n9:I[3667,[\"7829\",\"static/chunks/7829-b7b9eb1dbe0d40e4.js\",\"8974\",\"static/chunks/app/page-c8b940db14fac9a0.js\"],\"default\"]\na:I[8407,[\"7829\",\"static/chunks/7829-b7b9eb1dbe0d40e4.js\",\"2153\",\"static/chunks/2153-45fd9844831c6348.js\",\"7177\",\"static/chunks/app/layout-ea91c2d128ec48c2.js\"],\"default\"]\nb:I[8173,[\"7829\",\"static/chunks/7829-b7b9eb1dbe0d40e4.js\",\"8974\",\"static/chunks/app/page-c8b940db14fac9a0.js\"],\"\"]\nc:I[3197,[\"7829\",\"static/chunks/7829-b7b9eb1dbe0d40e4.js\",\"2153\",\"static/chunks/2153-45fd9844831c6348.js\",\"7177\",\"static/chunks/app/layout-ea91c2d128ec48c2.js\"],\"default\"]\nd:I[7933,[\"7829\",\"static/chunks/7829-b7b9eb1dbe0d40e4.js\",\"2153\",\"static/chunks/2153-45fd9844831c6348.js\",\"7177\",\"static/chunks/app/layout-ea91c2d128ec48c2.js\"],\"default\"]\ne:I[3800,[\"7829\",\"static/chunks/7829-b7b9eb1dbe0d40e4.js\",\"2153\",\"static/chunks/2153-45fd9844831c6348.js\",\"7177\",\"static/chunks/app/layout-ea91c2d128ec48c2.js\"],\"default\"]\n10:I[6213,[],\"OutletBoundary\"]\n12:I[6213,[],\"MetadataBoundary\"]\n14:I[6213,[],\"ViewportBoundary\"]\n16:I[4835,[],\"\"]\n:HL[\"/e2-next/_next/static/css/d3df112486f97f47.css\",\"style\"]\n:HL[\"/e2-next/_next/static/css/c3624a693ae5a0c4.css\",\"style\"]\nf:T42c,public final class TypeUtils {\r\n\r\n    private TypeUtils() {}\r\n\r\n    public static List\u003cString\u003e getGenericTypeNames("])</script><script>self.__next_f.push([1,"Class\u003c?\u003e clazz) {\r\n\r\n        if (!(clazz.getGenericSuperclass() instanceof ParameterizedType)) {\r\n            return Collections.emptyList();\r\n        }\r\n\r\n        return Arrays\r\n                .stream(((ParameterizedType) clazz.getGenericSuperclass()).getActualTypeArguments())\r\n                .map(Type::getTypeName)\r\n                .collect(Collectors.toList());\r\n    }\r\n\r\n    public static List\u003cClass\u003c?\u003e\u003e getGenericTypes(Class\u003c?\u003e clazz) {\r\n        return getGenericTypeNames(clazz).stream()\r\n                .map(e -\u003e e.replaceAll(\"\u003c.*?\u003e\", \"\"))\r\n                .map(e -\u003e {\r\n                    try {\r\n                        return Class.forName(e);\r\n                    } catch (Exception ex) {\r\n                        ex.printStackTrace(); // handle exception\r\n                        return null;\r\n                    }\r\n                })\r\n                .filter(Objects::nonNull)\r\n                .collect(Collectors.toList());\r\n    }\r\n}\n"])</script><script>self.__next_f.push([1,"0:{\"P\":null,\"b\":\"wfZ4FdS4ntgGvzjeKJhfw\",\"p\":\"/e2-next\",\"c\":[\"\",\"blog\",\"java-collections-generic-type-covariance\"],\"i\":false,\"f\":[[[\"\",{\"children\":[\"blog\",{\"children\":[\"(2021-06)\",{\"children\":[\"java-collections-generic-type-covariance\",{\"children\":[\"__PAGE__\",{}]}]}]}]},\"$undefined\",\"$undefined\",true],[\"\",[\"$\",\"$1\",\"c\",{\"children\":[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/e2-next/_next/static/css/d3df112486f97f47.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\",\"nonce\":\"$undefined\"}],[\"$\",\"link\",\"1\",{\"rel\":\"stylesheet\",\"href\":\"/e2-next/_next/static/css/c3624a693ae5a0c4.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\",\"nonce\":\"$undefined\"}]],[\"$\",\"html\",null,{\"lang\":\"en\",\"children\":[[\"$\",\"head\",null,{\"children\":[[\"$\",\"link\",null,{\"href\":\"https://fonts.googleapis.com/css2?family=Roboto:ital,wght@0,100;0,300;0,400;0,500;0,700;0,900;1,100;1,300;1,400;1,500;1,700;1,900\u0026display=swap\",\"rel\":\"stylesheet\"}],[\"$\",\"link\",null,{\"rel\":\"stylesheet\",\"href\":\"https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.6.0/css/all.min.css\"}]]}],[\"$\",\"body\",null,{\"children\":[\"$\",\"$L2\",null,{\"children\":[\"$\",\"$L3\",null,{\"gap\":5,\"children\":[[\"$\",\"$L3\",null,{\"gap\":5,\"className\":\"text-center\",\"children\":[[\"$\",\"div\",null,{\"children\":[[\"$\",\"code\",null,{\"className\":\"SiteHeader_name__cwQmL\",\"children\":\"Chung Cheuk Hang Michael\"}],[\"$\",\"code\",null,{\"className\":\"SiteHeader_title__CCfvI\",\"children\":\"Java Web Developer\"}]]}],[\"$\",\"$L4\",null,{}]]}],[\"$\",\"$L5\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L6\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[[],[[\"$\",\"title\",null,{\"children\":\"404: This page could not be found.\"}],[\"$\",\"div\",null,{\"style\":{\"fontFamily\":\"system-ui,\\\"Segoe UI\\\",Roboto,Helvetica,Arial,sans-serif,\\\"Apple Color Emoji\\\",\\\"Segoe UI Emoji\\\"\",\"height\":\"100vh\",\"textAlign\":\"center\",\"display\":\"flex\",\"flexDirection\":\"column\",\"alignItems\":\"center\",\"justifyContent\":\"center\"},\"children\":[\"$\",\"div\",null,{\"children\":[[\"$\",\"style\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}\"}}],[\"$\",\"h1\",null,{\"className\":\"next-error-h1\",\"style\":{\"display\":\"inline-block\",\"margin\":\"0 20px 0 0\",\"padding\":\"0 23px 0 0\",\"fontSize\":24,\"fontWeight\":500,\"verticalAlign\":\"top\",\"lineHeight\":\"49px\"},\"children\":404}],[\"$\",\"div\",null,{\"style\":{\"display\":\"inline-block\"},\"children\":[\"$\",\"h2\",null,{\"style\":{\"fontSize\":14,\"fontWeight\":400,\"lineHeight\":\"49px\",\"margin\":0},\"children\":\"This page could not be found.\"}]}]]}]}]]],\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}],[\"$\",\"hr\",null,{}],[\"$\",\"$L3\",null,{\"gap\":3,\"children\":[\"$\",\"$L7\",null,{\"className\":\"text-center\",\"children\":[\"$\",\"$L8\",null,{\"xs\":1,\"sm\":2,\"md\":3,\"className\":\"justify-content-center g-3\",\"children\":[[\"$\",\"$L9\",\"0\",{\"children\":[\"$\",\"$La\",null,{\"as\":\"$b\",\"href\":\"tel:+85263301333\",\"target\":\"_blank\",\"rel\":\"external nofollow noopener noreferrer\",\"className\":\"SiteFooter_contact-item__2JRRr\",\"children\":[\"$\",\"$Lc\",null,{\"children\":[[\"$\",\"$Ld\",null,{\"children\":[\"$\",\"i\",null,{\"className\":\"fa-solid fa-phone\",\"style\":{\"color\":\"#009688\"}}]}],[\"$\",\"$Le\",null,{\"className\":\"text-muted\",\"children\":[\"6330 1333\",\" \"]}]]}]}]}],[\"$\",\"$L9\",\"1\",{\"children\":[\"$\",\"$La\",null,{\"as\":\"$b\",\"href\":\"mailto:michaelboyboy@gmail.com\",\"target\":\"_blank\",\"rel\":\"external nofollow noopener noreferrer\",\"className\":\"SiteFooter_contact-item__2JRRr\",\"children\":[\"$\",\"$Lc\",null,{\"children\":[[\"$\",\"$Ld\",null,{\"children\":[\"$\",\"i\",null,{\"className\":\"fa-solid fa-envelope\",\"style\":{\"color\":\"#f44336\"}}]}],[\"$\",\"$Le\",null,{\"className\":\"text-muted\",\"children\":[\"michaelboyboy@gmail.com\",\" \"]}]]}]}]}],[\"$\",\"$L9\",\"2\",{\"children\":[\"$\",\"$La\",null,{\"as\":\"$b\",\"href\":\"https://www.linkedin.com/in/mickchung\",\"target\":\"_blank\",\"rel\":\"external nofollow noopener noreferrer\",\"className\":\"SiteFooter_contact-item__2JRRr\",\"children\":[\"$\",\"$Lc\",null,{\"children\":[[\"$\",\"$Ld\",null,{\"children\":[\"$\",\"i\",null,{\"className\":\"fa-brands fa-linkedin\",\"style\":{\"color\":\"#2196f3\"}}]}],[\"$\",\"$Le\",null,{\"className\":\"text-muted\",\"children\":[\"www.linkedin.com/in/mickchung\",\" \"]}]]}]}]}]]}]}]}]]}]}]}]]}]]}],{\"children\":[\"blog\",[\"$\",\"$1\",\"c\",{\"children\":[null,[\"$\",\"$L5\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"blog\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L6\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]]}],{\"children\":[\"(2021-06)\",[\"$\",\"$1\",\"c\",{\"children\":[null,[\"$\",\"$L5\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"blog\",\"children\",\"(2021-06)\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L6\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]]}],{\"children\":[\"java-collections-generic-type-covariance\",[\"$\",\"$1\",\"c\",{\"children\":[null,[\"$\",\"$L5\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"blog\",\"children\",\"(2021-06)\",\"children\",\"java-collections-generic-type-covariance\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L6\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]]}],{\"children\":[\"__PAGE__\",[\"$\",\"$1\",\"c\",{\"children\":[[[\"$\",\"h1\",null,{\"children\":\"1 重溫 Java collections\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"如果想重溫返關於 Java \",[\"$\",\"code\",null,{\"children\":\"Collection\"}],\" 既 \",[\"$\",\"code\",null,{\"children\":\"List\"}],\"、\",[\"$\",\"code\",null,{\"children\":\"Set\"}],\" subinterfaces 以及 \",[\"$\",\"code\",null,{\"children\":\"Map\"}],\"，可以睇返呢篇：\",[\"$\",\"a\",null,{\"href\":\"/blog/coding-java-3#335-array--collection--map\",\"children\":\"Java 開發筆記（三） - Array / Collection / Map\"}],\"。\"]}],\"\\n\",[\"$\",\"p\",null,{\"children\":[[\"$\",\"code\",null,{\"children\":\"List\"}],\"：\"]}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"className\":\"language-java\",\"children\":\"List\u003cString\u003e names = new ArrayList\u003c\u003e();\\r\\nnames.add(\\\"Michael\\\");\\r\\nnames.add(\\\"Peter\\\");\\r\\nnames.add(\\\"Peter\\\");\\r\\nSystem.out.println(names); // [Michael, Peter, Peter]\\n\"}]}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"解釋：\",[\"$\",\"code\",null,{\"children\":\"List\"}],\" 支持重複既 elements。\"]}],\"\\n\",[\"$\",\"p\",null,{\"children\":[[\"$\",\"code\",null,{\"children\":\"Set\"}],\"：\"]}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"className\":\"language-java\",\"children\":\"Set\u003cString\u003e names = new HashSet\u003c\u003e();\\r\\nnames.add(\\\"Michael\\\");\\r\\nnames.add(\\\"Peter\\\");\\r\\nnames.add(\\\"Peter\\\");\\r\\nSystem.out.println(names); // [Michael, Peter]\\n\"}]}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"解釋：\",[\"$\",\"code\",null,{\"children\":\"Set\"}],\" 裡面既 elements 都係獨一無二，唔會重複。如果 \",[\"$\",\"code\",null,{\"children\":\"Set\"}],\" 既 generic type 係自定義既 class，咁建議喺自定義既 class 裡面再定義 \",[\"$\",\"code\",null,{\"children\":\"equals(obj)\"}],\" 同 \",[\"$\",\"code\",null,{\"children\":\"hashCode()\"}],\" 既邏輯，畀 \",[\"$\",\"code\",null,{\"children\":\"Set\"}],\" 判決呢個自定義既 class 既唔同既 objects 係咪重複。\"]}],\"\\n\",[\"$\",\"p\",null,{\"children\":[[\"$\",\"code\",null,{\"children\":\"Map\"}],\"：\"]}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"className\":\"language-java\",\"children\":\"Map\u003cString, Integer\u003e nameAgeMap = new HashMap\u003c\u003e();\\r\\nnameAgeMap.put(\\\"Alice\\\", 15);\\r\\nnameAgeMap.put(\\\"Bob\\\", 24);\\r\\nnameAgeMap.put(\\\"Alice\\\", 22);\\r\\nSystem.out.println(nameAgeMap); // {Bob=24, Alice=22}\\n\"}]}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"解釋：\",[\"$\",\"code\",null,{\"children\":\"Map\"}],\" 既 keys 都係獨一無二，唔會重複，一般情況都會用 Java 內建既 primitive wrapper classes 或者 \",[\"$\",\"code\",null,{\"children\":\"String\"}],\" 作為 key 既 generic type，而 value 就更可以用自定義既 class 做 generic type。\"]}],\"\\n\",[\"$\",\"hr\",null,{}],\"\\n\",[\"$\",\"h1\",null,{\"children\":\"2 介紹 Java generic type\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"上面既 \",[\"$\",\"code\",null,{\"children\":\"List\"}],\"、\",[\"$\",\"code\",null,{\"children\":\"Set\"}],\"、\",[\"$\",\"code\",null,{\"children\":\"Map\"}],\" 例子裡面，我地都見到佢地有個 diamond operator \",[\"$\",\"code\",null,{\"children\":\"\u003c\u003e\"}],\"，而裡面有一個 type，我地會叫 \",[\"$\",\"code\",null,{\"children\":\"\u003cT\u003e\"}],\" 裡面既 type 做 generic type，咁 \",[\"$\",\"code\",null,{\"children\":\"Clazz\u003cT\u003e\"}],\" 成個夾埋係表達緊 class of type，例如 \",[\"$\",\"code\",null,{\"children\":\"List\u003cString\u003e\"}],\" 解 \",[\"$\",\"code\",null,{\"children\":\"List\"}],\" of \",[\"$\",\"code\",null,{\"children\":\"String\"}],\"，因為已經 substitute 左 \",[\"$\",\"code\",null,{\"children\":\"String\"}],\" 落 \",[\"$\",\"code\",null,{\"children\":\"List\u003cT\u003e\"}],\" 既 \",[\"$\",\"code\",null,{\"children\":\"T\"}],\"，所以 \",[\"$\",\"code\",null,{\"children\":\"List\u003cString\u003e\"}],\" 喺呢個情況就係一個 parameterized type。\"]}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"Generic type 係 Java 5 加入既功能，compiler 會喺 compile time 既時候幫我 check 啲 code 寫得合唔合理，係 for type safety 既用途。例如，明明我地 declare 既係 \",[\"$\",\"code\",null,{\"children\":\"List\u003cString\u003e list\"}],\"，但我地又 call \",[\"$\",\"code\",null,{\"children\":\"list.add(1)\"}],\"，咁就好唔合理，而 compiler 就會喺 compile time 出 error，示意我地要睇下有冇寫錯 code。不過呢個功能只會應用喺 compile time，runtime 係發揮唔到任何作用，因為有 type erasure。\"]}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"因為 Java 既新版都會支持返舊式既 syntax，所以就算唔寫 \",[\"$\",\"code\",null,{\"children\":\"\u003cType\u003e\"}],\" 都唔會引致 compilation error。即係咁樣寫都冇問題：\"]}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"className\":\"language-java\",\"children\":\"List rawList = new ArrayList();\\r\\nSet rawSet = new HashSet();\\r\\nMap rawMap = new HashMap();\\n\"}]}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"呢啲冇畀 generic type 既 objects 既 class 我地會叫做 \",[\"$\",\"a\",null,{\"href\":\"https://docs.oracle.com/javase/tutorial/java/generics/rawTypes.html\",\"children\":\"raw type\"}],\"。\"]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"有啲 IDE 例如 Eclipse 默認既設定下會顯示黃線 warning，提示 raw type 係舊式寫法，應該跟足新式寫法，令我地既 code 更 strongly typed。\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"以下係複雜少少，牽涉 subclass：\"}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"className\":\"language-java\",\"children\":\"List\u003cNumber\u003e nums = new ArrayList\u003c\u003e();\\r\\nnums.add(1); // 1 係 int，會被 autobox 成 Integer object\\r\\nnums.add(1L); // 1 係 long，會被 autobox 成 Long object\\r\\nnums.add(1.5F); // 1.5F 係 float，會被 autobox 成 Float object\\r\\nnums.add(1.5D); // 1.5D 係 double，會被 autobox 成 Double object\\n\"}]}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"解釋：\",[\"$\",\"code\",null,{\"children\":\"List\u003cNumber\u003e\"}],\" 可以 \",[\"$\",\"code\",null,{\"children\":\"add()\"}],\" 既 argument 可以係任何 \",[\"$\",\"code\",null,{\"children\":\"extends Number\"}],\" 既 object。\"]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"但咁樣寫會有 compilation error：\"}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"className\":\"language-java\",\"children\":\"List\u003cNumber\u003e nums = new ArrayList\u003c\u003e();\\r\\nnums = new ArrayList\u003cInteger\u003e(); // compilation error\\r\\nnums = new ArrayList\u003cLong\u003e(); // compilation error\\r\\nnums = new ArrayList\u003cFloat\u003e(); // compilation error\\r\\nnums = new ArrayList\u003cDouble\u003e(); // compilation error\\n\"}]}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"解釋：\",[\"$\",\"code\",null,{\"children\":\"List\u003cNumber\u003e\"}],\" 既 variable 只限 assign 返 \",[\"$\",\"code\",null,{\"children\":\"List\u003cNumber\u003e\"}],\" 既 object。\"]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"但如果換成咁樣寫，反而就冇 compilation error（Java 8+）：\"}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"className\":\"language-java\",\"children\":\"public static void main(String[] args) throws Exception {\\r\\n\\r\\n    List\u003cNumber\u003e nums = new ArrayList\u003c\u003e();\\r\\n\\r\\n    // 下面既 createList(T...) 同用 Arrays.asList(T...) 一樣\\r\\n    nums = createList(); // List\u003cNumber\u003e\\r\\n    nums = createList(1, 2); // List\u003cInteger\u003e\\r\\n    nums = createList(1L, 2L); // List\u003cLong\u003e\\r\\n    nums = createList(1.5F, 2.5F); // List\u003cFloat\u003e\\r\\n    nums = createList(1.5D, 2.5D); // List\u003cDouble\u003e\\r\\n}\\r\\n\\r\\nprivate static \u003cT\u003e List\u003cT\u003e createList(T... nums) {\\r\\n    final List list = Arrays.asList(nums);\\r\\n    return list;\\r\\n}\\n\"}]}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"解釋：\",[\"$\",\"code\",null,{\"children\":\"createList(T...)\"}],\" 或者 \",[\"$\",\"code\",null,{\"children\":\"Arrays.asList(T...)\"}],\" 做緊既野一樣，都係根據傳入既 \",[\"$\",\"code\",null,{\"children\":\"T...\"}],\" varargs 既 \",[\"$\",\"code\",null,{\"children\":\"T\"}],\" 去 infer return type \",[\"$\",\"code\",null,{\"children\":\"List\u003cT\u003e\"}],\" 裡面既 \",[\"$\",\"code\",null,{\"children\":\"T\"}],\"。然後我地將 \",[\"$\",\"code\",null,{\"children\":\"createList(T...)\"}],\" 既 result assign 落 \",[\"$\",\"code\",null,{\"children\":\"List\u003cNumber\u003e\"}],\" 度。就咁睇好似同上面出 error 既例子一樣，但其實情況有啲唔同，因為 Java 8+ 會睇埋 assignment 既被 assign 果邊（即係左手邊既 \",[\"$\",\"code\",null,{\"children\":\"nums\"}],\"）既 type，再去決定右手邊既 type，而呢個情況下句 \",[\"$\",\"code\",null,{\"children\":\"createList(T...)\"}],\" expression 就係 poly expression，出現左喺一個 poly context 裡面。類似既做法有 Java 7 既 type inference，例如 \",[\"$\",\"code\",null,{\"children\":\"List\u003cString\u003e list = new ArrayList\u003c\u003e()\"}],\" 既 \",[\"$\",\"code\",null,{\"children\":\"\u003c\u003e\"}],\" 唔洗寫 \",[\"$\",\"code\",null,{\"children\":\"\u003cString\u003e\"}],\" 係因為 compiler 知道呢個係 poly expression，就會睇埋 assignment 既 context，會睇被 assign 果邊去決定 \",[\"$\",\"code\",null,{\"children\":\"\u003c\u003e\"}],\" 裡面係咩 type。相反，standalone expression 就唔會理個 context。\"]}],\"\\n\",[\"$\",\"h2\",null,{\"children\":\"2.1 Type erasure\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"其實 Java 既 generic type 只不過係 for compile time 既 type safety 用，而去到 runtime（個 JVM 幫你執行緊你啲 code）既時候，所有 type information 就會冇曬。\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"呢個亦係點解我地寫 utility methods 既時候，係冇得寫 \",[\"$\",\"code\",null,{\"children\":\"T.class\"}],\" 或者用 reflection 既方法黎 reference 返一個 parameterized type 既 \",[\"$\",\"code\",null,{\"children\":\"\u003cT\u003e\"}],\" 裡面既 \",[\"$\",\"code\",null,{\"children\":\"T\"}],\" 喺 runtime 既 value，而一定要用一個 parameter \",[\"$\",\"code\",null,{\"children\":\"Class\u003c?\u003e type\"}],\" 既 variable 先可以知道係咩 type。\"]}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"className\":\"language-java\",\"children\":\"public static \u003cT\u003e void foo(T obj) {\\r\\n    // 唔知 T 係咩黎，冇得用 T.class 或者 T.newInstance()\\r\\n}\\n\"}]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"要改成：\"}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"className\":\"language-java\",\"children\":\"public static \u003cT\u003e void foo(T obj, Class\u003cT\u003e type) {\\r\\n    T newObj = type.newInstance();\\r\\n    System.out.println(type);\\r\\n}\\n\"}]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"只要唔係 unbounded wildcard 既 parameterized type，都係 non-reifiable type，type information 都會喺 runtime 度 lost 左。\"}],\"\\n\",[\"$\",\"blockquote\",null,{\"children\":[\"\\n\",[\"$\",\"p\",null,{\"children\":\"A reifiable type is a type whose type information is fully available at runtime. This includes primitives, non-generic types, raw types, and invocations of unbound wildcards.\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"Non-reifiable types are types where information has been removed at compile-time by type erasure — invocations of generic types that are not defined as unbounded wildcards. A non-reifiable type does not have all of its information available at runtime. Examples of non-reifiable types are \",[\"$\",\"code\",null,{\"children\":\"List\u003cString\u003e\"}],\" and \",[\"$\",\"code\",null,{\"children\":\"List\u003cNumber\u003e\"}],\"; the JVM cannot tell the difference between these types at runtime. As shown in Restrictions on Generics, there are certain situations where non-reifiable types cannot be used: in an \",[\"$\",\"code\",null,{\"children\":\"instanceof\"}],\" expression, for example, or as an element in an array.\"]}],\"\\n\"]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"舉個例，即係就算我地咁樣寫，唔單止喺 compile time 冇 error，而到左 runtime 都唔會有任何 exception：\"}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"className\":\"language-java\",\"children\":\"List nums = new ArrayList\u003cInteger\u003e();\\r\\nnums.add(1);\\r\\nnums.add(\\\"Hi\\\");\\r\\n\\r\\nSystem.out.println(nums.get(0)); // 1\\r\\nSystem.out.println(nums.get(1)); // Hi\\n\"}]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"解釋：\"}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":[\"上面段 code 冇 compile time exception 好正常，因為 \",[\"$\",\"code\",null,{\"children\":\"List\"}],\" 係 raw type，而之前已經講過，想要 compiler 幫我地 check type，就要寫埋個 generic type，例如 \",[\"$\",\"code\",null,{\"children\":\"List\u003cString\u003e\"}],\"；\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[\"而點解上面段 code 喺 runtime 執行 \",[\"$\",\"code\",null,{\"children\":\"add()\"}],\" 唔同 types 既 objects 都冇任何 exception？咁係因為 type erasure 既關係，就算我地 assign 既 object 係 \",[\"$\",\"code\",null,{\"children\":\"ArrayList\u003cInteger\u003e\"}],\"，其實呢個 \",[\"$\",\"code\",null,{\"children\":\"\u003cInteger\u003e\"}],\" 喺 compile 完出黎既 bytecode 裡面係會抹走左，咁 runtime 自然就冇 type information，即係 \",[\"$\",\"code\",null,{\"children\":\"new ArrayList\u003cInteger\u003e()\"}],\" 到左 runtime 其實同一個冇 generic type 既 \",[\"$\",\"code\",null,{\"children\":\"new ArrayList()\"}],\" 完全一樣，所以點解話 generics 只會喺 compile time 發揮作用，就係呢個原因。\"]}],\"\\n\"]}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"但如果我地將 \",[\"$\",\"code\",null,{\"children\":\"List nums\"}],\" 改成 \",[\"$\",\"code\",null,{\"children\":\"List\u003cInteger\u003e nums\"}],\"，\",[\"$\",\"code\",null,{\"children\":\"nums.add(\\\"Hi\\\")\"}],\" 就會出 compile time error，咁係因為 compiler 幫我地喺 compile time check 左，\",[\"$\",\"code\",null,{\"children\":\"List\u003cInteger\u003e\"}],\" 係加唔到 \",[\"$\",\"code\",null,{\"children\":\"String\"}],\" object。\"]}],\"\\n\",[\"$\",\"h3\",null,{\"children\":\"2.1.1 Explicit type casting\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"因為 type erasure 既關係，喺 runtime 既時候如果要用 generic type \",[\"$\",\"code\",null,{\"children\":\"\u003cT\u003e\"}],\" 黎做 explicit type casting，就唔可以用 \",[\"$\",\"code\",null,{\"children\":\"(T) obj\"}],\" 既寫法：\"]}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"className\":\"language-java\",\"children\":\"public class Main {\\r\\n\\r\\n    public static void main(String[] args) {\\r\\n        final GenericClass\u003cInteger\u003e list = castToGenericClass(\\\"123\\\");\\r\\n        System.out.println(list.getData() instanceof Integer); // false\\r\\n        System.out.println(list.getData().getClass()); // ClassCastException\\r\\n    }\\r\\n\\r\\n    private static \u003cT\u003e GenericClass\u003cT\u003e castToGenericClass(Object obj) {\\r\\n\\r\\n        final T cast = (T) obj;\\r\\n\\r\\n        final GenericClass\u003cT\u003e list = new GenericClass\u003c\u003e();\\r\\n        list.setData(cast);\\r\\n\\r\\n        return list;\\r\\n    }\\r\\n}\\r\\n\\r\\n@Data\\r\\nclass GenericClass\u003cT\u003e {\\r\\n    T data;\\r\\n}\\n\"}]}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"應該改為傳入 \",[\"$\",\"code\",null,{\"children\":\"Class\u003cT\u003e clazz\"}],\"，然後用 \",[\"$\",\"code\",null,{\"children\":\"clazz.cast(obj)\"}],\" 既方式：\"]}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"className\":\"language-java\",\"children\":\"public class Main {\\r\\n\\r\\n    public static void main(String[] args) {\\r\\n        final GenericClass\u003cString\u003e list = castToGenericClass(\\\"123\\\", String.class);\\r\\n        System.out.println(list.getData().getClass()); // class java.lang.String\\r\\n\\r\\n        final GenericClass\u003cInteger\u003e list2 = castToGenericClass(123, Integer.class);\\r\\n        System.out.println(list2.getData().getClass()); // class java.lang.Integer\\r\\n    }\\r\\n\\r\\n    private static \u003cT\u003e GenericClass\u003cT\u003e castToGenericClass(Object obj, Class\u003cT\u003e clazz) {\\r\\n\\r\\n        final T cast = clazz.cast(obj);\\r\\n\\r\\n        final GenericClass\u003cT\u003e list = new GenericClass\u003c\u003e();\\r\\n        list.setData(cast);\\r\\n\\r\\n        return list;\\r\\n    }\\r\\n}\\r\\n\\r\\n@Data\\r\\nclass GenericClass\u003cT\u003e {\\r\\n    T data;\\r\\n}\\n\"}]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"參考資料：\"}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":[\"$\",\"a\",null,{\"href\":\"https://stackoverflow.com/questions/14524751/cast-object-to-generic-type-for-returning\",\"children\":\"StackOverflow - Cast Object to Generic Type for returning\"}]}],\"\\n\"]}],\"\\n\",[\"$\",\"h3\",null,{\"children\":\"2.1.2 Declared type information\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"如果個 generic type 係喺 class definition 層面，例如以下既例子，咁係可以 reference 到個 type，但一定要係 type declaration 先可以，如果唔係 type declaration 既情況下 invoke generic type，最後都係會令 type information lost 左。\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"首先我地寫一個 utility class，喺下面既例子會用到：\"}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"className\":\"language-java\",\"children\":\"$f\"}]}],\"\\n\",[\"$\",\"h4\",null,{\"children\":\"2.1.2.1 Anonymous class\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"Anonymous class 係 type declaration，所以可以拎到 parameterized type 裡面既 generic type information 出黎。\"}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"className\":\"language-java\",\"children\":\"Map raw = new HashMap\u003cInteger, String\u003e() {}; // 注意後面既 {} 令佢成為 anonymous class\\r\\n\\r\\nList\u003cString\u003e typeNames = TypeUtils.getGenericTypeNames(raw.getClass());\\r\\nSystem.out.println(typeNames);\\r\\n// [java.lang.Integer, java.util.List\u003cjava.lang.String\u003e]\\r\\n\\r\\nList\u003cClass\u003c?\u003e\u003e types = TypeUtils.getGenericTypes(raw.getClass());\\r\\nSystem.out.println(types);\\r\\n// [class java.lang.Integer, interface java.util.List]\\n\"}]}],\"\\n\",[\"$\",\"h4\",null,{\"children\":\"2.1.2.2 Subclass\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"Subclass 係 type declaration，所以可以拎到 parameterized type 裡面既 generic type information 出黎。但係如果直接用 superclass invoke generic type，咁就拎唔到 generic type information 出黎。\"}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"className\":\"language-java\",\"children\":\"public class Main {\\r\\n\\r\\n    public static void main(String[] args) {\\r\\n\\r\\n        new Sub();\\r\\n        // [java.lang.String, java.util.List\u003cjava.lang.Integer\u003e]\\r\\n        // [class java.lang.String, interface java.util.List]\\r\\n\\r\\n        new Super\u003cInteger, List\u003cString\u003e\u003e();\\r\\n        // [] 拎唔到\\r\\n        // [] 拎唔到\\r\\n    }\\r\\n}\\r\\n\\r\\nclass Super\u003cT1, T2\u003e {\\r\\n    public Super() {\\r\\n        System.out.println(TypeUtils.getGenericTypeNames(getClass()));\\r\\n        System.out.println(TypeUtils.getGenericTypes(getClass()));\\r\\n    }\\r\\n}\\r\\n\\r\\nclass Sub extends Super\u003cString, List\u003cInteger\u003e\u003e {}\\n\"}]}],\"\\n\",[\"$\",\"hr\",null,{}],\"\\n\",[\"$\",\"h2\",null,{\"children\":\"2.2 Unbounded wildcard generic type\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"我地可以用問號 \",[\"$\",\"code\",null,{\"children\":\"?\"}],\" 黎代表 generic type 係 wildcard type：\"]}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"className\":\"language-java\",\"children\":\"List\u003c?\u003e list = new ArrayList\u003c\u003e();\\r\\n\\r\\nlist = Arrays.asList(\\\"item\\\");\\r\\n// wildcard generic type 既 List variable 可以 assign 任何 generic type 既 List object\\r\\n\\r\\nlist.add(null);\\r\\nlist.add(new Object()); // compilation error\\r\\n// 因為 Java 唔知個 List 係咩 generic type，我地係 add 唔到 element（除左乜野 type 都唔係既 null）\\n\"}]}],\"\\n\",[\"$\",\"hr\",null,{}],\"\\n\",[\"$\",\"h2\",null,{\"children\":\"2.3 Upper bounded wildcard generic type\"}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"className\":\"language-java\",\"children\":\"List\u003c? extends Number\u003e nums = new ArrayList\u003c\u003e();\\n\"}]}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"解釋：呢一個 \",[\"$\",\"code\",null,{\"children\":\"List\"}],\" 既 variable 只能夠接受 list of \",[\"$\",\"code\",null,{\"children\":\"Number\"}],\" 或者 list of \",[\"$\",\"code\",null,{\"children\":\"extends Number\"}],\" 既 class。下面既都可以：\"]}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"className\":\"language-java\",\"children\":\"List\u003c? extends Number\u003e nums;\\r\\nnums = new ArrayList\u003cNumber\u003e();\\r\\nnums = new ArrayList\u003cInteger\u003e();\\r\\nnums = new ArrayList\u003cDouble\u003e();\\n\"}]}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"需要注意既係，因為唔知個 \",[\"$\",\"code\",null,{\"children\":\"List\"}],\" 係幾 specific 既 generic type，\",[\"$\",\"code\",null,{\"children\":\"List\u003c? extends Number\u003e\"}],\" 可以 assign \",[\"$\",\"code\",null,{\"children\":\"List\u003cNumber\u003e\"}],\"、\",[\"$\",\"code\",null,{\"children\":\"List\u003cInteger\u003e\"}],\"，甚至 list of \",[\"$\",\"code\",null,{\"children\":\"Integer\"}],\" 既 subclass（自定義或者 3rd party library 裡面提供既）既 object，而如果 assign 既係 \",[\"$\",\"code\",null,{\"children\":\"List\u003cInteger\u003e\"}],\" 既 object，理論上係唔應該畀 \",[\"$\",\"code\",null,{\"children\":\"add()\"}],\" 一個 \",[\"$\",\"code\",null,{\"children\":\"Integer\"}],\" 以外既 element，所以 compiler 穩陣起見，就喺 compile time 唔畀我地 \",[\"$\",\"code\",null,{\"children\":\"add()\"}],\" 任何 element（除左乜野 type 都唔係既 \",[\"$\",\"code\",null,{\"children\":\"null\"}],\"）：\"]}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"className\":\"language-java\",\"children\":\"List\u003c? extends Number\u003e nums = new ArrayList\u003c\u003e();\\r\\nnums.add(null);\\r\\nnums.add(1); // compilation error\\n\"}]}],\"\\n\",[\"$\",\"hr\",null,{}],\"\\n\",[\"$\",\"h2\",null,{\"children\":\"2.4 Lower bounded wildcard generic type\"}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"className\":\"language-java\",\"children\":\"List\u003c? super Number\u003e nums = new ArrayList\u003c\u003e();\\n\"}]}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"解釋：呢一個 \",[\"$\",\"code\",null,{\"children\":\"List\"}],\" 既 variable 只能夠接受 list of \",[\"$\",\"code\",null,{\"children\":\"Number\"}],\" 或者 list of \",[\"$\",\"code\",null,{\"children\":\"Number\"}],\" 既 superclass。下面既都可以：\"]}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"className\":\"language-java\",\"children\":\"List\u003c? super Number\u003e nums;\\r\\nnums = new ArrayList\u003cNumber\u003e();\\r\\nnums = new ArrayList\u003cObject\u003e();\\n\"}]}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"需要注意既係，lower bounded wildcard 同 upper bounded wildcard 唔同，因為知道個 \",[\"$\",\"code\",null,{\"children\":\"List\"}],\" 唔會比 \",[\"$\",\"code\",null,{\"children\":\"List\u003cNumber\u003e\"}],\" 更 specific，可以 assign \",[\"$\",\"code\",null,{\"children\":\"List\u003cNumber\u003e\"}],\" 或者 \",[\"$\",\"code\",null,{\"children\":\"List\u003cObject\u003e\"}],\" 既 object 都得，如果 assign 既係 \",[\"$\",\"code\",null,{\"children\":\"List\u003cNumber\u003e\"}],\" 既 object，係可以 \",[\"$\",\"code\",null,{\"children\":\"add()\"}],\" 任何 \",[\"$\",\"code\",null,{\"children\":\"Number\"}],\" 或者 \",[\"$\",\"code\",null,{\"children\":\"extends Number\"}],\" 既 object，而如果 assign 既係 \",[\"$\",\"code\",null,{\"children\":\"List\u003cObject\u003e\"}],\" 既 object 既話更加係 \",[\"$\",\"code\",null,{\"children\":\"add()\"}],\" 乜野 object 都可以，所以 lower bounded wildcard 係畀我地 \",[\"$\",\"code\",null,{\"children\":\"add()\"}],\" element，但 \",[\"$\",\"code\",null,{\"children\":\"List\u003c? super Number\u003e\"}],\" 只限 \",[\"$\",\"code\",null,{\"children\":\"add()\"}],\" 到 \",[\"$\",\"code\",null,{\"children\":\"Number\"}],\" 或者 \",[\"$\",\"code\",null,{\"children\":\"extends Number\"}],\" 既 object，以及乜野 type 都唔係既 \",[\"$\",\"code\",null,{\"children\":\"null\"}],\"。\"]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"咁樣寫係冇問題：\"}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"className\":\"language-java\",\"children\":\"List\u003c? super Number\u003e nums = new ArrayList\u003c\u003e();\\r\\nnums.add(null);\\r\\nnums.add(new Number() { /* add unimplemented methods */ }); // anonymous class\\r\\nnums.add(1);\\r\\nnums.add(1.5D);\\n\"}]}],\"\\n\",[\"$\",\"hr\",null,{}],\"\\n\",[\"$\",\"h1\",null,{\"children\":\"3 Covariance 問題\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"因為 generic type 可以有繼承，即係我地可以寫 \",[\"$\",\"code\",null,{\"children\":\"class Sub extends Super\"}],\"，咁即係話我地可以有 \",[\"$\",\"code\",null,{\"children\":\"List\u003cSuper\u003e\"}],\" 同 \",[\"$\",\"code\",null,{\"children\":\"List\u003cSub\u003e\"}],\"，咁到底兩者既 variables 同 objects 係咪互相相容（in terms of polymorphism）？呢個就係 covariance 問題。\"]}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"註：除左 \",[\"$\",\"code\",null,{\"children\":\"extends\"}],\"，covariance 既規則對 \",[\"$\",\"code\",null,{\"children\":\"implements\"}],\"（interface）都一樣適用。\"]}],\"\\n\",[\"$\",\"hr\",null,{}],\"\\n\",[\"$\",\"h1\",null,{\"children\":\"4 Covariance 規則\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"到底 \",[\"$\",\"code\",null,{\"children\":\"Clazz\u003cT\u003e\"}],\" 可以 assign 返乜野 type 既 object？\"]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"假設我地有以下既自定義 classes：\"}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"className\":\"language-java\",\"children\":\"class Wrapper\u003cT\u003e {\\r\\n    public void foo(T obj) {}\\r\\n}\\r\\nclass SubWrapper\u003cT\u003e extends Wrapper\u003cT\u003e {}\\r\\n\\r\\nclass Super {}\\r\\nclass Sub extends Super {}\\n\"}]}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"如果係特定 generic type，例如 \",[\"$\",\"code\",null,{\"children\":\"Wrapper\u003cSuper\u003e\"}],\"，特定左 generic type 係 \",[\"$\",\"code\",null,{\"children\":\"Super\"}],\"，咁只能 assign 同樣特定 generic type 既 \",[\"$\",\"code\",null,{\"children\":\"Wrapper\"}],\" 或者 \",[\"$\",\"code\",null,{\"children\":\"Wrapper\"}],\" 既 subclass 既 object：\"]}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"className\":\"language-java\",\"children\":\"Wrapper\u003cSuper\u003e wrapper;\\r\\nwrapper = new Wrapper\u003cSuper\u003e();\\r\\nwrapper = new SubWrapper\u003cSuper\u003e();\\r\\n\\r\\nwrapper.foo(null);\\r\\nwrapper.foo(new Super());\\r\\nwrapper.foo(new Sub());\\r\\n\\r\\n// 唔可以用特定 generic type 既 subclass 做個 generic type\\r\\nwrapper = new Wrapper\u003cSub\u003e(); // compilation error\\r\\nwrapper = new SubWrapper\u003cSub\u003e(); // compilation error\\n\"}]}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"如果係 upper bounded wildcard，例如 \",[\"$\",\"code\",null,{\"children\":\"Wrapper\u003c? extends Super\u003e\"}],\"，咁可以 assign 相同既 generic type 或者佢既 subclass 既 \",[\"$\",\"code\",null,{\"children\":\"Wrapper\"}],\" 或者 \",[\"$\",\"code\",null,{\"children\":\"Wrapper\"}],\" 既 subclass 既 object：\"]}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"className\":\"language-java\",\"children\":\"Wrapper\u003c? extends Super\u003e wrapper;\\r\\nwrapper = new Wrapper\u003cSuper\u003e();\\r\\nwrapper = new SubWrapper\u003cSuper\u003e();\\r\\nwrapper = new Wrapper\u003cSub\u003e();\\r\\nwrapper = new SubWrapper\u003cSub\u003e();\\r\\n\\r\\nwrapper.foo(null);\\r\\n\\r\\n// 唔可以 call 任何 parameter 有 T 既 method\\r\\nwrapper.foo(new Super()); // compilation error\\r\\nwrapper.foo(new Sub()); // compilation error\\n\"}]}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"如果係 lower bounded wildcard，例如 \",[\"$\",\"code\",null,{\"children\":\"Wrapper\u003c? super Super\u003e\"}],\"，咁可以 assign 相同既 generic type 或者佢既 superclass 既 \",[\"$\",\"code\",null,{\"children\":\"Wrapper\"}],\" 或者 \",[\"$\",\"code\",null,{\"children\":\"Wrapper\"}],\" 既 subclass 既 object：\"]}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"className\":\"language-java\",\"children\":\"Wrapper\u003c? super Super\u003e wrapper;\\r\\nwrapper = new Wrapper\u003cSuper\u003e();\\r\\nwrapper = new SubWrapper\u003cSuper\u003e();\\r\\nwrapper = new Wrapper\u003cObject\u003e();\\r\\nwrapper = new SubWrapper\u003cObject\u003e();\\r\\n\\r\\nwrapper.foo(null);\\r\\nwrapper.foo(new Super());\\r\\nwrapper.foo(new Sub());\\n\"}]}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"如果係 wildcard，例如 \",[\"$\",\"code\",null,{\"children\":\"Wrapper\u003c?\u003e\"}],\"，咁可以 assign 任何 generic type 既 \",[\"$\",\"code\",null,{\"children\":\"Wrapper\"}],\" 或者 \",[\"$\",\"code\",null,{\"children\":\"Wrapper\"}],\" 既 subclass 既 object：\"]}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"className\":\"language-java\",\"children\":\"Wrapper\u003c?\u003e wrapper;\\r\\nwrapper = new Wrapper\u003cSuper\u003e();\\r\\nwrapper = new SubWrapper\u003cSuper\u003e();\\r\\nwrapper = new Wrapper\u003cSub\u003e();\\r\\nwrapper = new SubWrapper\u003cSub\u003e();\\r\\nwrapper = new Wrapper\u003cObject\u003e();\\r\\nwrapper = new SubWrapper\u003cObject\u003e();\\r\\n\\r\\nwrapper.foo(null);\\r\\n\\r\\n// 唔可以 call 任何 parameter 有 T 既 method\\r\\nwrapper.foo(new Super()); // compilation error\\r\\nwrapper.foo(new Sub()); // compilation error\\r\\nwrapper.foo(new Object()); // compilation error\\n\"}]}]],null,[\"$\",\"$L10\",null,{\"children\":\"$L11\"}]]}],{},null,false]},null,false]},null,false]},null,false]},null,false],[\"$\",\"$1\",\"h\",{\"children\":[null,[\"$\",\"$1\",\"6E8OPlldIxe6RDx6GaAi9\",{\"children\":[[\"$\",\"$L12\",null,{\"children\":\"$L13\"}],[\"$\",\"$L14\",null,{\"children\":\"$L15\"}],null]}]]}],false]],\"m\":\"$undefined\",\"G\":[\"$16\",\"$undefined\"],\"s\":false,\"S\":true}\n"])</script><script>self.__next_f.push([1,"15:[[\"$\",\"meta\",\"0\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}]]\n13:[[\"$\",\"meta\",\"0\",{\"charSet\":\"utf-8\"}],[\"$\",\"title\",\"1\",{\"children\":\"Michael Chung's e-Portfolio\"}],[\"$\",\"meta\",\"2\",{\"name\":\"description\",\"content\":\"Powered by Next.js and React\"}]]\n"])</script><script>self.__next_f.push([1,"11:null\n"])</script></body></html>