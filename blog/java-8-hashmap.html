<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="preload" as="image" href="blog/2021-09/java-8-hashmap/jdk-7-hashmap.png"/><link rel="preload" as="image" href="blog/2021-09/java-8-hashmap/jdk-8-hashmap.png"/><link rel="stylesheet" href="/e2-next/_next/static/css/d3df112486f97f47.css" data-precedence="next"/><link rel="stylesheet" href="/e2-next/_next/static/css/c3624a693ae5a0c4.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/e2-next/_next/static/chunks/webpack-f088da4552bcc253.js"/><script src="/e2-next/_next/static/chunks/4bd1b696-120f4d9c40d223dd.js" async=""></script><script src="/e2-next/_next/static/chunks/1517-c8d232d43a11224c.js" async=""></script><script src="/e2-next/_next/static/chunks/main-app-05c45cc8f30d6cea.js" async=""></script><script src="/e2-next/_next/static/chunks/7829-b7b9eb1dbe0d40e4.js" async=""></script><script src="/e2-next/_next/static/chunks/2153-45fd9844831c6348.js" async=""></script><script src="/e2-next/_next/static/chunks/app/layout-ea91c2d128ec48c2.js" async=""></script><script src="/e2-next/_next/static/chunks/app/page-c8b940db14fac9a0.js" async=""></script><title>Michael Chung&#x27;s e-Portfolio</title><meta name="description" content="Powered by Next.js and React"/><link href="https://fonts.googleapis.com/css2?family=Roboto:ital,wght@0,100;0,300;0,400;0,500;0,700;0,900;1,100;1,300;1,400;1,500;1,700;1,900&amp;display=swap" rel="stylesheet"/><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.6.0/css/all.min.css"/><script src="/e2-next/_next/static/chunks/polyfills-42372ed130431b0a.js" noModule=""></script></head><body><div class="vstack gap-5"><div class="text-center vstack gap-5"><div><code class="SiteHeader_name__cwQmL">Chung Cheuk Hang Michael</code><code class="SiteHeader_title__CCfvI">Java Web Developer</code></div><nav class="justify-content-center navbar navbar-expand-md navbar-dark"><button type="button" aria-label="Toggle navigation" class="navbar-toggler collapsed"><span class="navbar-toggler-icon"></span></button><div class="justify-content-center navbar-collapse collapse"><div class="justify-content-center navbar-nav nav-underline"><div class="nav-item"><a draggable="false" data-rr-ui-event-key="/" class="nav-link" href="/e2-next">Home</a></div><div class="nav-item"><a draggable="false" data-rr-ui-event-key="/work" class="nav-link" href="/e2-next/work">Work</a></div><div class="nav-item"><a draggable="false" data-rr-ui-event-key="/hobbyProjects" class="nav-link" href="/e2-next/hobbyProjects">Hobby projects</a></div><div class="nav-item"><a draggable="false" data-rr-ui-event-key="/personality" class="nav-link" href="/e2-next/personality">Personality</a></div><div class="nav-item"><a draggable="false" data-rr-ui-event-key="/blog" class="nav-link" href="/e2-next/blog">Blog</a></div></div></div></nav></div><h1>1 <code>HashMap</code> 內部結構</h1>
<p><code>HashMap</code> 係用一堆「buckets」（bucket array——<code>Node&lt;K, V&gt;[]</code>）黎存放 key-value entries。</p>
<table><thead><tr><th style="text-align:center">JDK 版本</th><th>Bucket 既 data structure</th></tr></thead><tbody><tr><td style="text-align:center">JDK 7</td><td>全部都係 linked lists</td></tr><tr><td style="text-align:center">JDK 8</td><td>可以係 linked list 或者 red-black tree（self-balancing binary tree）。</td></tr></tbody></table>
<p>用 bucket 既方式存放 key-value entries 可以提供最好既效能。</p>
<p><img src="blog/2021-09/java-8-hashmap/jdk-7-hashmap.png" alt=""/></p>
<p><img src="blog/2021-09/java-8-hashmap/jdk-8-hashmap.png" alt=""/></p>
<p>註：<code>HashSet</code> 既內部都係用一個 <code>HashMap</code> object 黎實現，令到 elements 唔會重複。</p>
<hr/>
<h1>2 <code>HashMap#put</code></h1>
<p><code>HashMap#put(K key, V value)</code> 既 behaviors：</p>
<ul>
<li>如果 <code>HashMap</code> 既 entries 裡面存在 <code>key</code> 既 key，就用 <code>value</code> 覆蓋果個 entry 既 value。</li>
<li>如果 <code>HashMap</code> 既 entries 裡面唔存在 <code>key</code> 既 key，就將 <code>key</code> 同 <code>value</code> 作為新既 entry 放入 <code>HashMap</code> 既 entries 之中。</li>
</ul>
<h2>2.1 流程</h2>
<p>以下係 Oracle JDK 既 <code>HashMap#put</code> 流程：</p>
<ol>
<li>對 <code>key</code> 進行 <code>Object#hashCode</code>，得出 hash（<code>null</code> key 既 hash 係 <code>0</code>）。</li>
<li>將 hash 以及 bit-shifted hash 進行 bitwise XOR 處理（<code>HashMap#hash</code>）。<!-- -->
<ul>
<li>令到除左 lower bits 之外，連 higher bits 都可以影響到 hash。</li>
<li>目的係萬一我地有啲寫得差既 <code>hashCode</code> method，呢一層既處理可以幫我地把關。</li>
<li>操作／處理<!-- -->
<ul>
<li>Bitwise XOR with bit-shifted hash（Oracle JDK 7、Oracle JDK 8）</li>
<li>Bitwise XOR with hash seed（Oracle JDK 7）</li>
</ul>
</li>
</ul>
</li>
<li>對 hash 進行 <code>&amp; (&lt;bucket size&gt; - 1)</code>，得出 bucket index（<code>null</code> key 既 bucket index 係 <code>0</code>）。<!-- -->
<ul>
<li>因為 bucket size 係 <code>2</code> 既次方數，所以結果同 <code>%</code> 一樣，但就會 efficient 啲。</li>
</ul>
</li>
<li>將 entry 覆蓋或者放入 <code>HashMap</code> 既特定 bucket<!-- -->
<ul>
<li>Bucket 既 data structure<!-- -->
<ul>
<li>如果 <code>HashMap</code> 既容量達到 <code>64</code> 而且 bucket 既 linked list 長度超過 <code>8</code>，就會 treeify 成 red-black tree，否則就繼續用 linked list。</li>
</ul>
</li>
<li>Collision<!-- -->
<ul>
<li>因為我地將無限值既 hash 轉化成 bucket index，咁就有 collision 既可能，bucket 有可能會存放多過 <code>1</code> 個 element。</li>
<li>Collision 情境<!-- -->
<ul>
<li>一樣既 hash，所以得出一樣既 bucket index。</li>
<li>唔一樣既 hash，但得出一樣既 bucket index。</li>
<li>唔一樣既 hash，而又得出唔一樣既 bucket index。</li>
</ul>
</li>
<li>處理 hash collision<!-- -->
<ul>
<li>如果 bucket index 所在既 bucket 未有 linked list／red-black tree，咁就 init 一個出黎，放呢個 entry 落去。</li>
<li>如果 bucket index 所在既 bucket 已經存在 linked list／red-black tree，咁就由頭到尾 traverse 成個 linked list／red-black tree。<!-- -->
<ol>
<li>對每個 element 既 key 進行 <code>Object#equals</code>，睇下 <code>key</code> 係咪已經喺呢個 <code>HashMap</code> 裡面存在。</li>
<li>如果一樣，就取代個 value；否則，整一個新既 linked list element，然後將 linked list 既最後一個 element（佢既 next）指向呢個新既 element。</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<hr/>
<h2>2.2 <code>Object#hashCode</code>、<code>Object#equals</code></h2>
<ul>
<li><code>Object#hashCode</code> 既 contract<!-- -->
<ul>
<li>如果 <code>equals</code> method 所用到既 data 冇改變過，咁不斷 call <code>hashCode</code> method 返回既結果喺同一個 runtime 裡面必須維持不變。</li>
<li>當 <code>2</code> 個 objects 通過 <code>equals</code> method 得出 <code>true</code> 既結果，咁佢地既 <code>hashCode</code> method 既結果就必須要返回一樣既 <code>int</code> value。</li>
<li>當 <code>2</code> 個 objects 通過 <code>equals</code> method 得出 <code>false</code> 既結果，佢地既 <code>hashCode</code> method 既結果係冇必要返回唔同既 <code>int</code> values，但唔同既 <code>int</code> values 有可以提升 hash table 既效能。</li>
</ul>
</li>
<li><code>Object#equals</code> 既 contract<!-- -->
<ul>
<li><code>o.equals(o)</code> 應該要返回 <code>true</code>。</li>
<li>只有當 <code>a.equals(b)</code> 既結果係 <code>true</code>，咁 <code>b.equals(a)</code> 既結果都應該要係 <code>true</code>。</li>
<li><code>a.equals(b)</code> 以及 <code>b.equals(c)</code> 既結果都係 <code>true</code> 既話，<code>a.equals(c)</code> 眉結果應該要係 <code>true</code>。</li>
<li>如果 <code>equals</code> method 所用到既 data 冇改變過，咁不斷 call <code>a.equals(b)</code> 返回既結果應該維持不變。</li>
<li><code>o.equals(null)</code> 既結果應該要係 <code>false</code>。</li>
<li>Override <code>equals</code> method 既同時係需要 override 埋 <code>hashCode</code> method。</li>
</ul>
</li>
</ul>
<table><thead><tr><th style="text-align:center">情境</th><th style="text-align:center"><code>Object#hashCode</code> 結果</th><th style="text-align:center"><code>Object#equals</code> 結果</th><th style="text-align:center">符合 contract？</th></tr></thead><tbody><tr><td style="text-align:center">①</td><td style="text-align:center">一樣</td><td style="text-align:center"><code>true</code></td><td style="text-align:center">✔</td></tr><tr><td style="text-align:center">②</td><td style="text-align:center">一樣</td><td style="text-align:center"><code>false</code></td><td style="text-align:center">✔</td></tr><tr><td style="text-align:center">③</td><td style="text-align:center">唔一樣</td><td style="text-align:center"><code>true</code></td><td style="text-align:center">✘</td></tr><tr><td style="text-align:center">④</td><td style="text-align:center">唔一樣</td><td style="text-align:center"><code>false</code></td><td style="text-align:center">✔</td></tr></tbody></table>
<p>情境 ② 既例子：</p>
<ul>
<li><code>&quot;Aa&quot;</code>、<code>&quot;BB&quot;</code>
<ul>
<li>Hash 同樣係 <code>2112</code>。<!-- -->
<ul>
<li><code>String#hashCode</code> 既計法將係每個 <code>char</code> 作為 <code>int</code> value 乘以 <code>31</code> 既 char index（右至左，<code>0</code>-based）咁多既次方。<!-- -->
<ul>
<li><code>A</code> 既 ASCII 係 <code>65</code>。</li>
<li><code>a</code> 既 ASCII 係 <code>97</code>。</li>
<li><code>B</code> 既 ASCII 係 <code>66</code>。</li>
<li><code>65 * 31 + 97</code> 等於 <code>66 * 31 + 66</code> 等於 <code>2112</code>。</li>
</ul>
</li>
</ul>
</li>
<li><code>String#equals</code> 既結果係 <code>false</code>。</li>
</ul>
</li>
</ul>
<hr/>
<h1>3 Resize</h1>
<p>Bucket 數量即係 <code>HashMap</code> 既容量大小，但係就算不斷增加資料量，實際數量可能永久都達唔到容量大小，因為當 <code>HashMap</code> 既實際數量超過容量大小既一定比率，就會自動擴大容量大小到先前既 <code>2</code> 倍。呢個比率叫 load factor，默認值係 <code>0.75</code>（i.e. <code>75%</code>）。</p>
<p>需要注意一點，JDK 7 同 JDK 8 唔同，而唔同之處於 JDK 7 唔係只睇 load factor，所以好容易令到個 <code>HashMap</code> 既實際數量接近 <code>100%</code>，甚至可能令實際數量超越容量。</p>
<ul>
<li>如果用 <code>HashMap</code> 既 no-arg constructor，咁默認就會有 <code>16</code> 個 buckets（<code>DEFAULT_INITIAL_CAPACITY</code>）。</li>
<li>如果用 <code>HashMap</code> 既 <code>new HashMap&lt;&gt;(int initialCapacity)</code> constructor 或者 <code>new HashMap&lt;&gt;(int initialCapacity, float loadFactor)</code> constructor，咁 bucket 數量就會係不少於 <code>initialCapacity</code> 而最接近 <code>2</code> 既次方數既一個數字（e.g. <code>3</code> 就會得出 <code>4</code>，而 <code>10</code> 就會得出 <code>16</code>）。</li>
</ul>
<h2>3.1 JDK 7 流程</h2>
<p>JDK 7 既 <code>HashMap#put</code> 會 call <code>HashMap#addEntry</code>，然後根據條件 resize <code>HashMap</code>。而 Oracle JDK 7 既條件係 <code>(size &gt;= threshold) &amp;&amp; (null != table[bucketIndex])</code>：</p>
<ul>
<li>新增呢個 entry 之前，實際數量達到容量既 load factor</li>
<li>當前既 bucket 有 linked list（出現 collision）</li>
</ul>
<p>基於以上條件，喺 Oracle JDK 7，一個容量係 <code>16</code> 既 <code>HashMap</code> 理論上最多係可以存放到 <code>27</code> 個 entries（<code>12 + 15</code>——某個 bucket <code>12</code>，新增最後一個 entry 果時唔超過 <code>16 * 0.75 = 12</code>，而其他 buckets 各 <code>1</code>）；而 OpenJDK 7 就唔存在第 <code>2</code> 個條件，所以就唔會出現咁既情況。</p>
<p><code>HashMap#resize(int newCapacity)</code> method：</p>
<ol>
<li>建立一個全新既 bucket array，容量係舊既 <code>2</code> 倍。</li>
<li>將本來既 bucket array 既所有 entries 抄過去新既 bucket array（<code>HashMap#transfer(Entry[] newTable)</code> method）。<!-- -->
<ol>
<li>對所有 bucket 既 linked list<!-- -->
<ol>
<li>由 linked list 第 <code>1</code> 個 element 開始至到最後一個 element<!-- -->
<ol>
<li>對 entry 既 hash 進行 <code>&amp; (&lt;bucket size&gt; - 1)</code>，得出新既 bucket index</li>
<li>將 entry 放喺新 bucket 既頭部，佢會（佢既 next）指向現有既 entry（如果未有就 <code>null</code>）。</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<p>註：Bucket 既 linked list 如果有多過 <code>1</code> 個 element（next 唔係 <code>null</code>），喺 resize 完之後，linked list elements 既次序將會調轉曬（雖然唔太重要）。</p>
<hr/>
<h2>3.2 JDK 8 流程</h2>
<p><code>HashMap#resize()</code> method：</p>
<ol>
<li>建立一個全新既 bucket array，容量係舊既 <code>2</code> 倍。</li>
<li>將本來既 bucket array 既所有 entries 抄過去新既 bucket array。<!-- -->
<ol>
<li>對所有舊 buckets<!-- -->
<ul>
<li>如果係 linked list<!-- -->
<ol>
<li>由 linked list 第 <code>1</code> 個 element 開始至到最後一個 element<!-- -->
<ol>
<li>對 entry 既 hash 進行 <code>&amp; &lt;old bucket size&gt;</code>
<ul>
<li>如果結果係 <code>0</code>（即係屬於前半部分，屬於舊既 bucket indexes）<!-- -->
<ol>
<li>將 entry 放喺新 linked list 既尾部（借助 <code>loHead</code>、<code>loTail</code>）。如果已經有 entry，現有 entry（佢既 next）會指向呢個 entry。</li>
</ol>
</li>
<li>如果結果唔係 <code>0</code>（即係屬於後半部分，屬於新增既 bucket indexes）<!-- -->
<ol>
<li>將 entry 放喺新 linked list 既尾部（借助 <code>hiHead</code>、<code>hiTail</code>）。如果已經有 entry，現有 entry（佢既 next）會指向呢個 entry。</li>
</ol>
</li>
</ul>
</li>
<li>將新 buckets 指向 <code>loHead</code>、<code>hiHead</code>
<ul>
<li>屬於新 buckets 前半部分既果一個 linked list 就會係 <code>loHead</code>（<code>newTab[j] = loHead;</code>）。</li>
<li>屬於新 buckets 後半部分既果一個 linked list 就會係 <code>hiHead</code>（<code>newTab[j + oldCap] = hiHead;</code>）。</li>
</ul>
</li>
</ol>
</li>
</ol>
</li>
<li>如果係 red-black tree<!-- -->
<ol>
<li>同處理 linked list 既方式相似，最後 <code>loHead</code>、<code>hiHead</code> 會 <code>treeify</code> 成 red-black trees。</li>
</ol>
</li>
</ul>
</li>
</ol>
</li>
</ol>
<p>註：<code>loHead</code>、<code>loTail</code>、<code>hiHead</code>、<code>hiTail</code> 解決左 JDK 7 resize 之後所有 buckets 既 linked lists 如果有多個 elements 既情況下次序調轉曬既問題。</p>
<hr/>
<h2>3.3 建立避免 resize 既 <code>HashMap</code></h2>
<p>假如我地而家有已知數量既資料，而且係一個好大既數值，令到我地唔可以唔考慮效能。我地想建立一個 <code>HashMap</code> 然後 call <code>HashMap#put</code> 或者 <code>HashMap#putAll</code> 去存放呢啲資料入去，我地會有以下既考慮（適用於 Oracle JDK 8）：</p>
<table><thead><tr><th>方法</th><th>考慮</th></tr></thead><tbody><tr><td><code>new HashMap&lt;&gt;()</code></td><td>最唔推薦，因為如果資料數量好大，就需要由 <code>16</code>、<code>32</code>、<code>64</code> 咁一直 resize 上去，直到資料數量唔多過容量既 <code>75%</code>。</td></tr><tr><td><code>new HashMap&lt;&gt;(int initialCapacity)</code></td><td>可以用，但需要計算容量，確保資料數量係容量既 <code>75%</code> 或以下，否則會觸發 resize。例子：如果己知數量係 <code>16</code>，呢個 constructor 會建立一個容量係 <code>16</code> 既 <code>HashMap</code>，但當我地 <code>HashMap#put</code> 第 <code>13</code> 筆資料既時候，<code>HashMap</code> 就會 resize。</td></tr><tr><td><code>new HashMap&lt;&gt;(int initialCapacity, float loadFactor)</code></td><td>最好，因為可以 set load factor 係 <code>1</code>，即係 <code>new HashMap&lt;&gt;(size, 1)</code>。只有當容量唔夠，<code>HashMap</code> 先會 resize。</td></tr><tr><td>Guava 既 <code>Maps#newHashMapWithExpectedSize(int expectedSize)</code></td><td>可以用，但要注意佢既算式係 <code>(int) ((float) expectedSize / 0.75F + 1.0F)</code>，呢個 <code>+ 1.0F</code> 有可能會令到容量係真正需要既 <code>2</code> 倍。例子：如果己知數量係 <code>12</code>，呢個 method 會計到 <code>17</code>，從而令 <code>HashMap</code> 建立一個容量係 <code>32</code> 既 <code>HashMap</code>，而唔係容量係 <code>16</code>（唔會 resize 既最小容量）既 <code>HashMap</code>。</td></tr></tbody></table>
<p>註：</p>
<ul>
<li>理論上，如果出現過多既 collisions，以上既做法都唔可以保證 <code>HashMap</code> 唔會 resize。</li>
<li>實際上，資料本身帶有隨機性，而只要我地寫好啲 <code>hashCode</code> method，唔好令到 collision 咁容易發生就得。</li>
</ul>
<hr/>
<h1>4 筆記</h1>
<h2>4.1 內部運作</h2>
<ul>
<li><code>HashMap#put</code> 係用 <code>&amp; (&lt;bucket size&gt; - 1)</code>
<ul>
<li>目的係要知道 key 屬於邊一個 bucket index，所以就需要知道係 <code>0</code> 至 <code>&lt;bucket size&gt; - 1</code> 邊一個。</li>
</ul>
</li>
<li>JDK 8 既 <code>HashMap#resize</code> 係用 <code>&amp; &lt;old bucket size&gt;</code>
<ul>
<li>目的係要知道現有既某個 bucket 既每一個 entry 喺新既 bucket array 裡面屬於前半部分（舊既 bucket indexes）定係後半部分（新既 bucket indexes），所以就需要知道新增既 bit 係 <code>0</code> 定係 <code>1</code>。</li>
<li>新增既 bit 就係舊 bucket size 既二進制數字既 <code>1</code> 字果個位。</li>
<li>想知道一個二進制數字對象特定既 bits 係 <code>0</code> 定係 <code>1</code>，就要對佢進行 bit masking 操作。<!-- -->
<ol>
<li>需要用一個二進制數字作為 mask——只有想要既 bits 係 <code>1</code> 而其他唔想要既 bits 係 <code>0</code> 既二進制數字。</li>
<li>用呢個 mask 對二進制數字對象進行 bitwise AND（<code>&amp;</code>）操作。</li>
<li>而對舊 bucket index 既二進制數字進行 bit masking 所得出既結果只有 <code>2</code> 個。<!-- -->
<ul>
<li>所有 bits 都係 <code>0</code>（亦即係 <code>0</code>）</li>
<li>第 <code>1</code> 個 bit 係 <code>1</code>，其他 bits 係 <code>0</code>（亦即係舊 bucket index）</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
<li>因為 bucket size 一定係 <code>2</code> 既次方數，所以佢既二進制一定係 <code>1</code> 後面有 <code>N</code> 個 <code>0</code>。</li>
<li>例子：容量由 <code>16</code> resize 成 <code>32</code>
<ul>
<li>舊 <code>HashMap</code>
<ul>
<li>舊 bucket size <code>16</code> 既二進制係 <code>10000</code>。</li>
<li>舊 bucket size <code>16</code> - <code>1</code> 既二進制係 <code>1111</code>。</li>
</ul>
</li>
<li>新 <code>HashMap</code>
<ul>
<li>新 bucket size <code>32</code> 既二進制係 <code>100000</code>。</li>
<li>新 bucket size <code>32</code> - <code>1</code> 既二進制係 <code>11111</code>。</li>
</ul>
</li>
<li>新增既 bit 係指 <code>10000</code> 既 <code>1</code>（<code>2^4</code>）。<!-- -->
<ul>
<li>舊 <code>HashMap</code> 最大既 bucket index <code>1111</code> + <code>1</code> = <code>10000</code>——第 <code>1</code> 個新增既 bucket index。</li>
<li><code>10000</code> 開始直至 <code>11111</code> 都係新增既 bucket indexes。</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr/>
<h2>4.2 測試用代碼</h2>
<p>以下既代碼可以幫我地了解 Java 幾時會 resize 我地既 <code>HashMap</code>，以及 bucket 既分佈。</p>
<p><code>HashMapTest.java</code>：</p>
<pre><code class="language-java">public class HashMapTest {

    public static void main(String[] args) {

        final int cap = 16;
        final int size = 28;

        final Map&lt;Foo, Integer&gt; map = new HashMap&lt;&gt;(cap);

        for (int i=0; i&lt;size; i++) {
            map.put(new Foo(i), i);
            HashMapDebugUtils.printMap(map);
        }
    }
}
</code></pre>
<p><code>HashMapDebugUtils.java</code>：</p>
<pre><code class="language-java">public final class HashMapDebugUtils {
    private static Field nextField;

    static {
        try {
            final Class&lt;?&gt; entryClass = Class.forName(&quot;java.util.HashMap$Entry&quot;);
            nextField = entryClass.getDeclaredField(&quot;next&quot;);
            nextField.setAccessible(true);
        } catch (Exception e) {
            try {
                final Class&lt;?&gt; entryClass = Class.forName(&quot;java.util.HashMap$Node&quot;);
                nextField = entryClass.getDeclaredField(&quot;next&quot;);
                nextField.setAccessible(true);
            } catch (Exception ex) {
                ex.printStackTrace();
            }
        }
    }

    private HashMapDebugUtils() {}

    public static void printMap(Map&lt;?, ?&gt; map) {
        try {
            final Class&lt;?&gt; mapType = map.getClass();
            final Field tableField = mapType.getDeclaredField(&quot;table&quot;);
            tableField.setAccessible(true);

            final Object[] bucketArr = (Object[]) tableField.get(map);
            final int capacity = bucketArr.length;

            System.out.printf(&quot;Capacity: %5d&quot;, capacity);
            System.out.printf(&quot;%5s|%5s&quot;, &quot; &quot;, &quot; &quot;);
            System.out.printf(&quot;Size: %5d&quot;, map.size());
            printBuckets(bucketArr);
            System.out.println();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    private static void printBuckets(final Object[] bucketArr) throws Exception {

        System.out.printf(&quot;%5s|%5s&quot;, &quot; &quot;, &quot; &quot;);
        System.out.printf(&quot;Buckets: &quot;);

        for (int i=0; i&lt;bucketArr.length; i++) {
            printBucket(i, bucketArr[i]);

            if (i&lt;bucketArr.length-1) {
                System.out.print(&quot; | &quot;);
            }
        }
    }

    private static void printBucket(int index, Object entry) throws Exception {

        if (entry==null) {
            System.out.printf(&quot;[%d]:  . &quot;, index);
            return;
        }

        final boolean isRedBlackTree = &quot;java.util.HashMap$TreeNode&quot;.equals(entry.getClass().getName());

        int count = 0;
        do {
            count++;
            entry = nextField.get(entry);
        } while (entry!=null);

        System.out.printf(&quot;[%d]: %2d&quot;, index, count);
        System.out.print(isRedBlackTree ? &quot;t&quot; : &quot; &quot;);
    }
}
</code></pre>
<p><code>Foo.java</code>（作為自定義 map key，所以 immutable）：</p>
<pre><code class="language-java">public final class Foo {
    private final int val;

    public Foo(int val) {
        this.val = val;
    }

    @Override
    public int hashCode() {
        return Math.max(0, val-11);
    }

    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (!(obj instanceof Foo)) return false;
        Foo other = (Foo) obj;
        return val == other.val;
    }
}
</code></pre>
<h3>4.2.1 Oracle JDK 7 既測試結果</h3>
<p>執行程式之後，我地可以睇到：</p>
<ul>
<li>當容量係 <code>16</code> 既情況下，實際數量係有機會去到 <code>27</code>。</li>
<li>當新增第 <code>28</code> 個 entry 既時候，容量先至由 <code>16</code> 擴大到 <code>32</code>。</li>
</ul>
<p>Console output：</p>
<pre><code class="language-plaintext">Capacity:    16     |     Size:     1
Capacity:    16     |     Size:     2
Capacity:    16     |     Size:     3
Capacity:    16     |     Size:     4
Capacity:    16     |     Size:     5
Capacity:    16     |     Size:     6
Capacity:    16     |     Size:     7
Capacity:    16     |     Size:     8
Capacity:    16     |     Size:     9
Capacity:    16     |     Size:    10
Capacity:    16     |     Size:    11
Capacity:    16     |     Size:    12
Capacity:    16     |     Size:    13
Capacity:    16     |     Size:    14
Capacity:    16     |     Size:    15
Capacity:    16     |     Size:    16
Capacity:    16     |     Size:    17
Capacity:    16     |     Size:    18
Capacity:    16     |     Size:    19
Capacity:    16     |     Size:    20
Capacity:    16     |     Size:    21
Capacity:    16     |     Size:    22
Capacity:    16     |     Size:    23
Capacity:    16     |     Size:    24
Capacity:    16     |     Size:    25
Capacity:    16     |     Size:    26
Capacity:    16     |     Size:    27
Capacity:    32     |     Size:    28
</code></pre>
<hr/>
<h3>4.2.2 Oracle JDK 8 既測試結果</h3>
<p>先 uncomment <code>printBuckets(bucketArr);</code> 再執行程式，我地可以睇到：</p>
<ul>
<li>當實際數量去到 <code>9</code> 而舊容量係 <code>16</code>（多過 <code>TREEIFY_THRESHOLD</code> 既 <code>8</code> 但係容量小過 <code>MIN_TREEIFY_CAPACITY</code> 既 <code>64</code>），容量會由 <code>16</code> 擴大到 <code>32</code>。</li>
<li>當實際數量去到 <code>10</code> 而舊容量係 <code>32</code>（多過 <code>TREEIFY_THRESHOLD</code> 既 <code>8</code> 但係容量小過 <code>MIN_TREEIFY_CAPACITY</code> 既 <code>64</code>），容量會由 <code>32</code> 擴大到 <code>64</code>。</li>
<li>當實際數量去到 <code>11</code> 而舊容量係 <code>64</code>（多過 <code>TREEIFY_THRESHOLD</code> 既 <code>8</code> 而且容量達到 <code>MIN_TREEIFY_CAPACITY</code> 既 <code>64</code>），bucket 會由 linked list treeify 成 red-black tree。</li>
</ul>
<p>Console output（省略左部分 bucket 分佈）：</p>
<pre><code class="language-plaintext">Capacity:    16     |     Size:     1     |     Buckets: [0]:  1
Capacity:    16     |     Size:     2     |     Buckets: [0]:  2
Capacity:    16     |     Size:     3     |     Buckets: [0]:  3
Capacity:    16     |     Size:     4     |     Buckets: [0]:  4
Capacity:    16     |     Size:     5     |     Buckets: [0]:  5
Capacity:    16     |     Size:     6     |     Buckets: [0]:  6
Capacity:    16     |     Size:     7     |     Buckets: [0]:  7
Capacity:    16     |     Size:     8     |     Buckets: [0]:  8
Capacity:    32     |     Size:     9     |     Buckets: [0]:  9
Capacity:    64     |     Size:    10     |     Buckets: [0]: 10
Capacity:    64     |     Size:    11     |     Buckets: [0]: 11t
Capacity:    64     |     Size:    12     |     Buckets: [0]: 12t
Capacity:    64     |     Size:    13     |     Buckets: [0]: 12t
Capacity:    64     |     Size:    14     |     Buckets: [0]: 12t
Capacity:    64     |     Size:    15     |     Buckets: [0]: 12t
Capacity:    64     |     Size:    16     |     Buckets: [0]: 12t
Capacity:    64     |     Size:    17     |     Buckets: [0]: 12t
Capacity:    64     |     Size:    18     |     Buckets: [0]: 12t
Capacity:    64     |     Size:    19     |     Buckets: [0]: 12t
Capacity:    64     |     Size:    20     |     Buckets: [0]: 12t
Capacity:    64     |     Size:    21     |     Buckets: [0]: 12t
Capacity:    64     |     Size:    22     |     Buckets: [0]: 12t
Capacity:    64     |     Size:    23     |     Buckets: [0]: 12t
Capacity:    64     |     Size:    24     |     Buckets: [0]: 12t
Capacity:    64     |     Size:    25     |     Buckets: [0]: 12t
Capacity:    64     |     Size:    26     |     Buckets: [0]: 12t
Capacity:    64     |     Size:    27     |     Buckets: [0]: 12t
Capacity:    64     |     Size:    28     |     Buckets: [0]: 12t
</code></pre>
<hr/>
<h2>4.3 Mutable key 既問題</h2>
<p>正因為 <code>HashMap</code> 係用 key object 既 hash 去計算出存放 entry 既 bucket index，如果 key object 既 hash 喺存放 entry 之後改變左，咁又會產生咩變化或者影響呢？我地可以做個簡單實驗。</p>
<p><code>Bar.java</code>（mutable）：</p>
<pre><code class="language-java">public class Bar {
    private int val;

    public Bar(int val) {
        this.val = val;
    }

    public void setVal(int val) {
        this.val = val;
    }

    @Override
    public int hashCode() {
        return val;
    }

    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (!(obj instanceof Bar)) return false;
        Bar other = (Bar) obj;
        System.out.println(&quot;Bar#equals: &quot; + (val==other.val) + &quot; (&quot; + val + &quot; = &quot; + other.val + &quot;)&quot;);
        return val == other.val;
    }
}
</code></pre>
<p><code>HashMapWithMutableElementTest.java</code>：</p>
<pre><code class="language-java">public class HashMapWithMutableElementTest {

    public static void main(String[] args) throws Exception {

        final Bar bar = new Bar(1);

        final Map&lt;Bar, String&gt; map = new HashMap&lt;&gt;();
        map.put(bar, &quot;one&quot;);
        HashMapDebugUtils.printMap(map); // bucket [1]: 1 個 entry

        System.out.println(map.containsKey(new Bar(1))); // true

        bar.setVal(2);
        HashMapDebugUtils.printMap(map); // bucket [1]: 1 個 entry

        System.out.println(map.containsKey(new Bar(1))); // false
        System.out.println(map.containsKey(new Bar(2))); // false

        map.put(new Bar(2), &quot;two&quot;);
        HashMapDebugUtils.printMap(map); // bucket [1]: 1 個 entry | [2]: 1 個 entry

        System.out.println(map.remove(new Bar(1))); // null
        System.out.println(map.remove(new Bar(2))); // two
        HashMapDebugUtils.printMap(map); // bucket [1]: 1 個 entry

        final Map&lt;Bar, String&gt; newMap = new HashMap&lt;&gt;(map);
        HashMapDebugUtils.printMap(newMap); // bucket [0]: 1 個 entry
        System.out.println(newMap.containsKey(new Bar(2))); // true

        System.out.println(newMap.remove(new Bar(2))); // one
        HashMapDebugUtils.printMap(newMap); // bucket [0]: 1 個 entry
    }
}
</code></pre>
<p>解釋：</p>
<ul>
<li>我地既 <code>HashMap</code> 會用 mutable 既 <code>Bar</code> class 作為 key type。<!-- -->
<ul>
<li><code>Bar#hashCode</code> 會返回 <code>int</code> type 既 <code>val</code> field value。</li>
<li><code>Bar#equals</code> 會用 <code>val</code> field value 黎比較 object equality。</li>
</ul>
</li>
<li>測試流程（Oracle JDK 8）<!-- -->
<ol>
<li>將 key 係 <code>val: 1</code>、value 係 <code>one</code> 既 entry 放入 <code>HashMap</code>。<!-- -->
<ol>
<li>Hash 係 <code>1</code>，所以會放入 bucket <code>1</code>。</li>
<li>可以見到 bucket <code>1</code> 有 <code>1</code> 個 entry。</li>
</ol>
</li>
<li>用 <code>HashMap#containsKey</code> 測試下 <code>val: 1</code> 既 key 係咪存在喺 <code>HashMap</code> 裡面。<!-- -->
<ol>
<li>Hash 係 <code>1</code>，所以會喺 bucket <code>1</code> 裡面搵。</li>
<li>Bucket <code>1</code> 既 linked list 只有 <code>1</code> 個 element，而對呢個 element 既 <code>Bar#equals</code> 返回 <code>true</code>（<code>val</code> <code>1</code> 等於 <code>1</code>）。</li>
<li>結果係存在。</li>
</ol>
</li>
<li>將呢個 <code>Bar</code> object 既 <code>val</code> 改成 <code>2</code>。</li>
<li>用 <code>HashMap#containsKey</code> 測試下 <code>val: 1</code> 既 key 係咪存在喺 <code>HashMap</code> 裡面。<!-- -->
<ol>
<li>Hash 係 <code>1</code>，所以會喺 bucket <code>1</code> 裡面搵。</li>
<li>Bucket <code>1</code> 既 linked list 只有 <code>1</code> 個 element，但係對呢個 element 既 <code>Bar#equals</code> 返回 <code>false</code>（<code>val</code> <code>1</code> 唔等於 <code>2</code>）。</li>
<li>結果係唔存在。</li>
</ol>
</li>
<li>用 <code>HashMap#containsKey</code> 測試下 <code>val: 2</code> 既 key 係咪存在喺 <code>HashMap</code> 裡面。<!-- -->
<ol>
<li>Hash 係 <code>2</code>，所以會喺 bucket <code>2</code> 裡面搵。</li>
<li>Bucket <code>2</code> 係空既。</li>
<li>結果係唔存在。</li>
</ol>
</li>
<li>將 key 係 <code>val: 2</code>、value 係 <code>two</code> 既 entry 放入 <code>HashMap</code>。<!-- -->
<ol>
<li>Hash 係 <code>2</code>，所以會放入 bucket <code>2</code>。</li>
<li>可以見到 bucket <code>1</code> 以及 bucket <code>2</code> 各有 <code>1</code> 個 entry。</li>
</ol>
</li>
<li>用 <code>HashMap#remove</code> 測試下刪除 key 係 <code>val: 1</code> 既 entry。<!-- -->
<ol>
<li>Hash 係 <code>1</code>，所以會喺 bucket <code>1</code> 裡面搵。</li>
<li>Bucket <code>1</code> 既 linked list 只有 <code>1</code> 個 element，但係對呢個 element 既 <code>Bar#equals</code> 返回 <code>false</code>（<code>val</code> <code>1</code> 唔等於 <code>2</code>）。</li>
<li>冇刪除到 entry，所以返回 <code>null</code>。</li>
</ol>
</li>
<li>用 <code>HashMap#remove</code> 測試下刪除 key 係 <code>val: 2</code> 既 entry。<!-- -->
<ol>
<li>Hash 係 <code>2</code>，所以會喺 bucket <code>2</code> 裡面搵。</li>
<li>Bucket <code>2</code> 既 linked list 只有 <code>1</code> 個 element，而對呢個 element 既 <code>Bar#equals</code> 返回 <code>true</code>（<code>val</code> <code>2</code> 等於 <code>2</code>）。</li>
<li>因為刪除左 entry，所以返回 entry 既 value <code>two</code>。</li>
<li>可以見到 bucket <code>1</code> 有 <code>1</code> 個 entry，而 bucket <code>2</code> 就再冇 entry。</li>
</ol>
</li>
<li>用 <code>new HashMap&lt;&gt;(Map&lt;? extends K,? extends V&gt; m)</code> constructor 重新建立一個 <code>HashMap</code>，argument 用上述既 <code>HashMap</code>。<!-- -->
<ol>
<li>可以見到只有 <code>2</code> 個 buckets——Bucket <code>0</code> 有 <code>1</code> 個 entry，而 bucket <code>1</code> 就冇 entry。</li>
</ol>
</li>
<li>用 <code>HashMap#containsKey</code> 測試下 <code>val: 2</code> 既 key 係咪存在喺新既 <code>HashMap</code> 裡面。<!-- -->
<ol>
<li>Hash 係 <code>2</code>，所以會喺 bucket <code>0</code> 裡面搵。</li>
<li>Bucket <code>0</code> 既 linked list 只有 <code>1</code> 個 element，而對呢個 element 既 <code>Bar#equals</code> 返回 <code>true</code>（<code>val</code> <code>2</code> 等於 <code>2</code>）。</li>
<li>結果係存在。</li>
</ol>
</li>
</ol>
</li>
</ul>
<p>因為 <code>HashSet</code> 既內部都係用一個 <code>HashMap</code> object 黎實現，令到 elements 唔會重複，所以如果啲 elements 既 class 係 mutable，都會有一樣既問題。</p>
<p><code>HashSetWithMutableElementTest.java</code>：</p>
<pre><code class="language-java">public class HashSetWithMutableElementTest {

    public static void main(String[] args) throws Exception {

        final Bar bar = new Bar(1);

        final Set&lt;Bar&gt; set = new HashSet&lt;&gt;();
        set.add(bar);

        System.out.println(set.contains(new Bar(1))); // true

        bar.setVal(2);

        System.out.println(set.contains(new Bar(1))); // false
        System.out.println(set.contains(new Bar(2))); // false

        set.add(new Bar(2));

        System.out.println(set.remove(new Bar(1))); // false
        System.out.println(set.remove(new Bar(2))); // true

        final Set&lt;Bar&gt; newMap = new HashSet&lt;&gt;(set);
        System.out.println(newMap.contains(new Bar(2))); // true
        System.out.println(newMap.remove(new Bar(2))); // true
    }
}
</code></pre>
<hr/>
<h1>5 參考資料</h1>
<ul>
<li><a href="https://javamana.com/2021/02/20210202162541893w.html">HashMap - JDK 7 vs JDK 8</a></li>
<li><a href="https://elsef.com/2019/11/11/JDK1.8%E4%B8%ADHashMap%E7%9A%84resize%E6%93%8D%E4%BD%9C/">JDK 1.8 中 HashMap 的 resize 優化</a></li>
<li><a href="https://segmentfault.com/a/1190000015812438">深入理解 HashMap（四）：關鍵源碼逐行分析之 resize 擴容</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/369808654">你給 HashMap 初始化了容量，卻讓性能變加更糟？</a></li>
<li><a href="https://stackoverflow.com/questions/2414117/explanation-of-hashmaphashint-method">StackOverflow - Explanation of HashMap#hash(int) method</a></li>
<li><a href="https://github.com/openjdk/jdk/blob/jdk7-b147/jdk/src/share/classes/java/util/HashMap.java">OpenJDK 7 - <code>HashMap.java</code> source code</a></li>
<li><a href="https://github.com/openjdk/jdk/blob/jdk8-b120/jdk/src/share/classes/java/util/HashMap.java">OpenJDK 8 - <code>HashMap.java</code> source code</a></li>
<li><a href="https://github.com/openjdk/jdk/blob/jdk8-b120/jdk/src/share/classes/java/util/HashSet.java">OpenJDK 8 - <code>HashSet.java</code> source code</a></li>
</ul><hr/><div class="vstack gap-3"><div class="text-center container"><div class="justify-content-center g-3 row row-cols-md-3 row-cols-sm-2 row-cols-1"><div class="col"><a target="_blank" rel="external nofollow noopener noreferrer" class="SiteFooter_contact-item__2JRRr card" href="tel:+85263301333"><div class="card-body"><div class="card-title h5"><i class="fa-solid fa-phone" style="color:#009688"></i></div><p class="text-muted card-text">6330 1333<!-- --> </p></div></a></div><div class="col"><a target="_blank" rel="external nofollow noopener noreferrer" class="SiteFooter_contact-item__2JRRr card" href="mailto:michaelboyboy@gmail.com"><div class="card-body"><div class="card-title h5"><i class="fa-solid fa-envelope" style="color:#f44336"></i></div><p class="text-muted card-text">michaelboyboy@gmail.com<!-- --> </p></div></a></div><div class="col"><a target="_blank" rel="external nofollow noopener noreferrer" class="SiteFooter_contact-item__2JRRr card" href="https://www.linkedin.com/in/mickchung"><div class="card-body"><div class="card-title h5"><i class="fa-brands fa-linkedin" style="color:#2196f3"></i></div><p class="text-muted card-text">www.linkedin.com/in/mickchung<!-- --> </p></div></a></div></div></div></div></div><script src="/e2-next/_next/static/chunks/webpack-f088da4552bcc253.js" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0])</script><script>self.__next_f.push([1,"1:\"$Sreact.fragment\"\n2:I[8287,[\"7829\",\"static/chunks/7829-b7b9eb1dbe0d40e4.js\",\"2153\",\"static/chunks/2153-45fd9844831c6348.js\",\"7177\",\"static/chunks/app/layout-ea91c2d128ec48c2.js\"],\"default\"]\n3:I[3339,[\"7829\",\"static/chunks/7829-b7b9eb1dbe0d40e4.js\",\"8974\",\"static/chunks/app/page-c8b940db14fac9a0.js\"],\"default\"]\n4:I[1367,[\"7829\",\"static/chunks/7829-b7b9eb1dbe0d40e4.js\",\"2153\",\"static/chunks/2153-45fd9844831c6348.js\",\"7177\",\"static/chunks/app/layout-ea91c2d128ec48c2.js\"],\"default\"]\n5:I[5244,[],\"\"]\n6:I[3866,[],\"\"]\n7:I[4798,[\"7829\",\"static/chunks/7829-b7b9eb1dbe0d40e4.js\",\"8974\",\"static/chunks/app/page-c8b940db14fac9a0.js\"],\"default\"]\n8:I[6121,[\"7829\",\"static/chunks/7829-b7b9eb1dbe0d40e4.js\",\"8974\",\"static/chunks/app/page-c8b940db14fac9a0.js\"],\"default\"]\n9:I[3667,[\"7829\",\"static/chunks/7829-b7b9eb1dbe0d40e4.js\",\"8974\",\"static/chunks/app/page-c8b940db14fac9a0.js\"],\"default\"]\na:I[8407,[\"7829\",\"static/chunks/7829-b7b9eb1dbe0d40e4.js\",\"2153\",\"static/chunks/2153-45fd9844831c6348.js\",\"7177\",\"static/chunks/app/layout-ea91c2d128ec48c2.js\"],\"default\"]\nb:I[8173,[\"7829\",\"static/chunks/7829-b7b9eb1dbe0d40e4.js\",\"8974\",\"static/chunks/app/page-c8b940db14fac9a0.js\"],\"\"]\nc:I[3197,[\"7829\",\"static/chunks/7829-b7b9eb1dbe0d40e4.js\",\"2153\",\"static/chunks/2153-45fd9844831c6348.js\",\"7177\",\"static/chunks/app/layout-ea91c2d128ec48c2.js\"],\"default\"]\nd:I[7933,[\"7829\",\"static/chunks/7829-b7b9eb1dbe0d40e4.js\",\"2153\",\"static/chunks/2153-45fd9844831c6348.js\",\"7177\",\"static/chunks/app/layout-ea91c2d128ec48c2.js\"],\"default\"]\ne:I[3800,[\"7829\",\"static/chunks/7829-b7b9eb1dbe0d40e4.js\",\"2153\",\"static/chunks/2153-45fd9844831c6348.js\",\"7177\",\"static/chunks/app/layout-ea91c2d128ec48c2.js\"],\"default\"]\n13:I[6213,[],\"OutletBoundary\"]\n15:I[6213,[],\"MetadataBoundary\"]\n17:I[6213,[],\"ViewportBoundary\"]\n19:I[4835,[],\"\"]\n:HL[\"/e2-next/_next/static/css/d3df112486f97f47.css\",\"style\"]\n:HL[\"/e2-next/_next/static/css/c3624a693ae5a0c4.css\",\"style\"]\nf:T927,"])</script><script>self.__next_f.push([1,"public final class HashMapDebugUtils {\r\n    private static Field nextField;\r\n\r\n    static {\r\n        try {\r\n            final Class\u003c?\u003e entryClass = Class.forName(\"java.util.HashMap$Entry\");\r\n            nextField = entryClass.getDeclaredField(\"next\");\r\n            nextField.setAccessible(true);\r\n        } catch (Exception e) {\r\n            try {\r\n                final Class\u003c?\u003e entryClass = Class.forName(\"java.util.HashMap$Node\");\r\n                nextField = entryClass.getDeclaredField(\"next\");\r\n                nextField.setAccessible(true);\r\n            } catch (Exception ex) {\r\n                ex.printStackTrace();\r\n            }\r\n        }\r\n    }\r\n\r\n    private HashMapDebugUtils() {}\r\n\r\n    public static void printMap(Map\u003c?, ?\u003e map) {\r\n        try {\r\n            final Class\u003c?\u003e mapType = map.getClass();\r\n            final Field tableField = mapType.getDeclaredField(\"table\");\r\n            tableField.setAccessible(true);\r\n\r\n            final Object[] bucketArr = (Object[]) tableField.get(map);\r\n            final int capacity = bucketArr.length;\r\n\r\n            System.out.printf(\"Capacity: %5d\", capacity);\r\n            System.out.printf(\"%5s|%5s\", \" \", \" \");\r\n            System.out.printf(\"Size: %5d\", map.size());\r\n            printBuckets(bucketArr);\r\n            System.out.println();\r\n        } catch (Exception e) {\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n\r\n    private static void printBuckets(final Object[] bucketArr) throws Exception {\r\n\r\n        System.out.printf(\"%5s|%5s\", \" \", \" \");\r\n        System.out.printf(\"Buckets: \");\r\n\r\n        for (int i=0; i\u003cbucketArr.length; i++) {\r\n            printBucket(i, bucketArr[i]);\r\n\r\n            if (i\u003cbucketArr.length-1) {\r\n                System.out.print(\" | \");\r\n            }\r\n        }\r\n    }\r\n\r\n    private static void printBucket(int index, Object entry) throws Exception {\r\n\r\n        if (entry==null) {\r\n            System.out.printf(\"[%d]:  . \", index);\r\n            return;\r\n        }\r\n\r\n        final boolean isRedBlackTree = \"java.util.HashMap$TreeNode\".equals(entry.getClass().getName());\r\n\r\n        int count = 0;\r\n        do {\r\n            count++;\r\n            entry = nextField.get(entry);\r\n        } while (entry!=null);\r\n\r\n        System.out.printf(\"[%d]: %2d\", index, count);\r\n        System.out.print(isRedBlackTree ? \"t\" : \" \");\r\n    }\r\n}\n"])</script><script>self.__next_f.push([1,"10:T443,Capacity:    16     |     Size:     1\r\nCapacity:    16     |     Size:     2\r\nCapacity:    16     |     Size:     3\r\nCapacity:    16     |     Size:     4\r\nCapacity:    16     |     Size:     5\r\nCapacity:    16     |     Size:     6\r\nCapacity:    16     |     Size:     7\r\nCapacity:    16     |     Size:     8\r\nCapacity:    16     |     Size:     9\r\nCapacity:    16     |     Size:    10\r\nCapacity:    16     |     Size:    11\r\nCapacity:    16     |     Size:    12\r\nCapacity:    16     |     Size:    13\r\nCapacity:    16     |     Size:    14\r\nCapacity:    16     |     Size:    15\r\nCapacity:    16     |     Size:    16\r\nCapacity:    16     |     Size:    17\r\nCapacity:    16     |     Size:    18\r\nCapacity:    16     |     Size:    19\r\nCapacity:    16     |     Size:    20\r\nCapacity:    16     |     Size:    21\r\nCapacity:    16     |     Size:    22\r\nCapacity:    16     |     Size:    23\r\nCapacity:    16     |     Size:    24\r\nCapacity:    16     |     Size:    25\r\nCapacity:    16     |     Size:    26\r\nCapacity:    16     |     Size:    27\r\nCapacity:    32     |     Size:    28\n11:T749,Capacity:    16     |     Size:     1     |     Buckets: [0]:  1\r\nCapacity:    16     |     Size:     2     |     Buckets: [0]:  2\r\nCapacity:    16     |     Size:     3     |     Buckets: [0]:  3\r\nCapacity:    16     |     Size:     4     |     Buckets: [0]:  4\r\nCapacity:    16     |     Size:     5     |     Buckets: [0]:  5\r\nCapacity:    16     |     Size:     6     |     Buckets: [0]:  6\r\nCapacity:    16     |     Size:     7     |     Buckets: [0]:  7\r\nCapacity:    16     |     Size:     8     |     Buckets: [0]:  8\r\nCapacity:    32     |     Size:     9     |     Buckets: [0]:  9\r\nCapacity:    64     |     Size:    10     |     Buckets: [0]: 10\r\nCapacity:    64     |     Size:    11     |     Buckets: [0]: 11t\r\nCapacity:    64     |     Size:    12     |     Buckets: [0]: 12t\r\nCapacity:    64     |     Size:    13     |     Buckets: [0]: 12t\r\nCapacity:    64     |     Size:    14     |     Buckets: [0]: 12t\r\nCapacity:    "])</script><script>self.__next_f.push([1,"64     |     Size:    15     |     Buckets: [0]: 12t\r\nCapacity:    64     |     Size:    16     |     Buckets: [0]: 12t\r\nCapacity:    64     |     Size:    17     |     Buckets: [0]: 12t\r\nCapacity:    64     |     Size:    18     |     Buckets: [0]: 12t\r\nCapacity:    64     |     Size:    19     |     Buckets: [0]: 12t\r\nCapacity:    64     |     Size:    20     |     Buckets: [0]: 12t\r\nCapacity:    64     |     Size:    21     |     Buckets: [0]: 12t\r\nCapacity:    64     |     Size:    22     |     Buckets: [0]: 12t\r\nCapacity:    64     |     Size:    23     |     Buckets: [0]: 12t\r\nCapacity:    64     |     Size:    24     |     Buckets: [0]: 12t\r\nCapacity:    64     |     Size:    25     |     Buckets: [0]: 12t\r\nCapacity:    64     |     Size:    26     |     Buckets: [0]: 12t\r\nCapacity:    64     |     Size:    27     |     Buckets: [0]: 12t\r\nCapacity:    64     |     Size:    28     |     Buckets: [0]: 12t\n12:T4fa,public class HashMapWithMutableElementTest {\r\n\r\n    public static void main(String[] args) throws Exception {\r\n\r\n        final Bar bar = new Bar(1);\r\n\r\n        final Map\u003cBar, String\u003e map = new HashMap\u003c\u003e();\r\n        map.put(bar, \"one\");\r\n        HashMapDebugUtils.printMap(map); // bucket [1]: 1 個 entry\r\n\r\n        System.out.println(map.containsKey(new Bar(1))); // true\r\n\r\n        bar.setVal(2);\r\n        HashMapDebugUtils.printMap(map); // bucket [1]: 1 個 entry\r\n\r\n        System.out.println(map.containsKey(new Bar(1))); // false\r\n        System.out.println(map.containsKey(new Bar(2))); // false\r\n\r\n        map.put(new Bar(2), \"two\");\r\n        HashMapDebugUtils.printMap(map); // bucket [1]: 1 個 entry | [2]: 1 個 entry\r\n\r\n        System.out.println(map.remove(new Bar(1))); // null\r\n        System.out.println(map.remove(new Bar(2))); // two\r\n        HashMapDebugUtils.printMap(map); // bucket [1]: 1 個 entry\r\n\r\n        final Map\u003cBar, String\u003e newMap = new HashMap\u003c\u003e(map);\r\n        HashMapDebugUtils.printMap(newMap); // bucket [0]: 1 個 entry\r\n        System.out.println(newMap.containsKey(new Bar(2))"])</script><script>self.__next_f.push([1,"); // true\r\n\r\n        System.out.println(newMap.remove(new Bar(2))); // one\r\n        HashMapDebugUtils.printMap(newMap); // bucket [0]: 1 個 entry\r\n    }\r\n}\n"])</script><script>self.__next_f.push([1,"0:{\"P\":null,\"b\":\"wfZ4FdS4ntgGvzjeKJhfw\",\"p\":\"/e2-next\",\"c\":[\"\",\"blog\",\"java-8-hashmap\"],\"i\":false,\"f\":[[[\"\",{\"children\":[\"blog\",{\"children\":[\"(2021-09)\",{\"children\":[\"java-8-hashmap\",{\"children\":[\"__PAGE__\",{}]}]}]}]},\"$undefined\",\"$undefined\",true],[\"\",[\"$\",\"$1\",\"c\",{\"children\":[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/e2-next/_next/static/css/d3df112486f97f47.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\",\"nonce\":\"$undefined\"}],[\"$\",\"link\",\"1\",{\"rel\":\"stylesheet\",\"href\":\"/e2-next/_next/static/css/c3624a693ae5a0c4.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\",\"nonce\":\"$undefined\"}]],[\"$\",\"html\",null,{\"lang\":\"en\",\"children\":[[\"$\",\"head\",null,{\"children\":[[\"$\",\"link\",null,{\"href\":\"https://fonts.googleapis.com/css2?family=Roboto:ital,wght@0,100;0,300;0,400;0,500;0,700;0,900;1,100;1,300;1,400;1,500;1,700;1,900\u0026display=swap\",\"rel\":\"stylesheet\"}],[\"$\",\"link\",null,{\"rel\":\"stylesheet\",\"href\":\"https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.6.0/css/all.min.css\"}]]}],[\"$\",\"body\",null,{\"children\":[\"$\",\"$L2\",null,{\"children\":[\"$\",\"$L3\",null,{\"gap\":5,\"children\":[[\"$\",\"$L3\",null,{\"gap\":5,\"className\":\"text-center\",\"children\":[[\"$\",\"div\",null,{\"children\":[[\"$\",\"code\",null,{\"className\":\"SiteHeader_name__cwQmL\",\"children\":\"Chung Cheuk Hang Michael\"}],[\"$\",\"code\",null,{\"className\":\"SiteHeader_title__CCfvI\",\"children\":\"Java Web Developer\"}]]}],[\"$\",\"$L4\",null,{}]]}],[\"$\",\"$L5\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L6\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[[],[[\"$\",\"title\",null,{\"children\":\"404: This page could not be found.\"}],[\"$\",\"div\",null,{\"style\":{\"fontFamily\":\"system-ui,\\\"Segoe UI\\\",Roboto,Helvetica,Arial,sans-serif,\\\"Apple Color Emoji\\\",\\\"Segoe UI Emoji\\\"\",\"height\":\"100vh\",\"textAlign\":\"center\",\"display\":\"flex\",\"flexDirection\":\"column\",\"alignItems\":\"center\",\"justifyContent\":\"center\"},\"children\":[\"$\",\"div\",null,{\"children\":[[\"$\",\"style\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}\"}}],[\"$\",\"h1\",null,{\"className\":\"next-error-h1\",\"style\":{\"display\":\"inline-block\",\"margin\":\"0 20px 0 0\",\"padding\":\"0 23px 0 0\",\"fontSize\":24,\"fontWeight\":500,\"verticalAlign\":\"top\",\"lineHeight\":\"49px\"},\"children\":404}],[\"$\",\"div\",null,{\"style\":{\"display\":\"inline-block\"},\"children\":[\"$\",\"h2\",null,{\"style\":{\"fontSize\":14,\"fontWeight\":400,\"lineHeight\":\"49px\",\"margin\":0},\"children\":\"This page could not be found.\"}]}]]}]}]]],\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}],[\"$\",\"hr\",null,{}],[\"$\",\"$L3\",null,{\"gap\":3,\"children\":[\"$\",\"$L7\",null,{\"className\":\"text-center\",\"children\":[\"$\",\"$L8\",null,{\"xs\":1,\"sm\":2,\"md\":3,\"className\":\"justify-content-center g-3\",\"children\":[[\"$\",\"$L9\",\"0\",{\"children\":[\"$\",\"$La\",null,{\"as\":\"$b\",\"href\":\"tel:+85263301333\",\"target\":\"_blank\",\"rel\":\"external nofollow noopener noreferrer\",\"className\":\"SiteFooter_contact-item__2JRRr\",\"children\":[\"$\",\"$Lc\",null,{\"children\":[[\"$\",\"$Ld\",null,{\"children\":[\"$\",\"i\",null,{\"className\":\"fa-solid fa-phone\",\"style\":{\"color\":\"#009688\"}}]}],[\"$\",\"$Le\",null,{\"className\":\"text-muted\",\"children\":[\"6330 1333\",\" \"]}]]}]}]}],[\"$\",\"$L9\",\"1\",{\"children\":[\"$\",\"$La\",null,{\"as\":\"$b\",\"href\":\"mailto:michaelboyboy@gmail.com\",\"target\":\"_blank\",\"rel\":\"external nofollow noopener noreferrer\",\"className\":\"SiteFooter_contact-item__2JRRr\",\"children\":[\"$\",\"$Lc\",null,{\"children\":[[\"$\",\"$Ld\",null,{\"children\":[\"$\",\"i\",null,{\"className\":\"fa-solid fa-envelope\",\"style\":{\"color\":\"#f44336\"}}]}],[\"$\",\"$Le\",null,{\"className\":\"text-muted\",\"children\":[\"michaelboyboy@gmail.com\",\" \"]}]]}]}]}],[\"$\",\"$L9\",\"2\",{\"children\":[\"$\",\"$La\",null,{\"as\":\"$b\",\"href\":\"https://www.linkedin.com/in/mickchung\",\"target\":\"_blank\",\"rel\":\"external nofollow noopener noreferrer\",\"className\":\"SiteFooter_contact-item__2JRRr\",\"children\":[\"$\",\"$Lc\",null,{\"children\":[[\"$\",\"$Ld\",null,{\"children\":[\"$\",\"i\",null,{\"className\":\"fa-brands fa-linkedin\",\"style\":{\"color\":\"#2196f3\"}}]}],[\"$\",\"$Le\",null,{\"className\":\"text-muted\",\"children\":[\"www.linkedin.com/in/mickchung\",\" \"]}]]}]}]}]]}]}]}]]}]}]}]]}]]}],{\"children\":[\"blog\",[\"$\",\"$1\",\"c\",{\"children\":[null,[\"$\",\"$L5\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"blog\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L6\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]]}],{\"children\":[\"(2021-09)\",[\"$\",\"$1\",\"c\",{\"children\":[null,[\"$\",\"$L5\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"blog\",\"children\",\"(2021-09)\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L6\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]]}],{\"children\":[\"java-8-hashmap\",[\"$\",\"$1\",\"c\",{\"children\":[null,[\"$\",\"$L5\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"blog\",\"children\",\"(2021-09)\",\"children\",\"java-8-hashmap\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L6\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]]}],{\"children\":[\"__PAGE__\",[\"$\",\"$1\",\"c\",{\"children\":[[[\"$\",\"h1\",null,{\"children\":[\"1 \",[\"$\",\"code\",null,{\"children\":\"HashMap\"}],\" 內部結構\"]}],\"\\n\",[\"$\",\"p\",null,{\"children\":[[\"$\",\"code\",null,{\"children\":\"HashMap\"}],\" 係用一堆「buckets」（bucket array——\",[\"$\",\"code\",null,{\"children\":\"Node\u003cK, V\u003e[]\"}],\"）黎存放 key-value entries。\"]}],\"\\n\",[\"$\",\"table\",null,{\"children\":[[\"$\",\"thead\",null,{\"children\":[\"$\",\"tr\",null,{\"children\":[[\"$\",\"th\",null,{\"style\":{\"textAlign\":\"center\"},\"children\":\"JDK 版本\"}],[\"$\",\"th\",null,{\"children\":\"Bucket 既 data structure\"}]]}]}],[\"$\",\"tbody\",null,{\"children\":[[\"$\",\"tr\",null,{\"children\":[[\"$\",\"td\",null,{\"style\":{\"textAlign\":\"center\"},\"children\":\"JDK 7\"}],[\"$\",\"td\",null,{\"children\":\"全部都係 linked lists\"}]]}],[\"$\",\"tr\",null,{\"children\":[[\"$\",\"td\",null,{\"style\":{\"textAlign\":\"center\"},\"children\":\"JDK 8\"}],[\"$\",\"td\",null,{\"children\":\"可以係 linked list 或者 red-black tree（self-balancing binary tree）。\"}]]}]]}]]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"用 bucket 既方式存放 key-value entries 可以提供最好既效能。\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"$\",\"img\",null,{\"src\":\"blog/2021-09/java-8-hashmap/jdk-7-hashmap.png\",\"alt\":\"\"}]}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"$\",\"img\",null,{\"src\":\"blog/2021-09/java-8-hashmap/jdk-8-hashmap.png\",\"alt\":\"\"}]}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"註：\",[\"$\",\"code\",null,{\"children\":\"HashSet\"}],\" 既內部都係用一個 \",[\"$\",\"code\",null,{\"children\":\"HashMap\"}],\" object 黎實現，令到 elements 唔會重複。\"]}],\"\\n\",[\"$\",\"hr\",null,{}],\"\\n\",[\"$\",\"h1\",null,{\"children\":[\"2 \",[\"$\",\"code\",null,{\"children\":\"HashMap#put\"}]]}],\"\\n\",[\"$\",\"p\",null,{\"children\":[[\"$\",\"code\",null,{\"children\":\"HashMap#put(K key, V value)\"}],\" 既 behaviors：\"]}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":[\"如果 \",[\"$\",\"code\",null,{\"children\":\"HashMap\"}],\" 既 entries 裡面存在 \",[\"$\",\"code\",null,{\"children\":\"key\"}],\" 既 key，就用 \",[\"$\",\"code\",null,{\"children\":\"value\"}],\" 覆蓋果個 entry 既 value。\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[\"如果 \",[\"$\",\"code\",null,{\"children\":\"HashMap\"}],\" 既 entries 裡面唔存在 \",[\"$\",\"code\",null,{\"children\":\"key\"}],\" 既 key，就將 \",[\"$\",\"code\",null,{\"children\":\"key\"}],\" 同 \",[\"$\",\"code\",null,{\"children\":\"value\"}],\" 作為新既 entry 放入 \",[\"$\",\"code\",null,{\"children\":\"HashMap\"}],\" 既 entries 之中。\"]}],\"\\n\"]}],\"\\n\",[\"$\",\"h2\",null,{\"children\":\"2.1 流程\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"以下係 Oracle JDK 既 \",[\"$\",\"code\",null,{\"children\":\"HashMap#put\"}],\" 流程：\"]}],\"\\n\",[\"$\",\"ol\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":[\"對 \",[\"$\",\"code\",null,{\"children\":\"key\"}],\" 進行 \",[\"$\",\"code\",null,{\"children\":\"Object#hashCode\"}],\"，得出 hash（\",[\"$\",\"code\",null,{\"children\":\"null\"}],\" key 既 hash 係 \",[\"$\",\"code\",null,{\"children\":\"0\"}],\"）。\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[\"將 hash 以及 bit-shifted hash 進行 bitwise XOR 處理（\",[\"$\",\"code\",null,{\"children\":\"HashMap#hash\"}],\"）。\",\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"令到除左 lower bits 之外，連 higher bits 都可以影響到 hash。\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":[\"目的係萬一我地有啲寫得差既 \",[\"$\",\"code\",null,{\"children\":\"hashCode\"}],\" method，呢一層既處理可以幫我地把關。\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[\"操作／處理\",\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"Bitwise XOR with bit-shifted hash（Oracle JDK 7、Oracle JDK 8）\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"Bitwise XOR with hash seed（Oracle JDK 7）\"}],\"\\n\"]}],\"\\n\"]}],\"\\n\"]}],\"\\n\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[\"對 hash 進行 \",[\"$\",\"code\",null,{\"children\":\"\u0026 (\u003cbucket size\u003e - 1)\"}],\"，得出 bucket index（\",[\"$\",\"code\",null,{\"children\":\"null\"}],\" key 既 bucket index 係 \",[\"$\",\"code\",null,{\"children\":\"0\"}],\"）。\",\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":[\"因為 bucket size 係 \",[\"$\",\"code\",null,{\"children\":\"2\"}],\" 既次方數，所以結果同 \",[\"$\",\"code\",null,{\"children\":\"%\"}],\" 一樣，但就會 efficient 啲。\"]}],\"\\n\"]}],\"\\n\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[\"將 entry 覆蓋或者放入 \",[\"$\",\"code\",null,{\"children\":\"HashMap\"}],\" 既特定 bucket\",\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":[\"Bucket 既 data structure\",\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":[\"如果 \",[\"$\",\"code\",null,{\"children\":\"HashMap\"}],\" 既容量達到 \",[\"$\",\"code\",null,{\"children\":\"64\"}],\" 而且 bucket 既 linked list 長度超過 \",[\"$\",\"code\",null,{\"children\":\"8\"}],\"，就會 treeify 成 red-black tree，否則就繼續用 linked list。\"]}],\"\\n\"]}],\"\\n\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[\"Collision\",\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":[\"因為我地將無限值既 hash 轉化成 bucket index，咁就有 collision 既可能，bucket 有可能會存放多過 \",[\"$\",\"code\",null,{\"children\":\"1\"}],\" 個 element。\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[\"Collision 情境\",\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"一樣既 hash，所以得出一樣既 bucket index。\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"唔一樣既 hash，但得出一樣既 bucket index。\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"唔一樣既 hash，而又得出唔一樣既 bucket index。\"}],\"\\n\"]}],\"\\n\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[\"處理 hash collision\",\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"如果 bucket index 所在既 bucket 未有 linked list／red-black tree，咁就 init 一個出黎，放呢個 entry 落去。\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":[\"如果 bucket index 所在既 bucket 已經存在 linked list／red-black tree，咁就由頭到尾 traverse 成個 linked list／red-black tree。\",\"\\n\",[\"$\",\"ol\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":[\"對每個 element 既 key 進行 \",[\"$\",\"code\",null,{\"children\":\"Object#equals\"}],\"，睇下 \",[\"$\",\"code\",null,{\"children\":\"key\"}],\" 係咪已經喺呢個 \",[\"$\",\"code\",null,{\"children\":\"HashMap\"}],\" 裡面存在。\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"如果一樣，就取代個 value；否則，整一個新既 linked list element，然後將 linked list 既最後一個 element（佢既 next）指向呢個新既 element。\"}],\"\\n\"]}],\"\\n\"]}],\"\\n\"]}],\"\\n\"]}],\"\\n\"]}],\"\\n\"]}],\"\\n\"]}],\"\\n\"]}],\"\\n\"]}],\"\\n\",[\"$\",\"hr\",null,{}],\"\\n\",[\"$\",\"h2\",null,{\"children\":[\"2.2 \",[\"$\",\"code\",null,{\"children\":\"Object#hashCode\"}],\"、\",[\"$\",\"code\",null,{\"children\":\"Object#equals\"}]]}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":[[\"$\",\"code\",null,{\"children\":\"Object#hashCode\"}],\" 既 contract\",\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":[\"如果 \",[\"$\",\"code\",null,{\"children\":\"equals\"}],\" method 所用到既 data 冇改變過，咁不斷 call \",[\"$\",\"code\",null,{\"children\":\"hashCode\"}],\" method 返回既結果喺同一個 runtime 裡面必須維持不變。\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[\"當 \",[\"$\",\"code\",null,{\"children\":\"2\"}],\" 個 objects 通過 \",[\"$\",\"code\",null,{\"children\":\"equals\"}],\" method 得出 \",[\"$\",\"code\",null,{\"children\":\"true\"}],\" 既結果，咁佢地既 \",[\"$\",\"code\",null,{\"children\":\"hashCode\"}],\" method 既結果就必須要返回一樣既 \",[\"$\",\"code\",null,{\"children\":\"int\"}],\" value。\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[\"當 \",[\"$\",\"code\",null,{\"children\":\"2\"}],\" 個 objects 通過 \",[\"$\",\"code\",null,{\"children\":\"equals\"}],\" method 得出 \",[\"$\",\"code\",null,{\"children\":\"false\"}],\" 既結果，佢地既 \",[\"$\",\"code\",null,{\"children\":\"hashCode\"}],\" method 既結果係冇必要返回唔同既 \",[\"$\",\"code\",null,{\"children\":\"int\"}],\" values，但唔同既 \",[\"$\",\"code\",null,{\"children\":\"int\"}],\" values 有可以提升 hash table 既效能。\"]}],\"\\n\"]}],\"\\n\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[[\"$\",\"code\",null,{\"children\":\"Object#equals\"}],\" 既 contract\",\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":[[\"$\",\"code\",null,{\"children\":\"o.equals(o)\"}],\" 應該要返回 \",[\"$\",\"code\",null,{\"children\":\"true\"}],\"。\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[\"只有當 \",[\"$\",\"code\",null,{\"children\":\"a.equals(b)\"}],\" 既結果係 \",[\"$\",\"code\",null,{\"children\":\"true\"}],\"，咁 \",[\"$\",\"code\",null,{\"children\":\"b.equals(a)\"}],\" 既結果都應該要係 \",[\"$\",\"code\",null,{\"children\":\"true\"}],\"。\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[[\"$\",\"code\",null,{\"children\":\"a.equals(b)\"}],\" 以及 \",[\"$\",\"code\",null,{\"children\":\"b.equals(c)\"}],\" 既結果都係 \",[\"$\",\"code\",null,{\"children\":\"true\"}],\" 既話，\",[\"$\",\"code\",null,{\"children\":\"a.equals(c)\"}],\" 眉結果應該要係 \",[\"$\",\"code\",null,{\"children\":\"true\"}],\"。\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[\"如果 \",[\"$\",\"code\",null,{\"children\":\"equals\"}],\" method 所用到既 data 冇改變過，咁不斷 call \",[\"$\",\"code\",null,{\"children\":\"a.equals(b)\"}],\" 返回既結果應該維持不變。\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[[\"$\",\"code\",null,{\"children\":\"o.equals(null)\"}],\" 既結果應該要係 \",[\"$\",\"code\",null,{\"children\":\"false\"}],\"。\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[\"Override \",[\"$\",\"code\",null,{\"children\":\"equals\"}],\" method 既同時係需要 override 埋 \",[\"$\",\"code\",null,{\"children\":\"hashCode\"}],\" method。\"]}],\"\\n\"]}],\"\\n\"]}],\"\\n\"]}],\"\\n\",[\"$\",\"table\",null,{\"children\":[[\"$\",\"thead\",null,{\"children\":[\"$\",\"tr\",null,{\"children\":[[\"$\",\"th\",null,{\"style\":{\"textAlign\":\"center\"},\"children\":\"情境\"}],[\"$\",\"th\",null,{\"style\":{\"textAlign\":\"center\"},\"children\":[[\"$\",\"code\",null,{\"children\":\"Object#hashCode\"}],\" 結果\"]}],[\"$\",\"th\",null,{\"style\":{\"textAlign\":\"center\"},\"children\":[[\"$\",\"code\",null,{\"children\":\"Object#equals\"}],\" 結果\"]}],[\"$\",\"th\",null,{\"style\":{\"textAlign\":\"center\"},\"children\":\"符合 contract？\"}]]}]}],[\"$\",\"tbody\",null,{\"children\":[[\"$\",\"tr\",null,{\"children\":[[\"$\",\"td\",null,{\"style\":{\"textAlign\":\"center\"},\"children\":\"①\"}],[\"$\",\"td\",null,{\"style\":{\"textAlign\":\"center\"},\"children\":\"一樣\"}],[\"$\",\"td\",null,{\"style\":{\"textAlign\":\"center\"},\"children\":[\"$\",\"code\",null,{\"children\":\"true\"}]}],[\"$\",\"td\",null,{\"style\":{\"textAlign\":\"center\"},\"children\":\"✔\"}]]}],[\"$\",\"tr\",null,{\"children\":[[\"$\",\"td\",null,{\"style\":{\"textAlign\":\"center\"},\"children\":\"②\"}],[\"$\",\"td\",null,{\"style\":{\"textAlign\":\"center\"},\"children\":\"一樣\"}],[\"$\",\"td\",null,{\"style\":{\"textAlign\":\"center\"},\"children\":[\"$\",\"code\",null,{\"children\":\"false\"}]}],[\"$\",\"td\",null,{\"style\":{\"textAlign\":\"center\"},\"children\":\"✔\"}]]}],[\"$\",\"tr\",null,{\"children\":[[\"$\",\"td\",null,{\"style\":{\"textAlign\":\"center\"},\"children\":\"③\"}],[\"$\",\"td\",null,{\"style\":{\"textAlign\":\"center\"},\"children\":\"唔一樣\"}],[\"$\",\"td\",null,{\"style\":{\"textAlign\":\"center\"},\"children\":[\"$\",\"code\",null,{\"children\":\"true\"}]}],[\"$\",\"td\",null,{\"style\":{\"textAlign\":\"center\"},\"children\":\"✘\"}]]}],[\"$\",\"tr\",null,{\"children\":[[\"$\",\"td\",null,{\"style\":{\"textAlign\":\"center\"},\"children\":\"④\"}],[\"$\",\"td\",null,{\"style\":{\"textAlign\":\"center\"},\"children\":\"唔一樣\"}],[\"$\",\"td\",null,{\"style\":{\"textAlign\":\"center\"},\"children\":[\"$\",\"code\",null,{\"children\":\"false\"}]}],[\"$\",\"td\",null,{\"style\":{\"textAlign\":\"center\"},\"children\":\"✔\"}]]}]]}]]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"情境 ② 既例子：\"}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":[[\"$\",\"code\",null,{\"children\":\"\\\"Aa\\\"\"}],\"、\",[\"$\",\"code\",null,{\"children\":\"\\\"BB\\\"\"}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":[\"Hash 同樣係 \",[\"$\",\"code\",null,{\"children\":\"2112\"}],\"。\",\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":[[\"$\",\"code\",null,{\"children\":\"String#hashCode\"}],\" 既計法將係每個 \",[\"$\",\"code\",null,{\"children\":\"char\"}],\" 作為 \",[\"$\",\"code\",null,{\"children\":\"int\"}],\" value 乘以 \",[\"$\",\"code\",null,{\"children\":\"31\"}],\" 既 char index（右至左，\",[\"$\",\"code\",null,{\"children\":\"0\"}],\"-based）咁多既次方。\",\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":[[\"$\",\"code\",null,{\"children\":\"A\"}],\" 既 ASCII 係 \",[\"$\",\"code\",null,{\"children\":\"65\"}],\"。\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[[\"$\",\"code\",null,{\"children\":\"a\"}],\" 既 ASCII 係 \",[\"$\",\"code\",null,{\"children\":\"97\"}],\"。\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[[\"$\",\"code\",null,{\"children\":\"B\"}],\" 既 ASCII 係 \",[\"$\",\"code\",null,{\"children\":\"66\"}],\"。\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[[\"$\",\"code\",null,{\"children\":\"65 * 31 + 97\"}],\" 等於 \",[\"$\",\"code\",null,{\"children\":\"66 * 31 + 66\"}],\" 等於 \",[\"$\",\"code\",null,{\"children\":\"2112\"}],\"。\"]}],\"\\n\"]}],\"\\n\"]}],\"\\n\"]}],\"\\n\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[[\"$\",\"code\",null,{\"children\":\"String#equals\"}],\" 既結果係 \",[\"$\",\"code\",null,{\"children\":\"false\"}],\"。\"]}],\"\\n\"]}],\"\\n\"]}],\"\\n\"]}],\"\\n\",[\"$\",\"hr\",null,{}],\"\\n\",[\"$\",\"h1\",null,{\"children\":\"3 Resize\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"Bucket 數量即係 \",[\"$\",\"code\",null,{\"children\":\"HashMap\"}],\" 既容量大小，但係就算不斷增加資料量，實際數量可能永久都達唔到容量大小，因為當 \",[\"$\",\"code\",null,{\"children\":\"HashMap\"}],\" 既實際數量超過容量大小既一定比率，就會自動擴大容量大小到先前既 \",[\"$\",\"code\",null,{\"children\":\"2\"}],\" 倍。呢個比率叫 load factor，默認值係 \",[\"$\",\"code\",null,{\"children\":\"0.75\"}],\"（i.e. \",[\"$\",\"code\",null,{\"children\":\"75%\"}],\"）。\"]}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"需要注意一點，JDK 7 同 JDK 8 唔同，而唔同之處於 JDK 7 唔係只睇 load factor，所以好容易令到個 \",[\"$\",\"code\",null,{\"children\":\"HashMap\"}],\" 既實際數量接近 \",[\"$\",\"code\",null,{\"children\":\"100%\"}],\"，甚至可能令實際數量超越容量。\"]}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":[\"如果用 \",[\"$\",\"code\",null,{\"children\":\"HashMap\"}],\" 既 no-arg constructor，咁默認就會有 \",[\"$\",\"code\",null,{\"children\":\"16\"}],\" 個 buckets（\",[\"$\",\"code\",null,{\"children\":\"DEFAULT_INITIAL_CAPACITY\"}],\"）。\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[\"如果用 \",[\"$\",\"code\",null,{\"children\":\"HashMap\"}],\" 既 \",[\"$\",\"code\",null,{\"children\":\"new HashMap\u003c\u003e(int initialCapacity)\"}],\" constructor 或者 \",[\"$\",\"code\",null,{\"children\":\"new HashMap\u003c\u003e(int initialCapacity, float loadFactor)\"}],\" constructor，咁 bucket 數量就會係不少於 \",[\"$\",\"code\",null,{\"children\":\"initialCapacity\"}],\" 而最接近 \",[\"$\",\"code\",null,{\"children\":\"2\"}],\" 既次方數既一個數字（e.g. \",[\"$\",\"code\",null,{\"children\":\"3\"}],\" 就會得出 \",[\"$\",\"code\",null,{\"children\":\"4\"}],\"，而 \",[\"$\",\"code\",null,{\"children\":\"10\"}],\" 就會得出 \",[\"$\",\"code\",null,{\"children\":\"16\"}],\"）。\"]}],\"\\n\"]}],\"\\n\",[\"$\",\"h2\",null,{\"children\":\"3.1 JDK 7 流程\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"JDK 7 既 \",[\"$\",\"code\",null,{\"children\":\"HashMap#put\"}],\" 會 call \",[\"$\",\"code\",null,{\"children\":\"HashMap#addEntry\"}],\"，然後根據條件 resize \",[\"$\",\"code\",null,{\"children\":\"HashMap\"}],\"。而 Oracle JDK 7 既條件係 \",[\"$\",\"code\",null,{\"children\":\"(size \u003e= threshold) \u0026\u0026 (null != table[bucketIndex])\"}],\"：\"]}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"新增呢個 entry 之前，實際數量達到容量既 load factor\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"當前既 bucket 有 linked list（出現 collision）\"}],\"\\n\"]}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"基於以上條件，喺 Oracle JDK 7，一個容量係 \",[\"$\",\"code\",null,{\"children\":\"16\"}],\" 既 \",[\"$\",\"code\",null,{\"children\":\"HashMap\"}],\" 理論上最多係可以存放到 \",[\"$\",\"code\",null,{\"children\":\"27\"}],\" 個 entries（\",[\"$\",\"code\",null,{\"children\":\"12 + 15\"}],\"——某個 bucket \",[\"$\",\"code\",null,{\"children\":\"12\"}],\"，新增最後一個 entry 果時唔超過 \",[\"$\",\"code\",null,{\"children\":\"16 * 0.75 = 12\"}],\"，而其他 buckets 各 \",[\"$\",\"code\",null,{\"children\":\"1\"}],\"）；而 OpenJDK 7 就唔存在第 \",[\"$\",\"code\",null,{\"children\":\"2\"}],\" 個條件，所以就唔會出現咁既情況。\"]}],\"\\n\",[\"$\",\"p\",null,{\"children\":[[\"$\",\"code\",null,{\"children\":\"HashMap#resize(int newCapacity)\"}],\" method：\"]}],\"\\n\",[\"$\",\"ol\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":[\"建立一個全新既 bucket array，容量係舊既 \",[\"$\",\"code\",null,{\"children\":\"2\"}],\" 倍。\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[\"將本來既 bucket array 既所有 entries 抄過去新既 bucket array（\",[\"$\",\"code\",null,{\"children\":\"HashMap#transfer(Entry[] newTable)\"}],\" method）。\",\"\\n\",[\"$\",\"ol\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":[\"對所有 bucket 既 linked list\",\"\\n\",[\"$\",\"ol\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":[\"由 linked list 第 \",[\"$\",\"code\",null,{\"children\":\"1\"}],\" 個 element 開始至到最後一個 element\",\"\\n\",[\"$\",\"ol\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":[\"對 entry 既 hash 進行 \",[\"$\",\"code\",null,{\"children\":\"\u0026 (\u003cbucket size\u003e - 1)\"}],\"，得出新既 bucket index\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[\"將 entry 放喺新 bucket 既頭部，佢會（佢既 next）指向現有既 entry（如果未有就 \",[\"$\",\"code\",null,{\"children\":\"null\"}],\"）。\"]}],\"\\n\"]}],\"\\n\"]}],\"\\n\"]}],\"\\n\"]}],\"\\n\"]}],\"\\n\"]}],\"\\n\"]}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"註：Bucket 既 linked list 如果有多過 \",[\"$\",\"code\",null,{\"children\":\"1\"}],\" 個 element（next 唔係 \",[\"$\",\"code\",null,{\"children\":\"null\"}],\"），喺 resize 完之後，linked list elements 既次序將會調轉曬（雖然唔太重要）。\"]}],\"\\n\",[\"$\",\"hr\",null,{}],\"\\n\",[\"$\",\"h2\",null,{\"children\":\"3.2 JDK 8 流程\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":[[\"$\",\"code\",null,{\"children\":\"HashMap#resize()\"}],\" method：\"]}],\"\\n\",[\"$\",\"ol\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":[\"建立一個全新既 bucket array，容量係舊既 \",[\"$\",\"code\",null,{\"children\":\"2\"}],\" 倍。\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[\"將本來既 bucket array 既所有 entries 抄過去新既 bucket array。\",\"\\n\",[\"$\",\"ol\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":[\"對所有舊 buckets\",\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":[\"如果係 linked list\",\"\\n\",[\"$\",\"ol\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":[\"由 linked list 第 \",[\"$\",\"code\",null,{\"children\":\"1\"}],\" 個 element 開始至到最後一個 element\",\"\\n\",[\"$\",\"ol\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":[\"對 entry 既 hash 進行 \",[\"$\",\"code\",null,{\"children\":\"\u0026 \u003cold bucket size\u003e\"}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":[\"如果結果係 \",[\"$\",\"code\",null,{\"children\":\"0\"}],\"（即係屬於前半部分，屬於舊既 bucket indexes）\",\"\\n\",[\"$\",\"ol\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":[\"將 entry 放喺新 linked list 既尾部（借助 \",[\"$\",\"code\",null,{\"children\":\"loHead\"}],\"、\",[\"$\",\"code\",null,{\"children\":\"loTail\"}],\"）。如果已經有 entry，現有 entry（佢既 next）會指向呢個 entry。\"]}],\"\\n\"]}],\"\\n\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[\"如果結果唔係 \",[\"$\",\"code\",null,{\"children\":\"0\"}],\"（即係屬於後半部分，屬於新增既 bucket indexes）\",\"\\n\",[\"$\",\"ol\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":[\"將 entry 放喺新 linked list 既尾部（借助 \",[\"$\",\"code\",null,{\"children\":\"hiHead\"}],\"、\",[\"$\",\"code\",null,{\"children\":\"hiTail\"}],\"）。如果已經有 entry，現有 entry（佢既 next）會指向呢個 entry。\"]}],\"\\n\"]}],\"\\n\"]}],\"\\n\"]}],\"\\n\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[\"將新 buckets 指向 \",[\"$\",\"code\",null,{\"children\":\"loHead\"}],\"、\",[\"$\",\"code\",null,{\"children\":\"hiHead\"}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":[\"屬於新 buckets 前半部分既果一個 linked list 就會係 \",[\"$\",\"code\",null,{\"children\":\"loHead\"}],\"（\",[\"$\",\"code\",null,{\"children\":\"newTab[j] = loHead;\"}],\"）。\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[\"屬於新 buckets 後半部分既果一個 linked list 就會係 \",[\"$\",\"code\",null,{\"children\":\"hiHead\"}],\"（\",[\"$\",\"code\",null,{\"children\":\"newTab[j + oldCap] = hiHead;\"}],\"）。\"]}],\"\\n\"]}],\"\\n\"]}],\"\\n\"]}],\"\\n\"]}],\"\\n\"]}],\"\\n\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[\"如果係 red-black tree\",\"\\n\",[\"$\",\"ol\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":[\"同處理 linked list 既方式相似，最後 \",[\"$\",\"code\",null,{\"children\":\"loHead\"}],\"、\",[\"$\",\"code\",null,{\"children\":\"hiHead\"}],\" 會 \",[\"$\",\"code\",null,{\"children\":\"treeify\"}],\" 成 red-black trees。\"]}],\"\\n\"]}],\"\\n\"]}],\"\\n\"]}],\"\\n\"]}],\"\\n\"]}],\"\\n\"]}],\"\\n\"]}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"註：\",[\"$\",\"code\",null,{\"children\":\"loHead\"}],\"、\",[\"$\",\"code\",null,{\"children\":\"loTail\"}],\"、\",[\"$\",\"code\",null,{\"children\":\"hiHead\"}],\"、\",[\"$\",\"code\",null,{\"children\":\"hiTail\"}],\" 解決左 JDK 7 resize 之後所有 buckets 既 linked lists 如果有多個 elements 既情況下次序調轉曬既問題。\"]}],\"\\n\",[\"$\",\"hr\",null,{}],\"\\n\",[\"$\",\"h2\",null,{\"children\":[\"3.3 建立避免 resize 既 \",[\"$\",\"code\",null,{\"children\":\"HashMap\"}]]}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"假如我地而家有已知數量既資料，而且係一個好大既數值，令到我地唔可以唔考慮效能。我地想建立一個 \",[\"$\",\"code\",null,{\"children\":\"HashMap\"}],\" 然後 call \",[\"$\",\"code\",null,{\"children\":\"HashMap#put\"}],\" 或者 \",[\"$\",\"code\",null,{\"children\":\"HashMap#putAll\"}],\" 去存放呢啲資料入去，我地會有以下既考慮（適用於 Oracle JDK 8）：\"]}],\"\\n\",[\"$\",\"table\",null,{\"children\":[[\"$\",\"thead\",null,{\"children\":[\"$\",\"tr\",null,{\"children\":[[\"$\",\"th\",null,{\"children\":\"方法\"}],[\"$\",\"th\",null,{\"children\":\"考慮\"}]]}]}],[\"$\",\"tbody\",null,{\"children\":[[\"$\",\"tr\",null,{\"children\":[[\"$\",\"td\",null,{\"children\":[\"$\",\"code\",null,{\"children\":\"new HashMap\u003c\u003e()\"}]}],[\"$\",\"td\",null,{\"children\":[\"最唔推薦，因為如果資料數量好大，就需要由 \",[\"$\",\"code\",null,{\"children\":\"16\"}],\"、\",[\"$\",\"code\",null,{\"children\":\"32\"}],\"、\",[\"$\",\"code\",null,{\"children\":\"64\"}],\" 咁一直 resize 上去，直到資料數量唔多過容量既 \",[\"$\",\"code\",null,{\"children\":\"75%\"}],\"。\"]}]]}],[\"$\",\"tr\",null,{\"children\":[[\"$\",\"td\",null,{\"children\":[\"$\",\"code\",null,{\"children\":\"new HashMap\u003c\u003e(int initialCapacity)\"}]}],[\"$\",\"td\",null,{\"children\":[\"可以用，但需要計算容量，確保資料數量係容量既 \",[\"$\",\"code\",null,{\"children\":\"75%\"}],\" 或以下，否則會觸發 resize。例子：如果己知數量係 \",[\"$\",\"code\",null,{\"children\":\"16\"}],\"，呢個 constructor 會建立一個容量係 \",[\"$\",\"code\",null,{\"children\":\"16\"}],\" 既 \",[\"$\",\"code\",null,{\"children\":\"HashMap\"}],\"，但當我地 \",[\"$\",\"code\",null,{\"children\":\"HashMap#put\"}],\" 第 \",[\"$\",\"code\",null,{\"children\":\"13\"}],\" 筆資料既時候，\",[\"$\",\"code\",null,{\"children\":\"HashMap\"}],\" 就會 resize。\"]}]]}],[\"$\",\"tr\",null,{\"children\":[[\"$\",\"td\",null,{\"children\":[\"$\",\"code\",null,{\"children\":\"new HashMap\u003c\u003e(int initialCapacity, float loadFactor)\"}]}],[\"$\",\"td\",null,{\"children\":[\"最好，因為可以 set load factor 係 \",[\"$\",\"code\",null,{\"children\":\"1\"}],\"，即係 \",[\"$\",\"code\",null,{\"children\":\"new HashMap\u003c\u003e(size, 1)\"}],\"。只有當容量唔夠，\",[\"$\",\"code\",null,{\"children\":\"HashMap\"}],\" 先會 resize。\"]}]]}],[\"$\",\"tr\",null,{\"children\":[[\"$\",\"td\",null,{\"children\":[\"Guava 既 \",[\"$\",\"code\",null,{\"children\":\"Maps#newHashMapWithExpectedSize(int expectedSize)\"}]]}],[\"$\",\"td\",null,{\"children\":[\"可以用，但要注意佢既算式係 \",[\"$\",\"code\",null,{\"children\":\"(int) ((float) expectedSize / 0.75F + 1.0F)\"}],\"，呢個 \",[\"$\",\"code\",null,{\"children\":\"+ 1.0F\"}],\" 有可能會令到容量係真正需要既 \",[\"$\",\"code\",null,{\"children\":\"2\"}],\" 倍。例子：如果己知數量係 \",[\"$\",\"code\",null,{\"children\":\"12\"}],\"，呢個 method 會計到 \",[\"$\",\"code\",null,{\"children\":\"17\"}],\"，從而令 \",[\"$\",\"code\",null,{\"children\":\"HashMap\"}],\" 建立一個容量係 \",[\"$\",\"code\",null,{\"children\":\"32\"}],\" 既 \",[\"$\",\"code\",null,{\"children\":\"HashMap\"}],\"，而唔係容量係 \",[\"$\",\"code\",null,{\"children\":\"16\"}],\"（唔會 resize 既最小容量）既 \",[\"$\",\"code\",null,{\"children\":\"HashMap\"}],\"。\"]}]]}]]}]]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"註：\"}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":[\"理論上，如果出現過多既 collisions，以上既做法都唔可以保證 \",[\"$\",\"code\",null,{\"children\":\"HashMap\"}],\" 唔會 resize。\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[\"實際上，資料本身帶有隨機性，而只要我地寫好啲 \",[\"$\",\"code\",null,{\"children\":\"hashCode\"}],\" method，唔好令到 collision 咁容易發生就得。\"]}],\"\\n\"]}],\"\\n\",[\"$\",\"hr\",null,{}],\"\\n\",[\"$\",\"h1\",null,{\"children\":\"4 筆記\"}],\"\\n\",[\"$\",\"h2\",null,{\"children\":\"4.1 內部運作\"}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":[[\"$\",\"code\",null,{\"children\":\"HashMap#put\"}],\" 係用 \",[\"$\",\"code\",null,{\"children\":\"\u0026 (\u003cbucket size\u003e - 1)\"}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":[\"目的係要知道 key 屬於邊一個 bucket index，所以就需要知道係 \",[\"$\",\"code\",null,{\"children\":\"0\"}],\" 至 \",[\"$\",\"code\",null,{\"children\":\"\u003cbucket size\u003e - 1\"}],\" 邊一個。\"]}],\"\\n\"]}],\"\\n\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[\"JDK 8 既 \",[\"$\",\"code\",null,{\"children\":\"HashMap#resize\"}],\" 係用 \",[\"$\",\"code\",null,{\"children\":\"\u0026 \u003cold bucket size\u003e\"}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":[\"目的係要知道現有既某個 bucket 既每一個 entry 喺新既 bucket array 裡面屬於前半部分（舊既 bucket indexes）定係後半部分（新既 bucket indexes），所以就需要知道新增既 bit 係 \",[\"$\",\"code\",null,{\"children\":\"0\"}],\" 定係 \",[\"$\",\"code\",null,{\"children\":\"1\"}],\"。\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[\"新增既 bit 就係舊 bucket size 既二進制數字既 \",[\"$\",\"code\",null,{\"children\":\"1\"}],\" 字果個位。\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[\"想知道一個二進制數字對象特定既 bits 係 \",[\"$\",\"code\",null,{\"children\":\"0\"}],\" 定係 \",[\"$\",\"code\",null,{\"children\":\"1\"}],\"，就要對佢進行 bit masking 操作。\",\"\\n\",[\"$\",\"ol\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":[\"需要用一個二進制數字作為 mask——只有想要既 bits 係 \",[\"$\",\"code\",null,{\"children\":\"1\"}],\" 而其他唔想要既 bits 係 \",[\"$\",\"code\",null,{\"children\":\"0\"}],\" 既二進制數字。\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[\"用呢個 mask 對二進制數字對象進行 bitwise AND（\",[\"$\",\"code\",null,{\"children\":\"\u0026\"}],\"）操作。\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[\"而對舊 bucket index 既二進制數字進行 bit masking 所得出既結果只有 \",[\"$\",\"code\",null,{\"children\":\"2\"}],\" 個。\",\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":[\"所有 bits 都係 \",[\"$\",\"code\",null,{\"children\":\"0\"}],\"（亦即係 \",[\"$\",\"code\",null,{\"children\":\"0\"}],\"）\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[\"第 \",[\"$\",\"code\",null,{\"children\":\"1\"}],\" 個 bit 係 \",[\"$\",\"code\",null,{\"children\":\"1\"}],\"，其他 bits 係 \",[\"$\",\"code\",null,{\"children\":\"0\"}],\"（亦即係舊 bucket index）\"]}],\"\\n\"]}],\"\\n\"]}],\"\\n\"]}],\"\\n\"]}],\"\\n\"]}],\"\\n\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[\"因為 bucket size 一定係 \",[\"$\",\"code\",null,{\"children\":\"2\"}],\" 既次方數，所以佢既二進制一定係 \",[\"$\",\"code\",null,{\"children\":\"1\"}],\" 後面有 \",[\"$\",\"code\",null,{\"children\":\"N\"}],\" 個 \",[\"$\",\"code\",null,{\"children\":\"0\"}],\"。\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[\"例子：容量由 \",[\"$\",\"code\",null,{\"children\":\"16\"}],\" resize 成 \",[\"$\",\"code\",null,{\"children\":\"32\"}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":[\"舊 \",[\"$\",\"code\",null,{\"children\":\"HashMap\"}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":[\"舊 bucket size \",[\"$\",\"code\",null,{\"children\":\"16\"}],\" 既二進制係 \",[\"$\",\"code\",null,{\"children\":\"10000\"}],\"。\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[\"舊 bucket size \",[\"$\",\"code\",null,{\"children\":\"16\"}],\" - \",[\"$\",\"code\",null,{\"children\":\"1\"}],\" 既二進制係 \",[\"$\",\"code\",null,{\"children\":\"1111\"}],\"。\"]}],\"\\n\"]}],\"\\n\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[\"新 \",[\"$\",\"code\",null,{\"children\":\"HashMap\"}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":[\"新 bucket size \",[\"$\",\"code\",null,{\"children\":\"32\"}],\" 既二進制係 \",[\"$\",\"code\",null,{\"children\":\"100000\"}],\"。\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[\"新 bucket size \",[\"$\",\"code\",null,{\"children\":\"32\"}],\" - \",[\"$\",\"code\",null,{\"children\":\"1\"}],\" 既二進制係 \",[\"$\",\"code\",null,{\"children\":\"11111\"}],\"。\"]}],\"\\n\"]}],\"\\n\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[\"新增既 bit 係指 \",[\"$\",\"code\",null,{\"children\":\"10000\"}],\" 既 \",[\"$\",\"code\",null,{\"children\":\"1\"}],\"（\",[\"$\",\"code\",null,{\"children\":\"2^4\"}],\"）。\",\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":[\"舊 \",[\"$\",\"code\",null,{\"children\":\"HashMap\"}],\" 最大既 bucket index \",[\"$\",\"code\",null,{\"children\":\"1111\"}],\" + \",[\"$\",\"code\",null,{\"children\":\"1\"}],\" = \",[\"$\",\"code\",null,{\"children\":\"10000\"}],\"——第 \",[\"$\",\"code\",null,{\"children\":\"1\"}],\" 個新增既 bucket index。\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[[\"$\",\"code\",null,{\"children\":\"10000\"}],\" 開始直至 \",[\"$\",\"code\",null,{\"children\":\"11111\"}],\" 都係新增既 bucket indexes。\"]}],\"\\n\"]}],\"\\n\"]}],\"\\n\"]}],\"\\n\"]}],\"\\n\"]}],\"\\n\",[\"$\",\"hr\",null,{}],\"\\n\",[\"$\",\"h2\",null,{\"children\":\"4.2 測試用代碼\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"以下既代碼可以幫我地了解 Java 幾時會 resize 我地既 \",[\"$\",\"code\",null,{\"children\":\"HashMap\"}],\"，以及 bucket 既分佈。\"]}],\"\\n\",[\"$\",\"p\",null,{\"children\":[[\"$\",\"code\",null,{\"children\":\"HashMapTest.java\"}],\"：\"]}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"className\":\"language-java\",\"children\":\"public class HashMapTest {\\r\\n\\r\\n    public static void main(String[] args) {\\r\\n\\r\\n        final int cap = 16;\\r\\n        final int size = 28;\\r\\n\\r\\n        final Map\u003cFoo, Integer\u003e map = new HashMap\u003c\u003e(cap);\\r\\n\\r\\n        for (int i=0; i\u003csize; i++) {\\r\\n            map.put(new Foo(i), i);\\r\\n            HashMapDebugUtils.printMap(map);\\r\\n        }\\r\\n    }\\r\\n}\\n\"}]}],\"\\n\",[\"$\",\"p\",null,{\"children\":[[\"$\",\"code\",null,{\"children\":\"HashMapDebugUtils.java\"}],\"：\"]}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"className\":\"language-java\",\"children\":\"$f\"}]}],\"\\n\",[\"$\",\"p\",null,{\"children\":[[\"$\",\"code\",null,{\"children\":\"Foo.java\"}],\"（作為自定義 map key，所以 immutable）：\"]}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"className\":\"language-java\",\"children\":\"public final class Foo {\\r\\n    private final int val;\\r\\n\\r\\n    public Foo(int val) {\\r\\n        this.val = val;\\r\\n    }\\r\\n\\r\\n    @Override\\r\\n    public int hashCode() {\\r\\n        return Math.max(0, val-11);\\r\\n    }\\r\\n\\r\\n    @Override\\r\\n    public boolean equals(Object obj) {\\r\\n        if (this == obj) return true;\\r\\n        if (!(obj instanceof Foo)) return false;\\r\\n        Foo other = (Foo) obj;\\r\\n        return val == other.val;\\r\\n    }\\r\\n}\\n\"}]}],\"\\n\",[\"$\",\"h3\",null,{\"children\":\"4.2.1 Oracle JDK 7 既測試結果\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"執行程式之後，我地可以睇到：\"}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":[\"當容量係 \",[\"$\",\"code\",null,{\"children\":\"16\"}],\" 既情況下，實際數量係有機會去到 \",[\"$\",\"code\",null,{\"children\":\"27\"}],\"。\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[\"當新增第 \",[\"$\",\"code\",null,{\"children\":\"28\"}],\" 個 entry 既時候，容量先至由 \",[\"$\",\"code\",null,{\"children\":\"16\"}],\" 擴大到 \",[\"$\",\"code\",null,{\"children\":\"32\"}],\"。\"]}],\"\\n\"]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"Console output：\"}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"className\":\"language-plaintext\",\"children\":\"$10\"}]}],\"\\n\",[\"$\",\"hr\",null,{}],\"\\n\",[\"$\",\"h3\",null,{\"children\":\"4.2.2 Oracle JDK 8 既測試結果\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"先 uncomment \",[\"$\",\"code\",null,{\"children\":\"printBuckets(bucketArr);\"}],\" 再執行程式，我地可以睇到：\"]}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":[\"當實際數量去到 \",[\"$\",\"code\",null,{\"children\":\"9\"}],\" 而舊容量係 \",[\"$\",\"code\",null,{\"children\":\"16\"}],\"（多過 \",[\"$\",\"code\",null,{\"children\":\"TREEIFY_THRESHOLD\"}],\" 既 \",[\"$\",\"code\",null,{\"children\":\"8\"}],\" 但係容量小過 \",[\"$\",\"code\",null,{\"children\":\"MIN_TREEIFY_CAPACITY\"}],\" 既 \",[\"$\",\"code\",null,{\"children\":\"64\"}],\"），容量會由 \",[\"$\",\"code\",null,{\"children\":\"16\"}],\" 擴大到 \",[\"$\",\"code\",null,{\"children\":\"32\"}],\"。\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[\"當實際數量去到 \",[\"$\",\"code\",null,{\"children\":\"10\"}],\" 而舊容量係 \",[\"$\",\"code\",null,{\"children\":\"32\"}],\"（多過 \",[\"$\",\"code\",null,{\"children\":\"TREEIFY_THRESHOLD\"}],\" 既 \",[\"$\",\"code\",null,{\"children\":\"8\"}],\" 但係容量小過 \",[\"$\",\"code\",null,{\"children\":\"MIN_TREEIFY_CAPACITY\"}],\" 既 \",[\"$\",\"code\",null,{\"children\":\"64\"}],\"），容量會由 \",[\"$\",\"code\",null,{\"children\":\"32\"}],\" 擴大到 \",[\"$\",\"code\",null,{\"children\":\"64\"}],\"。\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[\"當實際數量去到 \",[\"$\",\"code\",null,{\"children\":\"11\"}],\" 而舊容量係 \",[\"$\",\"code\",null,{\"children\":\"64\"}],\"（多過 \",[\"$\",\"code\",null,{\"children\":\"TREEIFY_THRESHOLD\"}],\" 既 \",[\"$\",\"code\",null,{\"children\":\"8\"}],\" 而且容量達到 \",[\"$\",\"code\",null,{\"children\":\"MIN_TREEIFY_CAPACITY\"}],\" 既 \",[\"$\",\"code\",null,{\"children\":\"64\"}],\"），bucket 會由 linked list treeify 成 red-black tree。\"]}],\"\\n\"]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"Console output（省略左部分 bucket 分佈）：\"}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"className\":\"language-plaintext\",\"children\":\"$11\"}]}],\"\\n\",[\"$\",\"hr\",null,{}],\"\\n\",[\"$\",\"h2\",null,{\"children\":\"4.3 Mutable key 既問題\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"正因為 \",[\"$\",\"code\",null,{\"children\":\"HashMap\"}],\" 係用 key object 既 hash 去計算出存放 entry 既 bucket index，如果 key object 既 hash 喺存放 entry 之後改變左，咁又會產生咩變化或者影響呢？我地可以做個簡單實驗。\"]}],\"\\n\",[\"$\",\"p\",null,{\"children\":[[\"$\",\"code\",null,{\"children\":\"Bar.java\"}],\"（mutable）：\"]}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"className\":\"language-java\",\"children\":\"public class Bar {\\r\\n    private int val;\\r\\n\\r\\n    public Bar(int val) {\\r\\n        this.val = val;\\r\\n    }\\r\\n\\r\\n    public void setVal(int val) {\\r\\n        this.val = val;\\r\\n    }\\r\\n\\r\\n    @Override\\r\\n    public int hashCode() {\\r\\n        return val;\\r\\n    }\\r\\n\\r\\n    @Override\\r\\n    public boolean equals(Object obj) {\\r\\n        if (this == obj) return true;\\r\\n        if (!(obj instanceof Bar)) return false;\\r\\n        Bar other = (Bar) obj;\\r\\n        System.out.println(\\\"Bar#equals: \\\" + (val==other.val) + \\\" (\\\" + val + \\\" = \\\" + other.val + \\\")\\\");\\r\\n        return val == other.val;\\r\\n    }\\r\\n}\\n\"}]}],\"\\n\",[\"$\",\"p\",null,{\"children\":[[\"$\",\"code\",null,{\"children\":\"HashMapWithMutableElementTest.java\"}],\"：\"]}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"className\":\"language-java\",\"children\":\"$12\"}]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"解釋：\"}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":[\"我地既 \",[\"$\",\"code\",null,{\"children\":\"HashMap\"}],\" 會用 mutable 既 \",[\"$\",\"code\",null,{\"children\":\"Bar\"}],\" class 作為 key type。\",\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":[[\"$\",\"code\",null,{\"children\":\"Bar#hashCode\"}],\" 會返回 \",[\"$\",\"code\",null,{\"children\":\"int\"}],\" type 既 \",[\"$\",\"code\",null,{\"children\":\"val\"}],\" field value。\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[[\"$\",\"code\",null,{\"children\":\"Bar#equals\"}],\" 會用 \",[\"$\",\"code\",null,{\"children\":\"val\"}],\" field value 黎比較 object equality。\"]}],\"\\n\"]}],\"\\n\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[\"測試流程（Oracle JDK 8）\",\"\\n\",[\"$\",\"ol\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":[\"將 key 係 \",[\"$\",\"code\",null,{\"children\":\"val: 1\"}],\"、value 係 \",[\"$\",\"code\",null,{\"children\":\"one\"}],\" 既 entry 放入 \",[\"$\",\"code\",null,{\"children\":\"HashMap\"}],\"。\",\"\\n\",[\"$\",\"ol\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":[\"Hash 係 \",[\"$\",\"code\",null,{\"children\":\"1\"}],\"，所以會放入 bucket \",[\"$\",\"code\",null,{\"children\":\"1\"}],\"。\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[\"可以見到 bucket \",[\"$\",\"code\",null,{\"children\":\"1\"}],\" 有 \",[\"$\",\"code\",null,{\"children\":\"1\"}],\" 個 entry。\"]}],\"\\n\"]}],\"\\n\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[\"用 \",[\"$\",\"code\",null,{\"children\":\"HashMap#containsKey\"}],\" 測試下 \",[\"$\",\"code\",null,{\"children\":\"val: 1\"}],\" 既 key 係咪存在喺 \",[\"$\",\"code\",null,{\"children\":\"HashMap\"}],\" 裡面。\",\"\\n\",[\"$\",\"ol\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":[\"Hash 係 \",[\"$\",\"code\",null,{\"children\":\"1\"}],\"，所以會喺 bucket \",[\"$\",\"code\",null,{\"children\":\"1\"}],\" 裡面搵。\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[\"Bucket \",[\"$\",\"code\",null,{\"children\":\"1\"}],\" 既 linked list 只有 \",[\"$\",\"code\",null,{\"children\":\"1\"}],\" 個 element，而對呢個 element 既 \",[\"$\",\"code\",null,{\"children\":\"Bar#equals\"}],\" 返回 \",[\"$\",\"code\",null,{\"children\":\"true\"}],\"（\",[\"$\",\"code\",null,{\"children\":\"val\"}],\" \",[\"$\",\"code\",null,{\"children\":\"1\"}],\" 等於 \",[\"$\",\"code\",null,{\"children\":\"1\"}],\"）。\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"結果係存在。\"}],\"\\n\"]}],\"\\n\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[\"將呢個 \",[\"$\",\"code\",null,{\"children\":\"Bar\"}],\" object 既 \",[\"$\",\"code\",null,{\"children\":\"val\"}],\" 改成 \",[\"$\",\"code\",null,{\"children\":\"2\"}],\"。\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[\"用 \",[\"$\",\"code\",null,{\"children\":\"HashMap#containsKey\"}],\" 測試下 \",[\"$\",\"code\",null,{\"children\":\"val: 1\"}],\" 既 key 係咪存在喺 \",[\"$\",\"code\",null,{\"children\":\"HashMap\"}],\" 裡面。\",\"\\n\",[\"$\",\"ol\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":[\"Hash 係 \",[\"$\",\"code\",null,{\"children\":\"1\"}],\"，所以會喺 bucket \",[\"$\",\"code\",null,{\"children\":\"1\"}],\" 裡面搵。\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[\"Bucket \",[\"$\",\"code\",null,{\"children\":\"1\"}],\" 既 linked list 只有 \",[\"$\",\"code\",null,{\"children\":\"1\"}],\" 個 element，但係對呢個 element 既 \",[\"$\",\"code\",null,{\"children\":\"Bar#equals\"}],\" 返回 \",[\"$\",\"code\",null,{\"children\":\"false\"}],\"（\",[\"$\",\"code\",null,{\"children\":\"val\"}],\" \",[\"$\",\"code\",null,{\"children\":\"1\"}],\" 唔等於 \",[\"$\",\"code\",null,{\"children\":\"2\"}],\"）。\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"結果係唔存在。\"}],\"\\n\"]}],\"\\n\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[\"用 \",[\"$\",\"code\",null,{\"children\":\"HashMap#containsKey\"}],\" 測試下 \",[\"$\",\"code\",null,{\"children\":\"val: 2\"}],\" 既 key 係咪存在喺 \",[\"$\",\"code\",null,{\"children\":\"HashMap\"}],\" 裡面。\",\"\\n\",[\"$\",\"ol\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":[\"Hash 係 \",[\"$\",\"code\",null,{\"children\":\"2\"}],\"，所以會喺 bucket \",[\"$\",\"code\",null,{\"children\":\"2\"}],\" 裡面搵。\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[\"Bucket \",[\"$\",\"code\",null,{\"children\":\"2\"}],\" 係空既。\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"結果係唔存在。\"}],\"\\n\"]}],\"\\n\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[\"將 key 係 \",[\"$\",\"code\",null,{\"children\":\"val: 2\"}],\"、value 係 \",[\"$\",\"code\",null,{\"children\":\"two\"}],\" 既 entry 放入 \",[\"$\",\"code\",null,{\"children\":\"HashMap\"}],\"。\",\"\\n\",[\"$\",\"ol\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":[\"Hash 係 \",[\"$\",\"code\",null,{\"children\":\"2\"}],\"，所以會放入 bucket \",[\"$\",\"code\",null,{\"children\":\"2\"}],\"。\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[\"可以見到 bucket \",[\"$\",\"code\",null,{\"children\":\"1\"}],\" 以及 bucket \",[\"$\",\"code\",null,{\"children\":\"2\"}],\" 各有 \",[\"$\",\"code\",null,{\"children\":\"1\"}],\" 個 entry。\"]}],\"\\n\"]}],\"\\n\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[\"用 \",[\"$\",\"code\",null,{\"children\":\"HashMap#remove\"}],\" 測試下刪除 key 係 \",[\"$\",\"code\",null,{\"children\":\"val: 1\"}],\" 既 entry。\",\"\\n\",[\"$\",\"ol\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":[\"Hash 係 \",[\"$\",\"code\",null,{\"children\":\"1\"}],\"，所以會喺 bucket \",[\"$\",\"code\",null,{\"children\":\"1\"}],\" 裡面搵。\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[\"Bucket \",[\"$\",\"code\",null,{\"children\":\"1\"}],\" 既 linked list 只有 \",[\"$\",\"code\",null,{\"children\":\"1\"}],\" 個 element，但係對呢個 element 既 \",[\"$\",\"code\",null,{\"children\":\"Bar#equals\"}],\" 返回 \",[\"$\",\"code\",null,{\"children\":\"false\"}],\"（\",[\"$\",\"code\",null,{\"children\":\"val\"}],\" \",[\"$\",\"code\",null,{\"children\":\"1\"}],\" 唔等於 \",[\"$\",\"code\",null,{\"children\":\"2\"}],\"）。\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[\"冇刪除到 entry，所以返回 \",[\"$\",\"code\",null,{\"children\":\"null\"}],\"。\"]}],\"\\n\"]}],\"\\n\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[\"用 \",[\"$\",\"code\",null,{\"children\":\"HashMap#remove\"}],\" 測試下刪除 key 係 \",[\"$\",\"code\",null,{\"children\":\"val: 2\"}],\" 既 entry。\",\"\\n\",[\"$\",\"ol\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":[\"Hash 係 \",[\"$\",\"code\",null,{\"children\":\"2\"}],\"，所以會喺 bucket \",[\"$\",\"code\",null,{\"children\":\"2\"}],\" 裡面搵。\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[\"Bucket \",[\"$\",\"code\",null,{\"children\":\"2\"}],\" 既 linked list 只有 \",[\"$\",\"code\",null,{\"children\":\"1\"}],\" 個 element，而對呢個 element 既 \",[\"$\",\"code\",null,{\"children\":\"Bar#equals\"}],\" 返回 \",[\"$\",\"code\",null,{\"children\":\"true\"}],\"（\",[\"$\",\"code\",null,{\"children\":\"val\"}],\" \",[\"$\",\"code\",null,{\"children\":\"2\"}],\" 等於 \",[\"$\",\"code\",null,{\"children\":\"2\"}],\"）。\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[\"因為刪除左 entry，所以返回 entry 既 value \",[\"$\",\"code\",null,{\"children\":\"two\"}],\"。\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[\"可以見到 bucket \",[\"$\",\"code\",null,{\"children\":\"1\"}],\" 有 \",[\"$\",\"code\",null,{\"children\":\"1\"}],\" 個 entry，而 bucket \",[\"$\",\"code\",null,{\"children\":\"2\"}],\" 就再冇 entry。\"]}],\"\\n\"]}],\"\\n\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[\"用 \",[\"$\",\"code\",null,{\"children\":\"new HashMap\u003c\u003e(Map\u003c? extends K,? extends V\u003e m)\"}],\" constructor 重新建立一個 \",[\"$\",\"code\",null,{\"children\":\"HashMap\"}],\"，argument 用上述既 \",[\"$\",\"code\",null,{\"children\":\"HashMap\"}],\"。\",\"\\n\",[\"$\",\"ol\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":[\"可以見到只有 \",[\"$\",\"code\",null,{\"children\":\"2\"}],\" 個 buckets——Bucket \",[\"$\",\"code\",null,{\"children\":\"0\"}],\" 有 \",[\"$\",\"code\",null,{\"children\":\"1\"}],\" 個 entry，而 bucket \",[\"$\",\"code\",null,{\"children\":\"1\"}],\" 就冇 entry。\"]}],\"\\n\"]}],\"\\n\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[\"用 \",[\"$\",\"code\",null,{\"children\":\"HashMap#containsKey\"}],\" 測試下 \",[\"$\",\"code\",null,{\"children\":\"val: 2\"}],\" 既 key 係咪存在喺新既 \",[\"$\",\"code\",null,{\"children\":\"HashMap\"}],\" 裡面。\",\"\\n\",[\"$\",\"ol\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":[\"Hash 係 \",[\"$\",\"code\",null,{\"children\":\"2\"}],\"，所以會喺 bucket \",[\"$\",\"code\",null,{\"children\":\"0\"}],\" 裡面搵。\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[\"Bucket \",[\"$\",\"code\",null,{\"children\":\"0\"}],\" 既 linked list 只有 \",[\"$\",\"code\",null,{\"children\":\"1\"}],\" 個 element，而對呢個 element 既 \",[\"$\",\"code\",null,{\"children\":\"Bar#equals\"}],\" 返回 \",[\"$\",\"code\",null,{\"children\":\"true\"}],\"（\",[\"$\",\"code\",null,{\"children\":\"val\"}],\" \",[\"$\",\"code\",null,{\"children\":\"2\"}],\" 等於 \",[\"$\",\"code\",null,{\"children\":\"2\"}],\"）。\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"結果係存在。\"}],\"\\n\"]}],\"\\n\"]}],\"\\n\"]}],\"\\n\"]}],\"\\n\"]}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"因為 \",[\"$\",\"code\",null,{\"children\":\"HashSet\"}],\" 既內部都係用一個 \",[\"$\",\"code\",null,{\"children\":\"HashMap\"}],\" object 黎實現，令到 elements 唔會重複，所以如果啲 elements 既 class 係 mutable，都會有一樣既問題。\"]}],\"\\n\",[\"$\",\"p\",null,{\"children\":[[\"$\",\"code\",null,{\"children\":\"HashSetWithMutableElementTest.java\"}],\"：\"]}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"className\":\"language-java\",\"children\":\"public class HashSetWithMutableElementTest {\\r\\n\\r\\n    public static void main(String[] args) throws Exception {\\r\\n\\r\\n        final Bar bar = new Bar(1);\\r\\n\\r\\n        final Set\u003cBar\u003e set = new HashSet\u003c\u003e();\\r\\n        set.add(bar);\\r\\n\\r\\n        System.out.println(set.contains(new Bar(1))); // true\\r\\n\\r\\n        bar.setVal(2);\\r\\n\\r\\n        System.out.println(set.contains(new Bar(1))); // false\\r\\n        System.out.println(set.contains(new Bar(2))); // false\\r\\n\\r\\n        set.add(new Bar(2));\\r\\n\\r\\n        System.out.println(set.remove(new Bar(1))); // false\\r\\n        System.out.println(set.remove(new Bar(2))); // true\\r\\n\\r\\n        final Set\u003cBar\u003e newMap = new HashSet\u003c\u003e(set);\\r\\n        System.out.println(newMap.contains(new Bar(2))); // true\\r\\n        System.out.println(newMap.remove(new Bar(2))); // true\\r\\n    }\\r\\n}\\n\"}]}],\"\\n\",[\"$\",\"hr\",null,{}],\"\\n\",[\"$\",\"h1\",null,{\"children\":\"5 參考資料\"}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":[\"$\",\"a\",null,{\"href\":\"https://javamana.com/2021/02/20210202162541893w.html\",\"children\":\"HashMap - JDK 7 vs JDK 8\"}]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[\"$\",\"a\",null,{\"href\":\"https://elsef.com/2019/11/11/JDK1.8%E4%B8%ADHashMap%E7%9A%84resize%E6%93%8D%E4%BD%9C/\",\"children\":\"JDK 1.8 中 HashMap 的 resize 優化\"}]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[\"$\",\"a\",null,{\"href\":\"https://segmentfault.com/a/1190000015812438\",\"children\":\"深入理解 HashMap（四）：關鍵源碼逐行分析之 resize 擴容\"}]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[\"$\",\"a\",null,{\"href\":\"https://zhuanlan.zhihu.com/p/369808654\",\"children\":\"你給 HashMap 初始化了容量，卻讓性能變加更糟？\"}]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[\"$\",\"a\",null,{\"href\":\"https://stackoverflow.com/questions/2414117/explanation-of-hashmaphashint-method\",\"children\":\"StackOverflow - Explanation of HashMap#hash(int) method\"}]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[\"$\",\"a\",null,{\"href\":\"https://github.com/openjdk/jdk/blob/jdk7-b147/jdk/src/share/classes/java/util/HashMap.java\",\"children\":[\"OpenJDK 7 - \",[\"$\",\"code\",null,{\"children\":\"HashMap.java\"}],\" source code\"]}]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[\"$\",\"a\",null,{\"href\":\"https://github.com/openjdk/jdk/blob/jdk8-b120/jdk/src/share/classes/java/util/HashMap.java\",\"children\":[\"OpenJDK 8 - \",[\"$\",\"code\",null,{\"children\":\"HashMap.java\"}],\" source code\"]}]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[\"$\",\"a\",null,{\"href\":\"https://github.com/openjdk/jdk/blob/jdk8-b120/jdk/src/share/classes/java/util/HashSet.java\",\"children\":[\"OpenJDK 8 - \",[\"$\",\"code\",null,{\"children\":\"HashSet.java\"}],\" source code\"]}]}],\"\\n\"]}]],null,[\"$\",\"$L13\",null,{\"children\":\"$L14\"}]]}],{},null,false]},null,false]},null,false]},null,false]},null,false],[\"$\",\"$1\",\"h\",{\"children\":[null,[\"$\",\"$1\",\"h7KnOUWmmdmPx53JPp9cG\",{\"children\":[[\"$\",\"$L15\",null,{\"children\":\"$L16\"}],[\"$\",\"$L17\",null,{\"children\":\"$L18\"}],null]}]]}],false]],\"m\":\"$undefined\",\"G\":[\"$19\",\"$undefined\"],\"s\":false,\"S\":true}\n"])</script><script>self.__next_f.push([1,"18:[[\"$\",\"meta\",\"0\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}]]\n16:[[\"$\",\"meta\",\"0\",{\"charSet\":\"utf-8\"}],[\"$\",\"title\",\"1\",{\"children\":\"Michael Chung's e-Portfolio\"}],[\"$\",\"meta\",\"2\",{\"name\":\"description\",\"content\":\"Powered by Next.js and React\"}]]\n"])</script><script>self.__next_f.push([1,"14:null\n"])</script></body></html>